<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: /home/zoe/Mbed Programs/esp_code/mbed-os/platform/FEATURE_EXPERIMENTAL_API/FEATURE_PSA/TARGET_MBED_PSA_SRV/services/attestation/qcbor/inc/UsefulBuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('UsefulBuf_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">UsefulBuf.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="UsefulBuf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuseful__buf__c.html">useful_buf_c</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuseful__buf.html">useful_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuseful__out__buf.html">useful_out_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuseful__input__buf.html">useful_input_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aef281b38ce49e9413dad0893d225c70d" id="r_aef281b38ce49e9413dad0893d225c70d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a>&#160;&#160;&#160;((<a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>) {NULL, 0})</td></tr>
<tr class="separator:aef281b38ce49e9413dad0893d225c70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac590bc10c66f484fe139b361fe01c339" id="r_ac590bc10c66f484fe139b361fe01c339"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac590bc10c66f484fe139b361fe01c339">NULLUsefulBuf</a>&#160;&#160;&#160;((<a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a>) {NULL, 0})</td></tr>
<tr class="separator:ac590bc10c66f484fe139b361fe01c339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778543dc5c8297cbfdc8b1716ebce423" id="r_a778543dc5c8297cbfdc8b1716ebce423"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a778543dc5c8297cbfdc8b1716ebce423">UsefulBuf_FROM_SZ_LITERAL</a>(szString)</td></tr>
<tr class="separator:a778543dc5c8297cbfdc8b1716ebce423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc60f139ca7be95de2de18e5ea966ee" id="r_aacc60f139ca7be95de2de18e5ea966ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacc60f139ca7be95de2de18e5ea966ee">UsefulBuf_FROM_BYTE_ARRAY_LITERAL</a>(pBytes)</td></tr>
<tr class="separator:aacc60f139ca7be95de2de18e5ea966ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace69a6220419dd9dc204770c5b87efb6" id="r_ace69a6220419dd9dc204770c5b87efb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace69a6220419dd9dc204770c5b87efb6">UsefulBuf_MAKE_STACK_UB</a>(name,  size)</td></tr>
<tr class="separator:ace69a6220419dd9dc204770c5b87efb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eb36e1bdeab13b58d8a077d26bee86" id="r_a98eb36e1bdeab13b58d8a077d26bee86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98eb36e1bdeab13b58d8a077d26bee86">UsefulBuf_FROM_BYTE_ARRAY</a>(pBytes)</td></tr>
<tr class="separator:a98eb36e1bdeab13b58d8a077d26bee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fed8f0b3943666846bae738004dfbe" id="r_a54fed8f0b3943666846bae738004dfbe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54fed8f0b3943666846bae738004dfbe">UsefulOutBuf_MakeOnStack</a>(name,  size)</td></tr>
<tr class="separator:a54fed8f0b3943666846bae738004dfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e8acba0f0d344d630494c9bd76ec7b" id="r_af1e8acba0f0d344d630494c9bd76ec7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1e8acba0f0d344d630494c9bd76ec7b">UIB_MAGIC</a>&#160;&#160;&#160;(0xB00F)</td></tr>
<tr class="separator:af1e8acba0f0d344d630494c9bd76ec7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a05d9f65b59b672ec72153a346ef7cdad" id="r_a05d9f65b59b672ec72153a346ef7cdad"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structuseful__buf__c.html">useful_buf_c</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td></tr>
<tr class="separator:a05d9f65b59b672ec72153a346ef7cdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7643740fe44091c5c6507368863e85c" id="r_aa7643740fe44091c5c6507368863e85c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structuseful__buf.html">useful_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a></td></tr>
<tr class="separator:aa7643740fe44091c5c6507368863e85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f01ed9a781335a27e651b4d0fe99cd" id="r_a83f01ed9a781335a27e651b4d0fe99cd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structuseful__out__buf.html">useful_out_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a></td></tr>
<tr class="separator:a83f01ed9a781335a27e651b4d0fe99cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40147dc1c6e6ab03d7690b195b21603f" id="r_a40147dc1c6e6ab03d7690b195b21603f"><td class="memItemLeft" align="right" valign="top"><a id="a40147dc1c6e6ab03d7690b195b21603f" name="a40147dc1c6e6ab03d7690b195b21603f"></a>
typedef struct <a class="el" href="structuseful__input__buf.html">useful_input_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>UsefulInputBuf</b></td></tr>
<tr class="separator:a40147dc1c6e6ab03d7690b195b21603f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a82cbe966444cc482aaeef036ae801ebd" id="r_a82cbe966444cc482aaeef036ae801ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82cbe966444cc482aaeef036ae801ebd">UsefulBuf_CopyOffset</a> (<a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> Dest, size_t uOffset, const <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> Src)</td></tr>
<tr class="memdesc:a82cbe966444cc482aaeef036ae801ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> into another at an offset.  <br /></td></tr>
<tr class="separator:a82cbe966444cc482aaeef036ae801ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57b19dfa682d1806296f891bee01693" id="r_ab57b19dfa682d1806296f891bee01693"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab57b19dfa682d1806296f891bee01693">UsefulBuf_Compare</a> (const <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> UB1, const <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> UB2)</td></tr>
<tr class="memdesc:ab57b19dfa682d1806296f891bee01693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two UsefulBufCs.  <br /></td></tr>
<tr class="separator:ab57b19dfa682d1806296f891bee01693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a028eb81150d93fc1fc83b1ea7ac6b" id="r_a08a028eb81150d93fc1fc83b1ea7ac6b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08a028eb81150d93fc1fc83b1ea7ac6b">UsefulBuf_FindBytes</a> (<a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> BytesToSearch, <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> BytesToFind)</td></tr>
<tr class="memdesc:a08a028eb81150d93fc1fc83b1ea7ac6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find one <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> in another.  <br /></td></tr>
<tr class="separator:a08a028eb81150d93fc1fc83b1ea7ac6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac63be86d630aeeb748cfd4491360f0" id="r_a8ac63be86d630aeeb748cfd4491360f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ac63be86d630aeeb748cfd4491360f0">UsefulOutBuf_Init</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *me, <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> Storage)</td></tr>
<tr class="memdesc:a8ac63be86d630aeeb748cfd4491360f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and supply the actual output buffer.  <br /></td></tr>
<tr class="separator:a8ac63be86d630aeeb748cfd4491360f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d48f0714f1a12aad93e8513f587b1a" id="r_ad3d48f0714f1a12aad93e8513f587b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3d48f0714f1a12aad93e8513f587b1a">UsefulOutBuf_InsertUsefulBuf</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *me, <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> NewData, size_t uPos)</td></tr>
<tr class="memdesc:ad3d48f0714f1a12aad93e8513f587b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts bytes into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:ad3d48f0714f1a12aad93e8513f587b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda41e435b1d4464b9519005b1b01144" id="r_abda41e435b1d4464b9519005b1b01144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abda41e435b1d4464b9519005b1b01144">UsefulOutBuf_OutUBuf</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *me)</td></tr>
<tr class="memdesc:abda41e435b1d4464b9519005b1b01144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the resulting valid data in a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:abda41e435b1d4464b9519005b1b01144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5873f5e6697f2bbd6226f5d3ad4594" id="r_a7f5873f5e6697f2bbd6226f5d3ad4594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f5873f5e6697f2bbd6226f5d3ad4594">UsefulOutBuf_CopyOut</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *me, <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> Dest)</td></tr>
<tr class="memdesc:a7f5873f5e6697f2bbd6226f5d3ad4594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the valid data out into a supplied buffer.  <br /></td></tr>
<tr class="separator:a7f5873f5e6697f2bbd6226f5d3ad4594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4991ba215aced8a7c98da24a5e307740" id="r_a4991ba215aced8a7c98da24a5e307740"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4991ba215aced8a7c98da24a5e307740">UsefulInputBuf_GetBytes</a> (<a class="el" href="structuseful__input__buf.html">UsefulInputBuf</a> *me, size_t uNum)</td></tr>
<tr class="memdesc:a4991ba215aced8a7c98da24a5e307740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to bytes out of the input buffer.  <br /></td></tr>
<tr class="separator:a4991ba215aced8a7c98da24a5e307740"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The goal of this code is to make buffer and pointer manipulation easier and safer when working with binary data.</p>
<p>You use the <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a>, <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> and UsefulInputBuf structures to represent buffers rather than ad hoc pointers and lengths.</p>
<p>With these it will often be possible to write code that does little or no direct pointer manipulation for copying and formatting data. For example the QCBOR encoder was rewritten using these and has no direct pointer manipulation.</p>
<p>While it is true that object code using these functions will be a little larger and slower than a white-knuckle clever use of pointers might be, but not by that much or enough to have an affect for most use cases. For security-oriented code this is highly worthwhile. Clarity, simplicity, reviewability and are more important.</p>
<p>There are some extra sanity and double checks in this code to help catch coding errors and simple memory corruption. They are helpful, but not a substitute for proper code review, input validation and such.</p>
<p>This code consists of a lot of inline functions and a few that are not. It should not generate very much object code, especially with the optimizer turned up to -Os or -O3. The idea is that the inline functions are easier to review and understand and the optimizer does the work of making the code small. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac590bc10c66f484fe139b361fe01c339" name="ac590bc10c66f484fe139b361fe01c339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac590bc10c66f484fe139b361fe01c339">&#9670;&#160;</a></span>NULLUsefulBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NULLUsefulBuf&#160;&#160;&#160;((<a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a>) {NULL, 0})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A NULL <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> is one that has no memory associated the say way NULL points to nothing. It does not matter what len is. </p>

</div>
</div>
<a id="aef281b38ce49e9413dad0893d225c70d" name="aef281b38ce49e9413dad0893d225c70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef281b38ce49e9413dad0893d225c70d">&#9670;&#160;</a></span>NULLUsefulBufC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NULLUsefulBufC&#160;&#160;&#160;((<a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>) {NULL, 0})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "NULL" <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> is one that has no value in the same way a NULL pointer has no value. A <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> is NULL when the ptr field is NULL. It doesn't matter what len is. See UsefulBuf_IsEmpty() for the distinction between NULL and empty. </p>

</div>
</div>
<a id="af1e8acba0f0d344d630494c9bd76ec7b" name="af1e8acba0f0d344d630494c9bd76ec7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e8acba0f0d344d630494c9bd76ec7b">&#9670;&#160;</a></span>UIB_MAGIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UIB_MAGIC&#160;&#160;&#160;(0xB00F)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UsefulInputBuf is the counterpart to <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> and is for parsing data read or received. Initialize it with the data from the network and its length. Then use the functions here to get the various data types out of it. It maintains a position for getting the next item. This means you don't have to track a pointer as you get each object. UsefulInputBuf does that for you and makes sure it never goes off the end of the buffer. The QCBOR implementation parser makes use of this for all its pointer math and length checking.</p>
<p>UsefulInputBuf also maintains an internal error state so you do not have to. Once data has been requested off the end of the buffer, it goes into an error state. You can keep calling functions to get more data but they will either return 0 or NULL. As long as you don't dereference the NULL, you can wait until all data items have been fetched before checking for the error and this can simplify your code.</p>
<p>The integer and float parsing expects network byte order (big endian). Network byte order is what is used by TCP/IP, CBOR and most internet protocols.</p>
<p>Lots of inlining is used to keep code size down. The code optimizer, particularly with the -Os, also reduces code size a lot. The only non-inline code is <a class="el" href="#a4991ba215aced8a7c98da24a5e307740" title="Get pointer to bytes out of the input buffer.">UsefulInputBuf_GetBytes()</a> which is less than 100 bytes so use of UsefulInputBuf doesn't add much code for all the messy hard-to-get right issues with parsing in C that is solves.</p>
<p>The parse context size is: 64-bit machine: 16 + 8 + 2 + 1 (5 bytes padding to align) = 32 bytes 32-bit machine: 8 + 4 + 2 + 1 (1 byte padding to align) = 16 bytes </p>

</div>
</div>
<a id="a98eb36e1bdeab13b58d8a077d26bee86" name="a98eb36e1bdeab13b58d8a077d26bee86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98eb36e1bdeab13b58d8a077d26bee86">&#9670;&#160;</a></span>UsefulBuf_FROM_BYTE_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulBuf_FROM_BYTE_ARRAY</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pBytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((<a class="code hl_typedef" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a>) {(pBytes), <span class="keyword">sizeof</span>(pBytes)})</div>
<div class="ttc" id="aUsefulBuf_8h_html_aa7643740fe44091c5c6507368863e85c"><div class="ttname"><a href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a></div><div class="ttdeci">struct useful_buf UsefulBuf</div></div>
</div><!-- fragment --><p>Make a byte array in to a <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> </p>

</div>
</div>
<a id="aacc60f139ca7be95de2de18e5ea966ee" name="aacc60f139ca7be95de2de18e5ea966ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc60f139ca7be95de2de18e5ea966ee">&#9670;&#160;</a></span>UsefulBuf_FROM_BYTE_ARRAY_LITERAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulBuf_FROM_BYTE_ARRAY_LITERAL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pBytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((<a class="code hl_typedef" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>) {(pBytes), <span class="keyword">sizeof</span>(pBytes)})</div>
<div class="ttc" id="aUsefulBuf_8h_html_a05d9f65b59b672ec72153a346ef7cdad"><div class="ttname"><a href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></div><div class="ttdeci">struct useful_buf_c UsefulBufC</div></div>
</div><!-- fragment --><p>Convert a literal byte array to a <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>.</p>
<p>pBytes must be a literal string that you can take sizeof. It will not work on non-literal arrays. </p>

</div>
</div>
<a id="a778543dc5c8297cbfdc8b1716ebce423" name="a778543dc5c8297cbfdc8b1716ebce423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778543dc5c8297cbfdc8b1716ebce423">&#9670;&#160;</a></span>UsefulBuf_FROM_SZ_LITERAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulBuf_FROM_SZ_LITERAL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>szString</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((<a class="code hl_typedef" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>) {(szString), <span class="keyword">sizeof</span>(szString)-1})</div>
</div><!-- fragment --><p>Convert a literal string to a <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>.</p>
<p>szString must be a literal string that you can take sizeof. This is better for literal strings than UsefulBuf_FromSZ() because it generates less code. It will not work on non-literal strings.</p>
<p>The terminating \0 (NULL) is NOT included in the length! </p>

</div>
</div>
<a id="ace69a6220419dd9dc204770c5b87efb6" name="ace69a6220419dd9dc204770c5b87efb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace69a6220419dd9dc204770c5b87efb6">&#9670;&#160;</a></span>UsefulBuf_MAKE_STACK_UB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulBuf_MAKE_STACK_UB</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    uint8_t    __pBuf##name[(size)];\</div>
<div class="line">    <a class="code hl_typedef" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a>  name = {__pBuf##name , <span class="keyword">sizeof</span>( __pBuf##name )}</div>
</div><!-- fragment --><p>Make an automatic variable with name of type <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> and point it to a stack variable of the give size </p>

</div>
</div>
<a id="a54fed8f0b3943666846bae738004dfbe" name="a54fed8f0b3943666846bae738004dfbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fed8f0b3943666846bae738004dfbe">&#9670;&#160;</a></span>UsefulOutBuf_MakeOnStack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulOutBuf_MakeOnStack</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">   uint8_t       __pBuf##name[(size)];\</div>
<div class="line">   <a class="code hl_typedef" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>  name;\</div>
<div class="line">   UsefulOutBuf_Init(&amp;(name), (<a class="code hl_typedef" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a>){__pBuf##name, (size)});</div>
<div class="ttc" id="aUsefulBuf_8h_html_a83f01ed9a781335a27e651b4d0fe99cd"><div class="ttname"><a href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a></div><div class="ttdeci">struct useful_out_buf UsefulOutBuf</div></div>
</div><!-- fragment --><p>Convenience marco to make a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> on the stack and initialize it with stack buffer </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa7643740fe44091c5c6507368863e85c" name="aa7643740fe44091c5c6507368863e85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7643740fe44091c5c6507368863e85c">&#9670;&#160;</a></span>UsefulBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structuseful__buf.html">useful_buf</a> <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The non-const <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> typically used for some allocated memory that is to be filled in. The len is the amount of memory, not the length of the valid data in the buffer. </p>

</div>
</div>
<a id="a05d9f65b59b672ec72153a346ef7cdad" name="a05d9f65b59b672ec72153a346ef7cdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d9f65b59b672ec72153a346ef7cdad">&#9670;&#160;</a></span>UsefulBufC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structuseful__buf__c.html">useful_buf_c</a> <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> and <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> are simple data structures to hold a pointer and length for a binary data. In C99 this data structure can be passed on the stack making a lot of code cleaner than carrying around a pointer and length as two parameters.</p>
<p>This is also conducive to secure code practice as the lengths are always carried with the pointer and the convention for handling a pointer and a length is clear.</p>
<p>While it might be possible to write buffer and pointer code more efficiently in some use cases, the thought is that unless there is an extreme need for performance (e.g., you are building a gigabit-per-second IP router), it is probably better to have cleaner code you can be most certain about the security of.</p>
<p>The non-const <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> is usually used to refer a buffer to be filled in. The length is the size of the buffer.</p>
<p>The const <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> is usually used to refer to some data that has been filled in. The length is amount of valid data pointed to.</p>
<p>A common use is to pass a <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> to a function, the function fills it in, the function returns a <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a>. The pointer is the same in both.</p>
<p>A <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> is NULL, it has no value, when the ptr in it is NULL.</p>
<p>There are utility functions for the following:</p><ul>
<li>Checking for UsefulBufs that are NULL, empty or both</li>
<li>Copying, copying with offset, copying head or tail</li>
<li>Comparing and finding substrings</li>
<li>Initializating</li>
<li>Create initialized const <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> from compiler literals</li>
<li>Create initialized const <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> from NULL-terminated string</li>
<li>Make an empty <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> on the stack</li>
</ul>
<p>See also <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. It is a richer structure that has both the size of the valid data and the size of the buffer.</p>
<p><a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> is only 16 or 8 bytes on a 64- or 32-bit machine so it can go on the stack and be a function parameter or return value.</p>
<p><a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> is kind of like the Useful Pot Pooh gave Eeyore on his birthday. Eeyore's balloon fits beautifully, "it goes in and out like anything". </p>

</div>
</div>
<a id="a83f01ed9a781335a27e651b4d0fe99cd" name="a83f01ed9a781335a27e651b4d0fe99cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f01ed9a781335a27e651b4d0fe99cd">&#9670;&#160;</a></span>UsefulOutBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structuseful__out__buf.html">useful_out_buf</a> <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> is a structure and functions (an object) that are good for serializing data into a buffer such as is often done with network protocols or data written to files.</p>
<p>The main idea is that all the pointer manipulation for adding data is done by <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> functions so the caller doesn't have to do any. All the pointer manipulation is centralized here. This code will have been reviewed and written carefully so it spares the caller of much of this work and results in much safer code with much less work.</p>
<p>The functions to add data to the output buffer always check the length and will never write off the end of the output buffer. If an attempt to add data that will not fit is made, an internal error flag will be set and further attempts to add data will not do anything.</p>
<p>Basically, if you initialized with the correct buffer, there is no way to ever write off the end of that buffer when calling the Add and Insert functions here.</p>
<p>The functions to add data do not return an error. The working model is that the caller just makes all the calls to add data without any error checking on each one. The error is instead checked after all the data is added when the result is to be used. This makes the caller's code cleaner.</p>
<p>There is a utility function to get the error status anytime along the way if the caller wants. There are functions to see how much room is left and see if some data will fit too, but their use is generally not necessary.</p>
<p>The general call flow is like this:</p>
<ul>
<li>Initialize the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> with the buffer that is to have the data added. The caller allocates the buffer. It can be heap or stack or shared memory (or other).</li>
<li>Make calls to add data to the output buffer. Insert and append are both supported. The append and insert calls will never write off the end of the buffer.</li>
<li>When all data is added, check the error status to make sure everything fit.</li>
<li>Get the resulting serialized data either as a <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> (a pointer and length) or have it copied to another buffer.</li>
</ul>
<p><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> can be initialized with just a buffer length by passing NULL as the pointer to the output buffer. This is useful if you want to go through the whole serialization process to either see if it will fit into a given buffer or compute the size of the buffer needed. Pass a very large buffer size when calling Init, if you want just to compute the size.</p>
<p>Some inexpensive simple sanity checks are performed before every data addition to guard against use of an uninitialized or corrupted <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.</p>
<p>This has been used to create a CBOR encoder. The CBOR encoder has almost no pointer manipulation in it, is much easier to read, and easier to review.</p>
<p>A <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> is 27 bytes or 15 bytes on 64- or 32-bit machines so it can go on the stack or be a C99 function parameter. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab57b19dfa682d1806296f891bee01693" name="ab57b19dfa682d1806296f891bee01693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57b19dfa682d1806296f891bee01693">&#9670;&#160;</a></span>UsefulBuf_Compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UsefulBuf_Compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two UsefulBufCs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB1</td><td>The destination buffer to copy into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UB2</td><td>The source to copy from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if equal...</dd></dl>
<p>Returns a negative value if UB1 if is less than UB2. UB1 is less than UB2 if it is shorter or the first byte that is not the same is less.</p>
<p>Returns 0 if the UsefulBufs are the same.</p>
<p>Returns a positive value if UB2 is less than UB1.</p>
<p>All that is of significance is that the result is positive, negative or 0. (This doesn't return the difference between the first non-matching byte like memcmp). </p>

</div>
</div>
<a id="a82cbe966444cc482aaeef036ae801ebd" name="a82cbe966444cc482aaeef036ae801ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cbe966444cc482aaeef036ae801ebd">&#9670;&#160;</a></span>UsefulBuf_CopyOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> UsefulBuf_CopyOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>Dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>Src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy one <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> into another at an offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dest</td><td>Destiation buffer to copy into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uOffset</td><td>The byte offset in Dest at which to copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Src</td><td>The bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer and length of the copy</dd></dl>
<p>This fails and returns NULLUsefulBufC Src.len + uOffset &gt; Dest.len.</p>
<p>Like memcpy, there is no check for NULL. If NULL is passed this will crash.</p>
<p>There is an assumption that there is valid data in Dest up to uOffset as the resulting <a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> returned starts at the beginning of Dest and goes to Src.len + uOffset. </p>

</div>
</div>
<a id="a08a028eb81150d93fc1fc83b1ea7ac6b" name="a08a028eb81150d93fc1fc83b1ea7ac6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a028eb81150d93fc1fc83b1ea7ac6b">&#9670;&#160;</a></span>UsefulBuf_FindBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UsefulBuf_FindBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>BytesToSearch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>BytesToFind</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find one <a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> in another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesToSearch</td><td><a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> to search through </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesToFind</td><td><a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> with bytes to be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of found bytes or SIZE_MAX if not found. </dd></dl>

</div>
</div>
<a id="a4991ba215aced8a7c98da24a5e307740" name="a4991ba215aced8a7c98da24a5e307740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4991ba215aced8a7c98da24a5e307740">&#9670;&#160;</a></span>UsefulInputBuf_GetBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * UsefulInputBuf_GetBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuseful__input__buf.html">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>me</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uNum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to bytes out of the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">me</td><td>Pointer to the UsefulInputBuf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uNum</td><td>Number of bytes to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to bytes.</dd></dl>
<p>This consumes n bytes from the input buffer. It returns a pointer to the start of the n bytes.</p>
<p>If there are not n bytes in the input buffer, NULL will be returned and an error will be set.</p>
<p>It advances the current position by n bytes. </p>

</div>
</div>
<a id="a7f5873f5e6697f2bbd6226f5d3ad4594" name="a7f5873f5e6697f2bbd6226f5d3ad4594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5873f5e6697f2bbd6226f5d3ad4594">&#9670;&#160;</a></span>UsefulOutBuf_CopyOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> UsefulOutBuf_CopyOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>me</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>Dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the valid data out into a supplied buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">me</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Dest</td><td>The destination buffer to copy into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer and length of copied data.</dd></dl>
<p>This is the same as <a class="el" href="#abda41e435b1d4464b9519005b1b01144" title="Returns the resulting valid data in a UsefulOutBuf.">UsefulOutBuf_OutUBuf()</a> except it copies the data. </p>

</div>
</div>
<a id="a8ac63be86d630aeeb748cfd4491360f0" name="a8ac63be86d630aeeb748cfd4491360f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac63be86d630aeeb748cfd4491360f0">&#9670;&#160;</a></span>UsefulOutBuf_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UsefulOutBuf_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>me</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>Storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize and supply the actual output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">me</td><td>The <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Storage</td><td><a class="el" href="classBuffer.html">Buffer</a> to output into</td></tr>
  </table>
  </dd>
</dl>
<p>Intializes the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> with storage. Sets the current position to the beginning of the buffer clears the error.</p>
<p>This must be called before the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> is used. </p>

</div>
</div>
<a id="ad3d48f0714f1a12aad93e8513f587b1a" name="ad3d48f0714f1a12aad93e8513f587b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d48f0714f1a12aad93e8513f587b1a">&#9670;&#160;</a></span>UsefulOutBuf_InsertUsefulBuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UsefulOutBuf_InsertUsefulBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>me</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>NewData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts bytes into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">me</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NewData</td><td><a class="el" href="#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> with the bytes to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert</td></tr>
  </table>
  </dd>
</dl>
<p>NewData is the pointer and length for the bytes to be added to the output buffer. There must be room in the output buffer for all of NewData or an error will occur.</p>
<p>The insertion point must be between 0 and the current valid data. If not an error will occur. Appending data to the output buffer is achieved by inserting at the end of the valid data. This can be retrieved by calling UsefulOutBuf_GetEndPosition().</p>
<p>When insertion is performed, the bytes between the insertion point and the end of data previously added to the output buffer is slid to the right to make room for the new data.</p>
<p>Overlapping buffers are OK. NewData can point to data in the output buffer.</p>
<p>If an error occurs an error state is set in the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. No error is returned. All subsequent attempts to add data will do nothing.</p>
<p>Call UsefulOutBuf_GetError() to find out if there is an error. This is usually not needed until all additions of data are complete. </p>

</div>
</div>
<a id="abda41e435b1d4464b9519005b1b01144" name="abda41e435b1d4464b9519005b1b01144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda41e435b1d4464b9519005b1b01144">&#9670;&#160;</a></span>UsefulOutBuf_OutUBuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> UsefulOutBuf_OutUBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>me</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the resulting valid data in a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">me</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The valid data in <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.</dd></dl>
<p>The storage for the returned data is Storage parameter passed to <a class="el" href="#a8ac63be86d630aeeb748cfd4491360f0" title="Initialize and supply the actual output buffer.">UsefulOutBuf_Init()</a>. See also <a class="el" href="#a7f5873f5e6697f2bbd6226f5d3ad4594" title="Copies the valid data out into a supplied buffer.">UsefulOutBuf_CopyOut()</a>.</p>
<p>This can be called anytime and many times to get intermediate results. It doesn't change the data or reset the current position so you can keep adding data. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5fdebfbd0a4b5643a5e85bf3c8b1558b.html">mbed-os</a></li><li class="navelem"><a class="el" href="dir_d00fafdb9414f6e624fcf4d73ffde065.html">platform</a></li><li class="navelem"><a class="el" href="dir_a72924067aea8bbead751f11070268f4.html">FEATURE_EXPERIMENTAL_API</a></li><li class="navelem"><a class="el" href="dir_007a19531d3d09289f9f9c2cf309e91b.html">FEATURE_PSA</a></li><li class="navelem"><a class="el" href="dir_05e0d8a557d855fa23572451f1c8ea18.html">TARGET_MBED_PSA_SRV</a></li><li class="navelem"><a class="el" href="dir_ca746bf8ecd12d766019f43663efcc0b.html">services</a></li><li class="navelem"><a class="el" href="dir_923835f9769c78775a68e44a6b879543.html">attestation</a></li><li class="navelem"><a class="el" href="dir_3e8e74e557914f05fcb63c739dc062d4.html">qcbor</a></li><li class="navelem"><a class="el" href="dir_39375c5e13307d3e1d0539a6cbb9bd8a.html">inc</a></li><li class="navelem"><a class="el" href="UsefulBuf_8h.html">UsefulBuf.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
