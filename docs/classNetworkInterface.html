<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: NetworkInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classNetworkInterface.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classNetworkInterface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">NetworkInterface Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span><div class="ingroups"><a class="el" href="group__netinterface.html">Netinterface</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="NetworkInterface_8h_source.html">NetworkInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetworkInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNetworkInterface.png" usemap="#NetworkInterface_map" alt=""/>
  <map id="NetworkInterface_map" name="NetworkInterface_map">
<area href="classDNS.html" alt="DNS" shape="rect" coords="0,0,131,24"/>
<area href="classCellularInterface.html" alt="CellularInterface" shape="rect" coords="141,112,272,136"/>
<area href="classEMACInterface.html" alt="EMACInterface" shape="rect" coords="141,168,272,192"/>
<area href="classEthInterface.html" alt="EthInterface" shape="rect" coords="141,224,272,248"/>
<area href="classInterfaceNanostack.html" alt="InterfaceNanostack" shape="rect" coords="141,280,272,304"/>
<area href="classL3IPInterface.html" alt="L3IPInterface" shape="rect" coords="141,336,272,360"/>
<area href="classMeshInterface.html" alt="MeshInterface" shape="rect" coords="141,392,272,416"/>
<area href="classPPPInterface.html" alt="PPPInterface" shape="rect" coords="141,448,272,472"/>
<area href="classWiFiInterface.html" alt="WiFiInterface" shape="rect" coords="141,504,272,528"/>
<area href="classstubNetworkInterface.html" alt="stubNetworkInterface" shape="rect" coords="141,560,272,584"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac67b7baaf2a76b42aa31389f12a30c18" id="r_ac67b7baaf2a76b42aa31389f12a30c18"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmbed_1_1Callback.html">mbed::Callback</a>&lt; void(<a class="el" href="group__netsocket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> result, <a class="el" href="classSocketAddress.html">SocketAddress</a> *address)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac67b7baaf2a76b42aa31389f12a30c18">hostbyname_cb_t</a></td></tr>
<tr class="separator:ac67b7baaf2a76b42aa31389f12a30c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classDNS"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classDNS')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classDNS.html">DNS</a></td></tr>
<tr class="memitem:a8e4c3c4a25e5371f38ca771f8047c872 inherit pub_types_classDNS" id="r_a8e4c3c4a25e5371f38ca771f8047c872"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmbed_1_1Callback.html">mbed::Callback</a>&lt; void(<a class="el" href="group__netsocket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> result, <a class="el" href="classSocketAddress.html">SocketAddress</a> *address)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDNS.html#a8e4c3c4a25e5371f38ca771f8047c872">hostbyname_cb_t</a></td></tr>
<tr class="separator:a8e4c3c4a25e5371f38ca771f8047c872 inherit pub_types_classDNS"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b86350f17b547cbf8871d466200a215" id="r_a3b86350f17b547cbf8871d466200a215"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b86350f17b547cbf8871d466200a215">set_as_default</a> ()</td></tr>
<tr class="separator:a3b86350f17b547cbf8871d466200a215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e9c420561d0a7e213440b758dd9105" id="r_a44e9c420561d0a7e213440b758dd9105"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44e9c420561d0a7e213440b758dd9105">get_mac_address</a> ()</td></tr>
<tr class="separator:a44e9c420561d0a7e213440b758dd9105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5777e4a15a153266cd18a7edb62c91bf" id="r_a5777e4a15a153266cd18a7edb62c91bf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5777e4a15a153266cd18a7edb62c91bf">set_mac_address</a> (uint8_t *mac_addr, <a class="el" href="group__netsocket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> addr_len)</td></tr>
<tr class="separator:a5777e4a15a153266cd18a7edb62c91bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caf98844ea0d3a19b2fe7648536be25" id="r_a3caf98844ea0d3a19b2fe7648536be25"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3caf98844ea0d3a19b2fe7648536be25">get_ip_address</a> (<a class="el" href="classSocketAddress.html">SocketAddress</a> *address)</td></tr>
<tr class="separator:a3caf98844ea0d3a19b2fe7648536be25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d19faf6c3cb811ca8fe540b91453e0" id="r_a96d19faf6c3cb811ca8fe540b91453e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96d19faf6c3cb811ca8fe540b91453e0">get_ipv6_link_local_address</a> (<a class="el" href="classSocketAddress.html">SocketAddress</a> *address)</td></tr>
<tr class="separator:a96d19faf6c3cb811ca8fe540b91453e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d616489969c13e8bc858a3f670668c7" id="r_a6d616489969c13e8bc858a3f670668c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d616489969c13e8bc858a3f670668c7">get_netmask</a> (<a class="el" href="classSocketAddress.html">SocketAddress</a> *address)</td></tr>
<tr class="separator:a6d616489969c13e8bc858a3f670668c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e55aa4ca170e21bf05ecb0d8767141a" id="r_a6e55aa4ca170e21bf05ecb0d8767141a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e55aa4ca170e21bf05ecb0d8767141a">get_gateway</a> (<a class="el" href="classSocketAddress.html">SocketAddress</a> *address)</td></tr>
<tr class="separator:a6e55aa4ca170e21bf05ecb0d8767141a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06527c89236062d3cdeec0706176938c" id="r_a06527c89236062d3cdeec0706176938c"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06527c89236062d3cdeec0706176938c">get_interface_name</a> (char *interface_name)</td></tr>
<tr class="separator:a06527c89236062d3cdeec0706176938c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b94b4016ef38cb47c3af0c95d09bfd7" id="r_a4b94b4016ef38cb47c3af0c95d09bfd7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b94b4016ef38cb47c3af0c95d09bfd7">set_network</a> (const <a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;ip_address, const <a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;netmask, const <a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;gateway)</td></tr>
<tr class="separator:a4b94b4016ef38cb47c3af0c95d09bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b6c4eea1704e7be7fd0b9cebe14cb0" id="r_ab7b6c4eea1704e7be7fd0b9cebe14cb0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7b6c4eea1704e7be7fd0b9cebe14cb0">set_dhcp</a> (bool dhcp)</td></tr>
<tr class="separator:ab7b6c4eea1704e7be7fd0b9cebe14cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ef54ecbd066f2083e6031bd1f3cb00" id="r_aa7ef54ecbd066f2083e6031bd1f3cb00"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7ef54ecbd066f2083e6031bd1f3cb00">connect</a> ()=0</td></tr>
<tr class="separator:aa7ef54ecbd066f2083e6031bd1f3cb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0b6a1cc662ae2483d9cb58e34671a6" id="r_a1a0b6a1cc662ae2483d9cb58e34671a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a0b6a1cc662ae2483d9cb58e34671a6">disconnect</a> ()=0</td></tr>
<tr class="separator:a1a0b6a1cc662ae2483d9cb58e34671a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cebbbe94d1453474d75555fe9b37bb" id="r_a64cebbbe94d1453474d75555fe9b37bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64cebbbe94d1453474d75555fe9b37bb">gethostbyname</a> (const char *host, <a class="el" href="classSocketAddress.html">SocketAddress</a> *address, nsapi_version_t version=<a class="el" href="group__netsocket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="separator:a64cebbbe94d1453474d75555fe9b37bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e79fb9b23a868ac3b8a4eca21f4adb" id="r_ad7e79fb9b23a868ac3b8a4eca21f4adb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7e79fb9b23a868ac3b8a4eca21f4adb">getaddrinfo</a> (const char *hostname, <a class="el" href="classSocketAddress.html">SocketAddress</a> *hints, <a class="el" href="classSocketAddress.html">SocketAddress</a> **res, const char *interface_name=NULL)</td></tr>
<tr class="separator:ad7e79fb9b23a868ac3b8a4eca21f4adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b40661a2159338f20b90dfdf675c78" id="r_a16b40661a2159338f20b90dfdf675c78"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16b40661a2159338f20b90dfdf675c78">gethostbyname_async</a> (const char *host, <a class="el" href="#ac67b7baaf2a76b42aa31389f12a30c18">hostbyname_cb_t</a> callback, nsapi_version_t version=<a class="el" href="group__netsocket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="separator:a16b40661a2159338f20b90dfdf675c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a9c90cfe806e62b118d69d825da5de" id="r_a61a9c90cfe806e62b118d69d825da5de"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61a9c90cfe806e62b118d69d825da5de">getaddrinfo_async</a> (const char *hostname, <a class="el" href="classSocketAddress.html">SocketAddress</a> *hints, <a class="el" href="#ac67b7baaf2a76b42aa31389f12a30c18">hostbyname_cb_t</a> callback, const char *interface_name=NULL)</td></tr>
<tr class="separator:a61a9c90cfe806e62b118d69d825da5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8574fdb15904463225c4e828159093" id="r_a0e8574fdb15904463225c4e828159093"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e8574fdb15904463225c4e828159093">gethostbyname_async_cancel</a> (int id)</td></tr>
<tr class="separator:a0e8574fdb15904463225c4e828159093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3139edde05ed56c50f7148db6797ed04" id="r_a3139edde05ed56c50f7148db6797ed04"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3139edde05ed56c50f7148db6797ed04">add_dns_server</a> (const <a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;address, const char *interface_name)</td></tr>
<tr class="separator:a3139edde05ed56c50f7148db6797ed04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c8e3840f89d07dd983bd109a717b55" id="r_a00c8e3840f89d07dd983bd109a717b55"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00c8e3840f89d07dd983bd109a717b55">get_dns_server</a> (int index, <a class="el" href="classSocketAddress.html">SocketAddress</a> *address, const char *interface_name=NULL)</td></tr>
<tr class="separator:a00c8e3840f89d07dd983bd109a717b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff802f87aab01abd0d534ab90fbf85bc" id="r_aff802f87aab01abd0d534ab90fbf85bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff802f87aab01abd0d534ab90fbf85bc">attach</a> (<a class="el" href="classmbed_1_1Callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt; status_cb)</td></tr>
<tr class="separator:aff802f87aab01abd0d534ab90fbf85bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ec536abf894f7bdba6a580aa4c63f7" id="r_a37ec536abf894f7bdba6a580aa4c63f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37ec536abf894f7bdba6a580aa4c63f7">add_event_listener</a> (<a class="el" href="classmbed_1_1Callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt; status_cb)</td></tr>
<tr class="separator:a37ec536abf894f7bdba6a580aa4c63f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cbc579ff5ee3bc25a79fc0d562d070" id="r_a50cbc579ff5ee3bc25a79fc0d562d070"><td class="memItemLeft" align="right" valign="top">virtual nsapi_connection_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50cbc579ff5ee3bc25a79fc0d562d070">get_connection_status</a> () const</td></tr>
<tr class="separator:a50cbc579ff5ee3bc25a79fc0d562d070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9125ac147402e7db658b17ab59c0b3" id="r_a1b9125ac147402e7db658b17ab59c0b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b9125ac147402e7db658b17ab59c0b3">set_blocking</a> (bool blocking)</td></tr>
<tr class="separator:a1b9125ac147402e7db658b17ab59c0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fdbba17a46b87b2897e04bc9c04e51" id="r_ad8fdbba17a46b87b2897e04bc9c04e51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEthInterface.html">EthInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8fdbba17a46b87b2897e04bc9c04e51">ethInterface</a> ()</td></tr>
<tr class="separator:ad8fdbba17a46b87b2897e04bc9c04e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8e041fcc7a5737761187ef8efb1193" id="r_a1f8e041fcc7a5737761187ef8efb1193"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWiFiInterface.html">WiFiInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f8e041fcc7a5737761187ef8efb1193">wifiInterface</a> ()</td></tr>
<tr class="separator:a1f8e041fcc7a5737761187ef8efb1193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b34d3d20e7d1841e1ee34212d8a6c20" id="r_a6b34d3d20e7d1841e1ee34212d8a6c20"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMeshInterface.html">MeshInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b34d3d20e7d1841e1ee34212d8a6c20">meshInterface</a> ()</td></tr>
<tr class="separator:a6b34d3d20e7d1841e1ee34212d8a6c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f12ade012993be2cf7f42e2bc55a6b" id="r_a50f12ade012993be2cf7f42e2bc55a6b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEMACInterface.html">EMACInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50f12ade012993be2cf7f42e2bc55a6b">emacInterface</a> ()</td></tr>
<tr class="separator:a50f12ade012993be2cf7f42e2bc55a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f66cbb98c1120c8993a1f546668b77e" id="r_a4f66cbb98c1120c8993a1f546668b77e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCellularInterface.html">CellularInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f66cbb98c1120c8993a1f546668b77e">cellularInterface</a> ()</td></tr>
<tr class="separator:a4f66cbb98c1120c8993a1f546668b77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae397ad3e4cb6c5a3adbcdcd2606e1652" id="r_ae397ad3e4cb6c5a3adbcdcd2606e1652"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae397ad3e4cb6c5a3adbcdcd2606e1652">set_default_parameters</a> ()</td></tr>
<tr class="memdesc:ae397ad3e4cb6c5a3adbcdcd2606e1652"><td class="mdescLeft">&#160;</td><td class="mdescRight">defined(DOXYGEN_ONLY)  <br /></td></tr>
<tr class="separator:ae397ad3e4cb6c5a3adbcdcd2606e1652"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a91e2da33575adb34650601d50886b34d" id="r_a91e2da33575adb34650601d50886b34d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNetworkInterface.html">NetworkInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91e2da33575adb34650601d50886b34d">get_default_instance</a> ()</td></tr>
<tr class="separator:a91e2da33575adb34650601d50886b34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afbc5ee5da78879bd9db852ac6ef97ae6" id="r_afbc5ee5da78879bd9db852ac6ef97ae6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNetworkStack.html">NetworkStack</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbc5ee5da78879bd9db852ac6ef97ae6">get_stack</a> ()=0</td></tr>
<tr class="separator:afbc5ee5da78879bd9db852ac6ef97ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a9dbae3f6d13c567407357229fbc79a10" id="r_a9dbae3f6d13c567407357229fbc79a10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNetworkInterface.html">NetworkInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dbae3f6d13c567407357229fbc79a10">get_target_default_instance</a> ()</td></tr>
<tr class="separator:a9dbae3f6d13c567407357229fbc79a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8b03f511aee083c132a3cc137f581334" id="r_a8b03f511aee083c132a3cc137f581334"><td class="memItemLeft" align="right" valign="top"><a id="a8b03f511aee083c132a3cc137f581334" name="a8b03f511aee083c132a3cc137f581334"></a>
<a class="el" href="classNetworkStack.html">NetworkStack</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_nsapi_create_stack</b> (<a class="el" href="classNetworkInterface.html">NetworkInterface</a> *iface, std::false_type)</td></tr>
<tr class="separator:a8b03f511aee083c132a3cc137f581334"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common interface that is shared between network devices. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac67b7baaf2a76b42aa31389f12a30c18" name="ac67b7baaf2a76b42aa31389f12a30c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67b7baaf2a76b42aa31389f12a30c18">&#9670;&#160;</a></span>hostbyname_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmbed_1_1Callback.html">mbed::Callback</a>&lt;void (<a class="el" href="group__netsocket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> result, <a class="el" href="classSocketAddress.html">SocketAddress</a> *address)&gt; <a class="el" href="#ac67b7baaf2a76b42aa31389f12a30c18">NetworkInterface::hostbyname_cb_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hostname translation callback (for use with <a class="el" href="#a16b40661a2159338f20b90dfdf675c78">gethostbyname_async()</a>).</p>
<p><a class="el" href="classCallback.html">Callback</a> will be called after <a class="el" href="classDNS.html">DNS</a> resolution completes or a failure occurs.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCallback.html">Callback</a> should not take more than 10ms to execute, otherwise it might prevent underlying thread processing. A portable user of the callback should not make calls to network operations due to stack size limitations. The callback should not perform expensive operations such as socket recv/send calls or blocking operations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Negative error code on failure or value that represents the number of <a class="el" href="classDNS.html">DNS</a> records </td></tr>
    <tr><td class="paramname">address</td><td>On success, destination for the host <a class="el" href="classSocketAddress.html">SocketAddress</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3139edde05ed56c50f7148db6797ed04" name="a3139edde05ed56c50f7148db6797ed04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3139edde05ed56c50f7148db6797ed04">&#9670;&#160;</a></span>add_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::add_dns_server </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>interface_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a domain name server to list of servers to query</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address for the dns host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="classDNS.html#ac445bf712c2a49f8317053f09198ccd4">DNS</a>.</p>

</div>
</div>
<a id="a37ec536abf894f7bdba6a580aa4c63f7" name="a37ec536abf894f7bdba6a580aa4c63f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ec536abf894f7bdba6a580aa4c63f7">&#9670;&#160;</a></span>add_event_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkInterface::add_event_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1Callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt;</td>          <td class="paramname"><span class="paramname"><em>status_cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add event listener for interface.</p>
<p>This API allows multiple callback to be registered for a single interface. When first called, internal list of event handlers are created and registered to interface through <a class="el" href="#aff802f87aab01abd0d534ab90fbf85bc">attach()</a> API.</p>
<p>Application may only use <a class="el" href="#aff802f87aab01abd0d534ab90fbf85bc">attach()</a> or <a class="el" href="#a37ec536abf894f7bdba6a580aa4c63f7">add_event_listener()</a> interface. Mixing usage of both leads to undefined behavior.</p>
<dl class="section warning"><dt>Warning</dt><dd>This version of the function does not use the <code>std::nothrow</code> feature. Subsequently, the function may fail to allocate memory and cause a system error. To use the new version with the changes, set "nsapi.add-event-listener-return-change": 1 in the target overrides section in your mbed_app.json file.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_cb</td><td>The callback for status changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff802f87aab01abd0d534ab90fbf85bc" name="aff802f87aab01abd0d534ab90fbf85bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff802f87aab01abd0d534ab90fbf85bc">&#9670;&#160;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkInterface::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1Callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt;</td>          <td class="paramname"><span class="paramname"><em>status_cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register callback for status reporting.</p>
<p>The specified status callback function will be called on status changes on the network. The parameters on the callback are the event type and event-type dependent reason parameter. Only one callback can be registered at a time.</p>
<p>To unregister a callback call with status_cb parameter as a zero.</p>
<p><em>NOTE:</em> Any callbacks registered with this function will be overwritten if <a class="el" href="#a37ec536abf894f7bdba6a580aa4c63f7">add_event_listener()</a> API is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_cb</td><td>The callback for status changes. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#ab387a05d289f53feea6c6c0458435676">EMACInterface</a>, <a class="el" href="classInterfaceNanostack.html#aa22a0284c658b4ace15919d02f1ebd46">InterfaceNanostack</a>, <a class="el" href="classL3IPInterface.html#a491b35cdc698f2c633960a782c984de5">L3IPInterface</a>, <a class="el" href="classmbed_1_1AT__CellularContext.html#a4d047ebb4e873e4c018443e7f534781b">mbed::AT_CellularContext</a>, <a class="el" href="classmbed_1_1CellularContext.html#a559697c5c6379419ce158853c9ead269">mbed::CellularContext</a>, <a class="el" href="classmbed_1_1myCellularContext.html#abd85296fd3673b4b0d1f32e76ee64b53">mbed::myCellularContext</a>, <a class="el" href="classPPPInterface.html#a2f19a8fc7a7f18eb9bd27626a84cfc4f">PPPInterface</a>, <a class="el" href="classstubNetworkInterface.html#a3ceee362ce599ba30dfdd81a601f6176">stubNetworkInterface</a>, and <a class="el" href="classtestContext.html#a7ecfcf892023b2f914ba8a5341c92e7a">testContext</a>.</p>

</div>
</div>
<a id="a4f66cbb98c1120c8993a1f546668b77e" name="a4f66cbb98c1120c8993a1f546668b77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f66cbb98c1120c8993a1f546668b77e">&#9670;&#160;</a></span>cellularInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classCellularInterface.html">CellularInterface</a> * NetworkInterface::cellularInterface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return pointer to a <a class="el" href="classCellularInterface.html">CellularInterface</a>. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="group__cellular.html#ga43d498ff390046ce8a36e72547b10f48">CellularInterface</a>.</p>

</div>
</div>
<a id="aa7ef54ecbd066f2083e6031bd1f3cb00" name="aa7ef54ecbd066f2083e6031bd1f3cb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ef54ecbd066f2083e6031bd1f3cb00">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::connect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect to a network.</p>
<p>This blocks until connection is established, but asynchronous operation can be enabled by calling NetworkInterface::set_blocking(false).</p>
<p>In asynchronous mode this starts the connection sequence and returns immediately. Status of the connection can then checked from <a class="el" href="#a50cbc579ff5ee3bc25a79fc0d562d070">NetworkInterface::get_connection_status()</a> or from status callbacks.</p>
<p><a class="el" href="classNetworkInterface.html">NetworkInterface</a> internally handles reconnections until <a class="el" href="#a1a0b6a1cc662ae2483d9cb58e34671a6">disconnect()</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK if connection established in blocking mode. </dd>
<dd>
NSAPI_ERROR_OK if asynchronous operation started. </dd>
<dd>
NSAPI_ERROR_BUSY if asynchronous operation cannot be started. Implementation guarantees event generation, which can be used as an trigger to reissue the rejected request. </dd>
<dd>
NSAPI_ERROR_IS_CONNECTED if already connected. </dd>
<dd>
negative error code on failure. </dd></dl>

<p>Implemented in <a class="el" href="group__cellular.html#ga9a7f947bbf2c64f5a4f9f08c417d00fe">CellularInterface</a>, <a class="el" href="classEMACInterface.html#abf11adb7c47186537cf1c7c72f6cece5">EMACInterface</a>, <a class="el" href="classInterfaceNanostack.html#a03ff94b1a341180971c8edc95566e871">InterfaceNanostack</a>, <a class="el" href="classL3IPInterface.html#a8e4668c242951c1336b8bff2a4bf19f9">L3IPInterface</a>, <a class="el" href="classmbed_1_1AT__CellularContext.html#a057c16c70163d1d91958dee88c598e9c">mbed::AT_CellularContext</a>, <a class="el" href="classmbed_1_1CellularContext.html#a019006f0f0bdd7cb61a9ddd007a7bc8a">mbed::CellularContext</a>, <a class="el" href="classmbed_1_1myCellularContext.html#a92017c0939d9840f69cb5295124243ae">mbed::myCellularContext</a>, <a class="el" href="classPPPInterface.html#a14e172421639fd831f14171a8d051522">PPPInterface</a>, <a class="el" href="classRDAWiFiInterface.html#a060f1a56cc1a87389fa7b99b508dd3da">RDAWiFiInterface</a>, <a class="el" href="classSclSTAInterface.html#aeb41658adf6a8ca52ee8a1b827853d41">SclSTAInterface</a>, <a class="el" href="classstubNetworkInterface.html#a83fb6228fb7526c035dd0a60d158ad6d">stubNetworkInterface</a>, <a class="el" href="classtestContext.html#a6b46c8abbe67f4e940b65406391c94af">testContext</a>, <a class="el" href="classWhdSTAInterface.html#a04c222c38592b754f847e8c6e98897c5">WhdSTAInterface</a>, and <a class="el" href="classWiFiInterface.html#a783cff8cdde624760c360abcffabad99">WiFiInterface</a>.</p>

</div>
</div>
<a id="a1a0b6a1cc662ae2483d9cb58e34671a6" name="a1a0b6a1cc662ae2483d9cb58e34671a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0b6a1cc662ae2483d9cb58e34671a6">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::disconnect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnect from the network</p>
<p>This blocks until interface is disconnected, unless interface is set to asynchronous (non-blocking) mode by calling NetworkInterface::set_blocking(false).</p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on successfully disconnected in blocking mode. </dd>
<dd>
NSAPI_ERROR_OK if asynchronous operation started. </dd>
<dd>
NSAPI_ERROR_BUSY if asynchronous operation cannot be started. Implementation guarantees event generation, which can be used as an trigger to reissue the rejected request. </dd>
<dd>
NSAPI_ERROR_NO_CONNECTION if already disconnected. </dd>
<dd>
negative error code on failure. </dd></dl>

<p>Implemented in <a class="el" href="group__cellular.html#ga4e1059c1be844c12d75199591909b7df">CellularInterface</a>, <a class="el" href="classEMACInterface.html#aecceb50179983e33337f22d64aed1b10">EMACInterface</a>, <a class="el" href="classInterfaceNanostack.html#a2e77a0a01ac11aaccf348b238123d49b">InterfaceNanostack</a>, <a class="el" href="classL3IPInterface.html#acbfe638d626c1e0e8e82848f3cae8e96">L3IPInterface</a>, <a class="el" href="classmbed_1_1AT__CellularContext.html#a3eb4b4a3fb425330e7b2a28d06a62cd1">mbed::AT_CellularContext</a>, <a class="el" href="classmbed_1_1CellularContext.html#aa073177adddc189ed76a7b163b5f4325">mbed::CellularContext</a>, <a class="el" href="classmbed_1_1myCellularContext.html#aafa1e3512c46f9eba2ebbfb579830c2c">mbed::myCellularContext</a>, <a class="el" href="classPPPInterface.html#aeb1e4fa9429f2349218049fb83d623f5">PPPInterface</a>, <a class="el" href="classRDAWiFiInterface.html#af8ae0f32d9be01c7fc35babbb6fb536f">RDAWiFiInterface</a>, <a class="el" href="classSclSTAInterface.html#ae85d481c5a842ca0ab314579ff1e09f1">SclSTAInterface</a>, <a class="el" href="classstubNetworkInterface.html#a22d2e4ce3d323acc8b7a3ede7b1e82cf">stubNetworkInterface</a>, <a class="el" href="classtestContext.html#a85cd6358006a192c22f1e988779d9599">testContext</a>, <a class="el" href="classWhdSTAInterface.html#a19e5d1cf01899f8ad23306a3eac71862">WhdSTAInterface</a>, and <a class="el" href="classWiFiInterface.html#af8e56cfcdde754ab65dad00402f74008">WiFiInterface</a>.</p>

</div>
</div>
<a id="a50f12ade012993be2cf7f42e2bc55a6b" name="a50f12ade012993be2cf7f42e2bc55a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f12ade012993be2cf7f42e2bc55a6b">&#9670;&#160;</a></span>emacInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classEMACInterface.html">EMACInterface</a> * NetworkInterface::emacInterface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return pointer to an <a class="el" href="classEMACInterface.html">EMACInterface</a>. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#a3fd2892637379f600db9918aadadbb77">EMACInterface</a>.</p>

</div>
</div>
<a id="ad8fdbba17a46b87b2897e04bc9c04e51" name="ad8fdbba17a46b87b2897e04bc9c04e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fdbba17a46b87b2897e04bc9c04e51">&#9670;&#160;</a></span>ethInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classEthInterface.html">EthInterface</a> * NetworkInterface::ethInterface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return pointer to an <a class="el" href="classEthInterface.html">EthInterface</a>. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="classEthInterface.html#a78c1d64f82dbec414f5733674f1ba872">EthInterface</a>.</p>

</div>
</div>
<a id="a50cbc579ff5ee3bc25a79fc0d562d070" name="a50cbc579ff5ee3bc25a79fc0d562d070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cbc579ff5ee3bc25a79fc0d562d070">&#9670;&#160;</a></span>get_connection_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nsapi_connection_status_t NetworkInterface::get_connection_status </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the connection status.</p>
<dl class="section return"><dt>Returns</dt><dd>The connection status (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nsapi__types_8h_source.html">nsapi_types.h</a>). </dd></dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#aa171b1ec280f1c2b2edd8897c04c265a">EMACInterface</a>, <a class="el" href="classInterfaceNanostack.html#ac43a79da2857bcad25abdf340349548b">InterfaceNanostack</a>, <a class="el" href="classL3IPInterface.html#a3c9900df58a9074c2610c6facf310d3e">L3IPInterface</a>, <a class="el" href="classmbed_1_1AT__CellularContext.html#ae98fcc30d3b1219655a2ac7e15771faa">mbed::AT_CellularContext</a>, and <a class="el" href="classPPPInterface.html#a46752c31163f7d0147025b9865e78863">PPPInterface</a>.</p>

</div>
</div>
<a id="a91e2da33575adb34650601d50886b34d" name="a91e2da33575adb34650601d50886b34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e2da33575adb34650601d50886b34d">&#9670;&#160;</a></span>get_default_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#gaa7bb5d6a31c6888e54eea75c60f06400">MBED_WEAK</a> <a class="el" href="classNetworkInterface.html">NetworkInterface</a> * NetworkInterface::get_default_instance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the default network interface.</p>
<p>Returns the default network interface, as determined by JSON option target.network-default-interface-type or other overrides.</p>
<p>The type of the interface returned can be tested by calling <a class="el" href="#ad8fdbba17a46b87b2897e04bc9c04e51">ethInterface()</a>, <a class="el" href="#a1f8e041fcc7a5737761187ef8efb1193">wifiInterface()</a>, <a class="el" href="#a6b34d3d20e7d1841e1ee34212d8a6c20">meshInterface()</a>, <a class="el" href="#a4f66cbb98c1120c8993a1f546668b77e">cellularInterface()</a>, <a class="el" href="#a50f12ade012993be2cf7f42e2bc55a6b">emacInterface()</a> and checking for NULL pointers.</p>
<p>The default behavior is to return the default interface for the interface type specified by target.network-default-interface-type. Targets should set this in their targets.json to guide default selection, and applications may override.</p>
<p>The interface returned should be already configured for use such that its <a class="el" href="#aa7ef54ecbd066f2083e6031bd1f3cb00">connect()</a> method works with no parameters. For connection types needing configuration, settings should normally be obtained from JSON - the settings for the core types are under the "nsapi" JSON config tree.</p>
<p>The list of possible settings for default interface type is open-ended, as is the number of possible providers. Core providers are:</p>
<ul>
<li>ETHERNET: <a class="el" href="classEthernetInterface.html">EthernetInterface</a>, using default <a class="el" href="classEMAC.html">EMAC</a> and <a class="el" href="classOnboardNetworkStack.html">OnboardNetworkStack</a></li>
<li>MESH: <a class="el" href="classThreadInterface.html">ThreadInterface</a> or <a class="el" href="classLoWPANNDInterface.html">LoWPANNDInterface</a>, using default <a class="el" href="classNanostackRfPhy.html">NanostackRfPhy</a></li>
<li>CELLULAR: OnboardModemInterface</li>
<li>WIFI: None - always provided by a specific class</li>
</ul>
<p>Specific drivers may be activated by other settings of the default-network-interface-type configuration. This will depend on the target and the driver. For example a board may have its default setting as "AUTO" which causes it to autodetect an Ethernet cable. This should be described in the target's documentation.</p>
<p>An application can override all target settings by implementing <a class="el" href="#a91e2da33575adb34650601d50886b34d">NetworkInterface::get_default_instance()</a> themselves - the default definition is weak, and calls <a class="el" href="#a9dbae3f6d13c567407357229fbc79a10">get_target_default_instance()</a>. </p>

</div>
</div>
<a id="a00c8e3840f89d07dd983bd109a717b55" name="a00c8e3840f89d07dd983bd109a717b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c8e3840f89d07dd983bd109a717b55">&#9670;&#160;</a></span>get_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::get_dns_server </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSocketAddress.html">SocketAddress</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>interface_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a domain name server from a list of servers to query</p>
<p>Returns a <a class="el" href="classDNS.html">DNS</a> server address for a index. If returns error no more <a class="el" href="classDNS.html">DNS</a> servers to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the <a class="el" href="classDNS.html">DNS</a> server, starts from zero </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the host address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

</div>
</div>
<a id="a6e55aa4ca170e21bf05ecb0d8767141a" name="a6e55aa4ca170e21bf05ecb0d8767141a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e55aa4ca170e21bf05ecb0d8767141a">&#9670;&#160;</a></span>get_gateway()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::get_gateway </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSocketAddress.html">SocketAddress</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the local gateway.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="classSocketAddress.html">SocketAddress</a> representation of gateway address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#a55c784200bf49e63c3b16c813440f24c">EMACInterface</a>, <a class="el" href="classL3IPInterface.html#a335aa03f72d74cbc9534efad1d8238cc">L3IPInterface</a>, <a class="el" href="classmbed_1_1UBLOX__AT__CellularContext.html#a08301d1e5d5d408c0d87834661c9afc1">mbed::UBLOX_AT_CellularContext</a>, and <a class="el" href="classPPPInterface.html#a04bc2925d410b070935cded7f8fa4459">PPPInterface</a>.</p>

</div>
</div>
<a id="a06527c89236062d3cdeec0706176938c" name="a06527c89236062d3cdeec0706176938c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06527c89236062d3cdeec0706176938c">&#9670;&#160;</a></span>get_interface_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * NetworkInterface::get_interface_name </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>interface_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the network interface name</p>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated representation of the network interface name or null if interface not exists </dd></dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#a6b6f87470edb6334f1d44647b012203c">EMACInterface</a>, <a class="el" href="classL3IPInterface.html#afa96b3a9fd50feee85674c386d93f398">L3IPInterface</a>, <a class="el" href="classmbed_1_1AT__CellularContext.html#a3c307d82f29ce80757838aab36276dd2">mbed::AT_CellularContext</a>, and <a class="el" href="classPPPInterface.html#ad3e597867934265416a120fb0b5b14c0">PPPInterface</a>.</p>

</div>
</div>
<a id="a3caf98844ea0d3a19b2fe7648536be25" name="a3caf98844ea0d3a19b2fe7648536be25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caf98844ea0d3a19b2fe7648536be25">&#9670;&#160;</a></span>get_ip_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::get_ip_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSocketAddress.html">SocketAddress</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the local IP address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="classSocketAddress.html">SocketAddress</a> representation of the local IP address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__cellular.html#ga0a4719a08353510ab605741912ac88a4">CellularInterface</a>, <a class="el" href="classEMACInterface.html#a7854a5e5e398c87429268820a020bf4c">EMACInterface</a>, <a class="el" href="classInterfaceNanostack.html#a9abbe1cf81c1df4ee3cdc044a82a8383">InterfaceNanostack</a>, <a class="el" href="classL3IPInterface.html#ae3ab9397b1245ed3ff25dbc0d0be824a">L3IPInterface</a>, <a class="el" href="classmbed_1_1AT__CellularContext.html#a8033ed781397176a3647dcf0d0fb23bc">mbed::AT_CellularContext</a>, <a class="el" href="classmbed_1_1CellularContext.html#ae47c1289550ed5de4b250c4d482327f6">mbed::CellularContext</a>, <a class="el" href="classmbed_1_1myCellularContext.html#af18239d1999132dd5f237e7e23624e23">mbed::myCellularContext</a>, <a class="el" href="classPPPInterface.html#a25cb466a97de943fc3c1d8e38c5e8647">PPPInterface</a>, and <a class="el" href="classtestContext.html#ac42260df12f0a91435d4a33ce7717bc5">testContext</a>.</p>

</div>
</div>
<a id="a96d19faf6c3cb811ca8fe540b91453e0" name="a96d19faf6c3cb811ca8fe540b91453e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d19faf6c3cb811ca8fe540b91453e0">&#9670;&#160;</a></span>get_ipv6_link_local_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::get_ipv6_link_local_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSocketAddress.html">SocketAddress</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the IPv6 link local address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="classSocketAddress.html">SocketAddress</a> representation of the link local IPv6 address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#ab18d4adbc3041d56ca1e6448e54592a3">EMACInterface</a>.</p>

</div>
</div>
<a id="a44e9c420561d0a7e213440b758dd9105" name="a44e9c420561d0a7e213440b758dd9105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e9c420561d0a7e213440b758dd9105">&#9670;&#160;</a></span>get_mac_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * NetworkInterface::get_mac_address </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the local MAC address.</p>
<p>Provided MAC address is intended for info or debug purposes and may be not provided if the underlying network interface does not provide a MAC address.</p>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated representation of the local MAC address or null if no MAC address is available. </dd></dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#a08e0750db19db39d486a2ce6561e4d91">EMACInterface</a>, and <a class="el" href="classInterfaceNanostack.html#a3426b4224d8f99d7b496564c556fb614">InterfaceNanostack</a>.</p>

</div>
</div>
<a id="a6d616489969c13e8bc858a3f670668c7" name="a6d616489969c13e8bc858a3f670668c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d616489969c13e8bc858a3f670668c7">&#9670;&#160;</a></span>get_netmask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::get_netmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSocketAddress.html">SocketAddress</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the local network mask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="classSocketAddress.html">SocketAddress</a> representation of netmask </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#a4d72e306687571e90d35fbc9a0660c68">EMACInterface</a>, <a class="el" href="classL3IPInterface.html#a5c2330d20b707b5195c8628287683bf2">L3IPInterface</a>, and <a class="el" href="classPPPInterface.html#a605a16734865b6143fcc2bf4e30bddc5">PPPInterface</a>.</p>

</div>
</div>
<a id="afbc5ee5da78879bd9db852ac6ef97ae6" name="afbc5ee5da78879bd9db852ac6ef97ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc5ee5da78879bd9db852ac6ef97ae6">&#9670;&#160;</a></span>get_stack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNetworkStack.html">NetworkStack</a> * NetworkInterface::get_stack </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide access to the <a class="el" href="classNetworkStack.html">NetworkStack</a> object</p>
<dl class="section return"><dt>Returns</dt><dd>The underlying <a class="el" href="classNetworkStack.html">NetworkStack</a> object </dd></dl>

<p>Implemented in <a class="el" href="classEMACInterface.html#a2a5aadf35dce1eb4ae357085bda9cae7">EMACInterface</a>, <a class="el" href="classInterfaceNanostack.html#a078eb05372e82c3d5c35f64072918b01">InterfaceNanostack</a>, <a class="el" href="classL3IPInterface.html#a7df7ab9983d944fa3baa30f69087941c">L3IPInterface</a>, <a class="el" href="classmbed_1_1AT__CellularContext.html#a45839dd878913c9fe20ea66269c516c9">mbed::AT_CellularContext</a>, <a class="el" href="classmbed_1_1CellularContext.html#a4974e3727b28a2e848c69a8fad45a08f">mbed::CellularContext</a>, <a class="el" href="classmbed_1_1GEMALTO__CINTERION__CellularContext.html#ab1dd1a9962e0978e9925a8faa268dc56">mbed::GEMALTO_CINTERION_CellularContext</a>, <a class="el" href="classmbed_1_1myCellularContext.html#ac7a5bfc1a8a18d56154083125f0cf2a0">mbed::myCellularContext</a>, <a class="el" href="classmbed_1_1QUECTEL__BC95__CellularContext.html#a9bdeee6576f424b74d1d29c6ef0552fb">mbed::QUECTEL_BC95_CellularContext</a>, <a class="el" href="classmbed_1_1QUECTEL__BG96__CellularContext.html#a486ec306ece66011853d0611dc17b0a0">mbed::QUECTEL_BG96_CellularContext</a>, <a class="el" href="classmbed_1_1QUECTEL__M26__CellularContext.html#aabee1738375061f6845bf985cbb2d612">mbed::QUECTEL_M26_CellularContext</a>, <a class="el" href="classmbed_1_1RM1000__AT__CellularContext.html#acf8c4f4f589590f58a4987794565f7ab">mbed::RM1000_AT_CellularContext</a>, <a class="el" href="classmbed_1_1TELIT__ME310__CellularContext.html#a5a430bf26f78500e294f9f30ce2df60f">mbed::TELIT_ME310_CellularContext</a>, <a class="el" href="classmbed_1_1UBLOX__AT__CellularContext.html#a55f06154f1a1ddfe389b1b1342d79802">mbed::UBLOX_AT_CellularContext</a>, <a class="el" href="classmbed_1_1UBLOX__N2XX__CellularContext.html#ad1d9da03ca4e4296cc65cfb9d94b4974">mbed::UBLOX_N2XX_CellularContext</a>, <a class="el" href="classmy__AT__CTX.html#aad5f79048a8c50054513aefc16bd59ce">my_AT_CTX</a>, <a class="el" href="classmy__AT__CTXIPV6.html#a87f44cf83114bc912bb9a145e9c6fc17">my_AT_CTXIPV6</a>, <a class="el" href="classPPPInterface.html#af817ab60acb99daa4bf643fa485863c1">PPPInterface</a>, <a class="el" href="classstubNetworkInterface.html#a394c6af6ce678eeef8bd36d2d05c1f6c">stubNetworkInterface</a>, and <a class="el" href="classtestContext.html#aa260fb017e65c44f5b4e4d90d90e663f">testContext</a>.</p>

</div>
</div>
<a id="a9dbae3f6d13c567407357229fbc79a10" name="a9dbae3f6d13c567407357229fbc79a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbae3f6d13c567407357229fbc79a10">&#9670;&#160;</a></span>get_target_default_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#gaa7bb5d6a31c6888e54eea75c60f06400">MBED_WEAK</a> <a class="el" href="classNetworkInterface.html">NetworkInterface</a> * NetworkInterface::get_target_default_instance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the target's default network instance.</p>
<p>This method can be overridden by the target. Default implementations are provided weakly by various subsystems as described in <a class="el" href="#a91e2da33575adb34650601d50886b34d">NetworkInterface::get_default_instance()</a>, so targets should not need to override in simple cases.</p>
<p>If a target has more elaborate interface selection, it can completely override this behavior by implementing <a class="el" href="#a9dbae3f6d13c567407357229fbc79a10">NetworkInterface::get_target_default_instance()</a> themselves, either unconditionally, or for a specific network-default-interface-type setting</p>
<p>For example, a device with both Ethernet and Wi-fi could be set up its target so that:</p><ul>
<li>DEVICE_EMAC is set, and it provides <a class="el" href="group__lwip17xx__emac__DRIVER.html#gacc0729725206050054ec718080a07f1b">EMAC::get_default_instance()</a>, which means <a class="el" href="classEthernetInterface.html">EthernetInterface</a> provides EthInterface::get_target_instance() based on that <a class="el" href="classEMAC.html">EMAC</a>.</li>
<li>It provides WifiInterface::get_target_default_instance().</li>
<li>The core will route <a class="el" href="#a91e2da33575adb34650601d50886b34d">NetworkInterface::get_default_instance()</a> to either of those if network-default-interface-type is set to ETHERNET or WIFI.</li>
<li>The board overrides <a class="el" href="#a9dbae3f6d13c567407357229fbc79a10">NetworkInterface::get_target_default_instance()</a> if network-default-interface-type is set to AUTO. This returns either <a class="el" href="classEthInterface.html#afe8a7c966c246eb8ffef845053e4862d">EthInterface::get_default_instance()</a> or WiFIInterface::get_default_instance() depending on a cable detection.</li>
</ul>
<p>performs the search described by get_default_instance. </p>

</div>
</div>
<a id="ad7e79fb9b23a868ac3b8a4eca21f4adb" name="ad7e79fb9b23a868ac3b8a4eca21f4adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e79fb9b23a868ac3b8a4eca21f4adb">&#9670;&#160;</a></span>getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> NetworkInterface::getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSocketAddress.html">SocketAddress</a> *</td>          <td class="paramname"><span class="paramname"><em>hints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSocketAddress.html">SocketAddress</a> **</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>interface_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate a hostname to the multiple IP addresses with specific version using network interface name.</p>
<p>The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="classDNS.html">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="classSocketAddress.html">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to a <a class="el" href="classSocketAddress.html">SocketAddress</a> array to store the result.. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of results on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="classDNS.html#aa36cea9abd16e0a868b9d275481a1128">DNS</a>.</p>

</div>
</div>
<a id="a61a9c90cfe806e62b118d69d825da5de" name="a61a9c90cfe806e62b118d69d825da5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a9c90cfe806e62b118d69d825da5de">&#9670;&#160;</a></span>getaddrinfo_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> NetworkInterface::getaddrinfo_async </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSocketAddress.html">SocketAddress</a> *</td>          <td class="paramname"><span class="paramname"><em>hints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac67b7baaf2a76b42aa31389f12a30c18">hostbyname_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>interface_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate a hostname to the multiple IP addresses (asynchronous) using network interface name.</p>
<p>The hostname may be either a domain name or a dotted IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="classDNS.html">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p>Call is non-blocking. Result of the <a class="el" href="classDNS.html">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="classDNS.html">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="classSocketAddress.html">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">callback</td><td><a class="el" href="classCallback.html">Callback</a> that is called for result. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel. </dd></dl>

<p>Implements <a class="el" href="classDNS.html#ab4f7c6ed289cb48dd05ed61819ff5e43">DNS</a>.</p>

</div>
</div>
<a id="a64cebbbe94d1453474d75555fe9b37bb" name="a64cebbbe94d1453474d75555fe9b37bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cebbbe94d1453474d75555fe9b37bb">&#9670;&#160;</a></span>gethostbyname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSocketAddress.html">SocketAddress</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t</td>          <td class="paramname"><span class="paramname"><em>version</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__netsocket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>interface_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate a hostname to an IP address with specific version using network interface name.</p>
<p>The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="classDNS.html">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">address</td><td>Pointer to a <a class="el" href="classSocketAddress.html">SocketAddress</a> to store the result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">int</td><td>Negative error code on failure. See <a class="el" href="classNetworkStack.html#a823e2633db0c50fb341731fd7cdd7762">NetworkStack::gethostbyname</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classDNS.html#a3fc5f2df3625b51c2631d4700bdcbc60">DNS</a>.</p>

</div>
</div>
<a id="a16b40661a2159338f20b90dfdf675c78" name="a16b40661a2159338f20b90dfdf675c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b40661a2159338f20b90dfdf675c78">&#9670;&#160;</a></span>gethostbyname_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> NetworkInterface::gethostbyname_async </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac67b7baaf2a76b42aa31389f12a30c18">hostbyname_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t</td>          <td class="paramname"><span class="paramname"><em>version</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__netsocket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>interface_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate a hostname to an IP address (asynchronous) using network interface name.</p>
<p>The hostname may be either a domain name or a dotted IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p>If no stack-specific <a class="el" href="classDNS.html">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p>Call is non-blocking. Result of the <a class="el" href="classDNS.html">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="classDNS.html">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">callback</td><td><a class="el" href="classCallback.html">Callback</a> that is called for result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel. </dd></dl>

<p>Implements <a class="el" href="classDNS.html#afa5d2cda80d78d8b5dcfdeb611194ae3">DNS</a>.</p>

</div>
</div>
<a id="a0e8574fdb15904463225c4e828159093" name="a0e8574fdb15904463225c4e828159093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8574fdb15904463225c4e828159093">&#9670;&#160;</a></span>gethostbyname_async_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::gethostbyname_async_cancel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cancel asynchronous hostname translation.</p>
<p>When translation is cancelled, callback will not be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique id of the hostname translation operation (returned by gethostbyname_async) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="classDNS.html#a8be37f89c88d87ab31868959ae3d4d65">DNS</a>.</p>

</div>
</div>
<a id="a6b34d3d20e7d1841e1ee34212d8a6c20" name="a6b34d3d20e7d1841e1ee34212d8a6c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b34d3d20e7d1841e1ee34212d8a6c20">&#9670;&#160;</a></span>meshInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMeshInterface.html">MeshInterface</a> * NetworkInterface::meshInterface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return pointer to a <a class="el" href="classMeshInterface.html">MeshInterface</a>. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="classMeshInterface.html#a94a2db61dc3b98277f19edec3bf885c2">MeshInterface</a>.</p>

</div>
</div>
<a id="a3b86350f17b547cbf8871d466200a215" name="a3b86350f17b547cbf8871d466200a215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b86350f17b547cbf8871d466200a215">&#9670;&#160;</a></span>set_as_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkInterface::set_as_default </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set network interface as default one. </p>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#a872db50119bb6bbb02b412bc7cf0ea31">EMACInterface</a>, <a class="el" href="classL3IPInterface.html#ab4846ab601cb0498630c2708c4273928">L3IPInterface</a>, and <a class="el" href="classPPPInterface.html#a17a7d0e8ed2e4589041da76fa940c0f6">PPPInterface</a>.</p>

</div>
</div>
<a id="a1b9125ac147402e7db658b17ab59c0b3" name="a1b9125ac147402e7db658b17ab59c0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9125ac147402e7db658b17ab59c0b3">&#9670;&#160;</a></span>set_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::set_blocking </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>blocking</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set asynchronous operation of <a class="el" href="#aa7ef54ecbd066f2083e6031bd1f3cb00">connect()</a> and <a class="el" href="#a1a0b6a1cc662ae2483d9cb58e34671a6">disconnect()</a> calls.</p>
<p>By default, interfaces are in synchronous mode which means that <a class="el" href="#aa7ef54ecbd066f2083e6031bd1f3cb00">connect()</a> or <a class="el" href="#a1a0b6a1cc662ae2483d9cb58e34671a6">disconnect()</a> blocks until it reach the target state or requested operation fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking</td><td>Use false to set <a class="el" href="classNetworkInterface.html">NetworkInterface</a> in asynchronous mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success </dd>
<dd>
NSAPI_ERROR_UNSUPPORTED if driver does not support asynchronous mode. </dd>
<dd>
negative error code on failure. </dd></dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#ab7ce853c29a058be1e84732c1e6b8486">EMACInterface</a>, <a class="el" href="classInterfaceNanostack.html#a342abf6cf0dbb2d87558f27d9e5e420a">InterfaceNanostack</a>, <a class="el" href="classL3IPInterface.html#a35d387410754f806284ef93def71c426">L3IPInterface</a>, <a class="el" href="classmbed_1_1AT__CellularContext.html#ade39fa642003eaf3a4df41470d417106">mbed::AT_CellularContext</a>, <a class="el" href="classmbed_1_1CellularContext.html#af39fcc9cf7c5eab4247ddc5552b0ef7f">mbed::CellularContext</a>, <a class="el" href="classmbed_1_1myCellularContext.html#af655e669d830ebbcad7eb9225c3f57a5">mbed::myCellularContext</a>, <a class="el" href="classPPPInterface.html#a9db0dfe21b5f0004c5c13c4d16309369">PPPInterface</a>, <a class="el" href="classSclSTAInterface.html#a003650cf4e20f7d38790ea0ce141aa69">SclSTAInterface</a>, <a class="el" href="classtestContext.html#a00d7637270245bdd36acd5c1c199a910">testContext</a>, <a class="el" href="classWhdSoftAPInterface.html#ae42a87e85d43266aeda6af6b020ca09d">WhdSoftAPInterface</a>, and <a class="el" href="classWhdSTAInterface.html#a3e6855ecb1e0a63043e1f7670d56d661">WhdSTAInterface</a>.</p>

</div>
</div>
<a id="ae397ad3e4cb6c5a3adbcdcd2606e1652" name="ae397ad3e4cb6c5a3adbcdcd2606e1652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae397ad3e4cb6c5a3adbcdcd2606e1652">&#9670;&#160;</a></span>set_default_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkInterface::set_default_parameters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>defined(DOXYGEN_ONLY) </p>
<p>Set default parameters on an interface.</p>
<p>A network interface instantiated directly or using calls such as <a class="el" href="classWiFiInterface.html#a70d442535b92e16303d545f85047ce83">WiFiInterface::get_default_instance()</a> is initially unconfigured. This call can be used to set the default parameters that would have been set if the interface had been requested using <a class="el" href="#a91e2da33575adb34650601d50886b34d">NetworkInterface::get_default_instance()</a> (see nsapi JSON configuration). </p>

<p>Reimplemented in <a class="el" href="group__cellular.html#gab84901e500fb2bb9b64a71e79b2aa2a5">CellularInterface</a>, and <a class="el" href="classWiFiInterface.html#a8250569a79b1b63b0db04fa5ca9f3cfe">WiFiInterface</a>.</p>

</div>
</div>
<a id="ab7b6c4eea1704e7be7fd0b9cebe14cb0" name="ab7b6c4eea1704e7be7fd0b9cebe14cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b6c4eea1704e7be7fd0b9cebe14cb0">&#9670;&#160;</a></span>set_dhcp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::set_dhcp </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dhcp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable or disable DHCP on connecting the network.</p>
<p>Enabled by default unless a static IP address has been assigned. Requires that the network is disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dhcp</td><td>True to enable DHCP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success. </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if operation is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#acca7c79a4cb20bba79becf757f8b0dd2">EMACInterface</a>, and <a class="el" href="classL3IPInterface.html#a7ee2b03cfe2e21c259453d3476e52bf4">L3IPInterface</a>.</p>

</div>
</div>
<a id="a5777e4a15a153266cd18a7edb62c91bf" name="a5777e4a15a153266cd18a7edb62c91bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5777e4a15a153266cd18a7edb62c91bf">&#9670;&#160;</a></span>set_mac_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::set_mac_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>mac_addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__netsocket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a></td>          <td class="paramname"><span class="paramname"><em>addr_len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the MAC address to the interface.</p>
<p>Set the provided MAC address on the network interface. The address must be unique globally. The address must be set before calling the interface <a class="el" href="#aa7ef54ecbd066f2083e6031bd1f3cb00">connect()</a> method.</p>
<p>Not all interfaces are supporting MAC address set and an error is not returned for this method call. Verify the changed MAC address by checking packet captures from the used network interface.</p>
<p>6-byte EUI-48 MAC addresses are used for Ethernet while Mesh interface is using 8-byte EUI-64 address.</p>
<p>More information about obtaining MAC address can be found from: <a href="https://standards.ieee.org/products-services/regauth/index.html">https://standards.ieee.org/products-services/regauth/index.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mac_addr</td><td><a class="el" href="classBuffer.html">Buffer</a> containing the MAC address in hexadecimal format. </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of provided buffer in bytes (6 or 8) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if address is not valid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_BUSY</td><td>if address can't be set. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#ae055aff584c62505af85480188f8abe6">EMACInterface</a>, and <a class="el" href="classInterfaceNanostack.html#a62c565d6f5a6dae20186325dc640213b">InterfaceNanostack</a>.</p>

</div>
</div>
<a id="a4b94b4016ef38cb47c3af0c95d09bfd7" name="a4b94b4016ef38cb47c3af0c95d09bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b94b4016ef38cb47c3af0c95d09bfd7">&#9670;&#160;</a></span>set_network()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> NetworkInterface::set_network </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ip_address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>netmask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gateway</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configure this network interface to use a static IP address. Implicitly disables DHCP, which can be enabled in set_dhcp. Requires that the network is disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_address</td><td><a class="el" href="classSocketAddress.html">SocketAddress</a> object containing the local IP address </td></tr>
    <tr><td class="paramname">netmask</td><td><a class="el" href="classSocketAddress.html">SocketAddress</a> object containing the local network mask </td></tr>
    <tr><td class="paramname">gateway</td><td><a class="el" href="classSocketAddress.html">SocketAddress</a> object containing the local gateway </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this function is unsupported </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classEMACInterface.html#aca13ba088c16f8368946b928d344001e">EMACInterface</a>, <a class="el" href="classL3IPInterface.html#a7cf89a49e7bd919a87aa9c6098b8a851">L3IPInterface</a>, and <a class="el" href="classPPPInterface.html#a4c52d3cc56bde3eb370633cf57ce35ba">PPPInterface</a>.</p>

</div>
</div>
<a id="a1f8e041fcc7a5737761187ef8efb1193" name="a1f8e041fcc7a5737761187ef8efb1193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8e041fcc7a5737761187ef8efb1193">&#9670;&#160;</a></span>wifiInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classWiFiInterface.html">WiFiInterface</a> * NetworkInterface::wifiInterface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return pointer to a <a class="el" href="classWiFiInterface.html">WiFiInterface</a>. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="classWiFiInterface.html#a5ffdf0f107d7c3f2899513385afeb75a">WiFiInterface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/netsocket/include/netsocket/<a class="el" href="NetworkInterface_8h_source.html">NetworkInterface.h</a></li>
<li>/home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/netsocket/source/<b>NetworkInterface.cpp</b></li>
<li>/home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/netsocket/source/<b>NetworkInterfaceDefaults.cpp</b></li>
<li>/home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/netsocket/tests/UNITTESTS/doubles/<b>NetworkInterface_stub.cpp</b></li>
<li>/home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/netsocket/tests/UNITTESTS/doubles/<b>NetworkInterfaceDefaults_stub.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classNetworkInterface.html">NetworkInterface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
