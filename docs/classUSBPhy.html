<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: USBPhy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classUSBPhy.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classUSBPhy-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">USBPhy Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="USBPhy_8h_source.html">USBPhy.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for USBPhy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classUSBPhy.png" usemap="#USBPhy_map" alt=""/>
  <map id="USBPhy_map" name="USBPhy_map">
<area href="classUSBPhyHw.html" alt="USBPhyHw" shape="rect" coords="0,56,76,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaf1f382debf03c40872933585bf9adcf" id="r_aaf1f382debf03c40872933585bf9adcf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf1f382debf03c40872933585bf9adcf">init</a> (<a class="el" href="classUSBPhyEvents.html">USBPhyEvents</a> *events)=0</td></tr>
<tr class="separator:aaf1f382debf03c40872933585bf9adcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e23186fb9e6b146f10e1d80bc314852" id="r_a9e23186fb9e6b146f10e1d80bc314852"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e23186fb9e6b146f10e1d80bc314852">deinit</a> ()=0</td></tr>
<tr class="separator:a9e23186fb9e6b146f10e1d80bc314852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8035c6b7baf34159ae0484a67033ac7c" id="r_a8035c6b7baf34159ae0484a67033ac7c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8035c6b7baf34159ae0484a67033ac7c">powered</a> ()=0</td></tr>
<tr class="separator:a8035c6b7baf34159ae0484a67033ac7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d7036de07a01d9a39e7a9ec33dba8e" id="r_a36d7036de07a01d9a39e7a9ec33dba8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36d7036de07a01d9a39e7a9ec33dba8e">connect</a> ()=0</td></tr>
<tr class="separator:a36d7036de07a01d9a39e7a9ec33dba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5026559a66f72cab8dcb064d5e8de3e4" id="r_a5026559a66f72cab8dcb064d5e8de3e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5026559a66f72cab8dcb064d5e8de3e4">disconnect</a> ()=0</td></tr>
<tr class="separator:a5026559a66f72cab8dcb064d5e8de3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8558a8447eda10976d3b0ddb84d7acf3" id="r_a8558a8447eda10976d3b0ddb84d7acf3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8558a8447eda10976d3b0ddb84d7acf3">configure</a> ()=0</td></tr>
<tr class="separator:a8558a8447eda10976d3b0ddb84d7acf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd713b8ff8e6cd3cc7ce36cb6d8f41a" id="r_a0dd713b8ff8e6cd3cc7ce36cb6d8f41a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd713b8ff8e6cd3cc7ce36cb6d8f41a">unconfigure</a> ()=0</td></tr>
<tr class="separator:a0dd713b8ff8e6cd3cc7ce36cb6d8f41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd6fc74f58bd2e32bf15add0bb67cee" id="r_adcd6fc74f58bd2e32bf15add0bb67cee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcd6fc74f58bd2e32bf15add0bb67cee">sof_enable</a> ()=0</td></tr>
<tr class="separator:adcd6fc74f58bd2e32bf15add0bb67cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbe07ff8e1afd2d04f227a0b769826e" id="r_acfbe07ff8e1afd2d04f227a0b769826e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfbe07ff8e1afd2d04f227a0b769826e">sof_disable</a> ()=0</td></tr>
<tr class="separator:acfbe07ff8e1afd2d04f227a0b769826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4173fbd828099cd6f1001196d554f8" id="r_acf4173fbd828099cd6f1001196d554f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf4173fbd828099cd6f1001196d554f8">set_address</a> (uint8_t address)=0</td></tr>
<tr class="separator:acf4173fbd828099cd6f1001196d554f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecc7d51e674e1e457a1b9c4c6efcf48" id="r_a3ecc7d51e674e1e457a1b9c4c6efcf48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ecc7d51e674e1e457a1b9c4c6efcf48">remote_wakeup</a> ()=0</td></tr>
<tr class="separator:a3ecc7d51e674e1e457a1b9c4c6efcf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3acf87f9c1785d9734553881fa48b8" id="r_a8d3acf87f9c1785d9734553881fa48b8"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structusb__ep__table__t.html">usb_ep_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d3acf87f9c1785d9734553881fa48b8">endpoint_table</a> ()=0</td></tr>
<tr class="separator:a8d3acf87f9c1785d9734553881fa48b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebed09bfb9b700639185f7a87d04e4e7" id="r_aebed09bfb9b700639185f7a87d04e4e7"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebed09bfb9b700639185f7a87d04e4e7">ep0_set_max_packet</a> (uint32_t max_packet)=0</td></tr>
<tr class="separator:aebed09bfb9b700639185f7a87d04e4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8008022bee75eb5aeaab562bfdb19848" id="r_a8008022bee75eb5aeaab562bfdb19848"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8008022bee75eb5aeaab562bfdb19848">ep0_setup_read_result</a> (uint8_t *<a class="el" href="structbuffer.html">buffer</a>, uint32_t size)=0</td></tr>
<tr class="separator:a8008022bee75eb5aeaab562bfdb19848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651a323135ae14467d568308f9f879f4" id="r_a651a323135ae14467d568308f9f879f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a651a323135ae14467d568308f9f879f4">ep0_read</a> (uint8_t *data, uint32_t size)=0</td></tr>
<tr class="separator:a651a323135ae14467d568308f9f879f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9e51c417b5e8e0f8504de61a7afc21" id="r_a0d9e51c417b5e8e0f8504de61a7afc21"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d9e51c417b5e8e0f8504de61a7afc21">ep0_read_result</a> ()=0</td></tr>
<tr class="separator:a0d9e51c417b5e8e0f8504de61a7afc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f09d7223d895c91dc474eb0c387cf4" id="r_a92f09d7223d895c91dc474eb0c387cf4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92f09d7223d895c91dc474eb0c387cf4">ep0_write</a> (uint8_t *<a class="el" href="structbuffer.html">buffer</a>, uint32_t size)=0</td></tr>
<tr class="separator:a92f09d7223d895c91dc474eb0c387cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495e30a2fe39a7b94b80a391417efae8" id="r_a495e30a2fe39a7b94b80a391417efae8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a495e30a2fe39a7b94b80a391417efae8">ep0_stall</a> ()=0</td></tr>
<tr class="separator:a495e30a2fe39a7b94b80a391417efae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0ba90fa3d1ef16db37afdab9698f12" id="r_aff0ba90fa3d1ef16db37afdab9698f12"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff0ba90fa3d1ef16db37afdab9698f12">endpoint_add</a> (usb_ep_t endpoint, uint32_t max_packet, usb_ep_type_t type)=0</td></tr>
<tr class="separator:aff0ba90fa3d1ef16db37afdab9698f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af605fd6f25ae8de2266e5e066f401d12" id="r_af605fd6f25ae8de2266e5e066f401d12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af605fd6f25ae8de2266e5e066f401d12">endpoint_remove</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="separator:af605fd6f25ae8de2266e5e066f401d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1448e56f521cb9730f2660bb8d471d4f" id="r_a1448e56f521cb9730f2660bb8d471d4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1448e56f521cb9730f2660bb8d471d4f">endpoint_stall</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="separator:a1448e56f521cb9730f2660bb8d471d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192f42e02cea8b5e9adb7ab5aaa0e198" id="r_a192f42e02cea8b5e9adb7ab5aaa0e198"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a192f42e02cea8b5e9adb7ab5aaa0e198">endpoint_unstall</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="separator:a192f42e02cea8b5e9adb7ab5aaa0e198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab761a1a648afb886ebc0321dac50e383" id="r_ab761a1a648afb886ebc0321dac50e383"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab761a1a648afb886ebc0321dac50e383">endpoint_read</a> (usb_ep_t endpoint, uint8_t *data, uint32_t size)=0</td></tr>
<tr class="separator:ab761a1a648afb886ebc0321dac50e383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ccc62034eee7fd474323a6d1facb04" id="r_a73ccc62034eee7fd474323a6d1facb04"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73ccc62034eee7fd474323a6d1facb04">endpoint_read_result</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="separator:a73ccc62034eee7fd474323a6d1facb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3098c2e0d14d537aea64dfb8a733753" id="r_af3098c2e0d14d537aea64dfb8a733753"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3098c2e0d14d537aea64dfb8a733753">endpoint_write</a> (usb_ep_t endpoint, uint8_t *data, uint32_t size)=0</td></tr>
<tr class="separator:af3098c2e0d14d537aea64dfb8a733753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa542f475942e767937cfed9e7eb54840" id="r_aa542f475942e767937cfed9e7eb54840"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa542f475942e767937cfed9e7eb54840">endpoint_abort</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="separator:aa542f475942e767937cfed9e7eb54840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c3df31fe8a96c9f984d29a58dad4d0" id="r_a24c3df31fe8a96c9f984d29a58dad4d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24c3df31fe8a96c9f984d29a58dad4d0">process</a> ()=0</td></tr>
<tr class="separator:a24c3df31fe8a96c9f984d29a58dad4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract interface to physical USB hardware</p>
<h1><a class="anchor" id="autotoc_md768"></a>
Defined behavior</h1>
<ul>
<li>You can use any endpoint configurations that fit in the parameters of the table returned by <a class="el" href="#a8d3acf87f9c1785d9734553881fa48b8">USBPhy::endpoint_table</a>.</li>
<li>You can use all endpoints in any valid endpoint configuration concurrently.</li>
<li>The device supports use of at least one control, bulk, interrupt and isochronous in each direction at the same time - at least 8 endpoints.</li>
<li><a class="el" href="classUSBPhy.html">USBPhy</a> supports all standard endpoint sizes (wMaxPacketSize).</li>
<li><a class="el" href="classUSBPhy.html">USBPhy</a> can handle an interrupt latency of at least 100ms if the host PC is not performing a reset or setting the device's address.</li>
<li><a class="el" href="classUSBPhy.html">USBPhy</a> only sends <a class="el" href="classUSBPhyEvents.html">USBPhyEvents</a> when it is in the initialized state.</li>
<li>When unpowered, <a class="el" href="classUSBPhy.html">USBPhy</a> only sends the <a class="el" href="classUSBPhyEvents.html#ac050c589b6512c07e20822418d73482a">USBPhyEvents::power</a> event.</li>
<li>On USB reset, all endpoints are removed except for endpoint 0.</li>
<li>A call to <a class="el" href="#a92f09d7223d895c91dc474eb0c387cf4">USBPhy::ep0_write</a> results in the call of <a class="el" href="classUSBPhyEvents.html#a00160ae065d90ba8c882d23a8451b5f2">USBPhyEvents::in</a> when the PC reads the data unless a power loss, reset, or a call to <a class="el" href="#a5026559a66f72cab8dcb064d5e8de3e4">USBPhy::disconnect</a> occurs first.</li>
<li>A call to <a class="el" href="#af3098c2e0d14d537aea64dfb8a733753">USBPhy::endpoint_write</a> results in the call of <a class="el" href="classUSBPhyEvents.html#a00160ae065d90ba8c882d23a8451b5f2">USBPhyEvents::in</a> when the pc reads the data unless a power loss, reset, or a call to <a class="el" href="#aa542f475942e767937cfed9e7eb54840">USBPhy::endpoint_abort</a> occurs first.</li>
<li>A call to <a class="el" href="#ab761a1a648afb886ebc0321dac50e383">USBPhy::endpoint_read</a> results in the call of <a class="el" href="classUSBPhyEvents.html#a30d85c54ae549e63c011868db4161388">USBPhyEvents::out</a> when the pc sends data unless a power loss, reset, or a call to <a class="el" href="#aa542f475942e767937cfed9e7eb54840">USBPhy::endpoint_abort</a> occurs first.</li>
<li>Endpoint 0 naks all transactions aside from setup packets until higher-level code calls one of <a class="el" href="#a651a323135ae14467d568308f9f879f4">USBPhy::ep0_read</a>, <a class="el" href="#a92f09d7223d895c91dc474eb0c387cf4">USBPhy::ep0_write</a> or <a class="el" href="#a495e30a2fe39a7b94b80a391417efae8">USBPhy::ep0_stall</a>.</li>
<li>Endpoint 0 stall automatically clears on reception of a setup packet.</li>
</ul>
<h1><a class="anchor" id="autotoc_md769"></a>
Undefined behavior</h1>
<ul>
<li>Calling <a class="el" href="#aff0ba90fa3d1ef16db37afdab9698f12">USBPhy::endpoint_add</a> or <a class="el" href="#af605fd6f25ae8de2266e5e066f401d12">USBPhy::endpoint_remove</a> outside of the control requests SetInterface or SetConfiguration.</li>
<li>Calling <a class="el" href="#af605fd6f25ae8de2266e5e066f401d12">USBPhy::endpoint_remove</a> on an endpoint that has an ongoing read or write operation. To avoid undefined behavior, you must abort ongoing operations with <a class="el" href="#aa542f475942e767937cfed9e7eb54840">USBPhy::endpoint_abort</a>.</li>
<li>Devices behavior is undefined if latency is greater than 2ms when address is being set - see USB spec 9.2.6.3.</li>
<li>Devices behavior is undefined if latency is greater than 10ms when a reset occurs - see USB spec 7.1.7.5.</li>
<li>Calling any of the USBPhy::endpoint_* functions on endpoint 0.</li>
</ul>
<h1><a class="anchor" id="autotoc_md770"></a>
Notes</h1>
<ul>
<li>Make sure <a class="el" href="classUSBPhy.html">USBPhy</a> sends <a class="el" href="classUSBPhyEvents.html">USBPhyEvents</a> in the correct order when multiple packets are present. <a class="el" href="classUSBPhy.html">USBPhy</a> must send IN endpoint events before OUT endpoint events if both are pending.</li>
<li>A host PC may resend setup packets to a USB device if there is noise on the USB line. The <a class="el" href="classUSBPhy.html">USBPhy</a> should be able to handle this scenario and respond to the setup packet with an ACK.</li>
<li>Bidirectional protocols making use of alternating IN and OUT phases should not rely on the last ACK an IN transfer to indicate that the OUT phase should start. Instead, the OUT phase should be started at the same time the last IN transfer is started. This is because the ACK to the last in transfer may be dropped if there is noise on the USB line. If dropped, it will only be resent on the next IN phase. You can find more information on this in section 8.5.3.3 of the USB specification. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8558a8447eda10976d3b0ddb84d7acf3" name="a8558a8447eda10976d3b0ddb84d7acf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8558a8447eda10976d3b0ddb84d7acf3">&#9670;&#160;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::configure </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set this device to the configured state</p>
<p>Enable added endpoints if they are not enabled already. </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a2385bd6e09003b60a55557e11555818d">USBPhyHw</a>.</p>

</div>
</div>
<a id="a36d7036de07a01d9a39e7a9ec33dba8e" name="a36d7036de07a01d9a39e7a9ec33dba8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d7036de07a01d9a39e7a9ec33dba8e">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::connect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the USB phy visible to the USB host</p>
<p>Enable either the D+ or D- pullup so the host can detect the presence of this device. </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a6d3fe07338af79b4bbabf7066e0b9e62">USBPhyHw</a>.</p>

</div>
</div>
<a id="a9e23186fb9e6b146f10e1d80bc314852" name="a9e23186fb9e6b146f10e1d80bc314852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e23186fb9e6b146f10e1d80bc314852">&#9670;&#160;</a></span>deinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::deinit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Power down this <a class="el" href="classUSBPhy.html">USBPhy</a> instance</p>
<p>Disable interrupts and stop sending events. </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#ab91a6c8a9ffd0603ea4f5fff59ff095a">USBPhyHw</a>.</p>

</div>
</div>
<a id="a5026559a66f72cab8dcb064d5e8de3e4" name="a5026559a66f72cab8dcb064d5e8de3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5026559a66f72cab8dcb064d5e8de3e4">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::disconnect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detach the USB phy</p>
<p>Disable the D+ and D- pullup and stop responding to USB traffic. </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a9895b388c79ca55221387e2904f87004">USBPhyHw</a>.</p>

</div>
</div>
<a id="aa542f475942e767937cfed9e7eb54840" name="aa542f475942e767937cfed9e7eb54840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa542f475942e767937cfed9e7eb54840">&#9670;&#160;</a></span>endpoint_abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::endpoint_abort </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t</td>          <td class="paramname"><span class="paramname"><em>endpoint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Abort the current transfer if it has not yet been sent</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to abort the transfer on. It is implementation defined if this function has an effect on receive endpoints. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#ad542f3a96e285fe33b7d8974cffa84f2">USBPhyHw</a>.</p>

</div>
</div>
<a id="aff0ba90fa3d1ef16db37afdab9698f12" name="aff0ba90fa3d1ef16db37afdab9698f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0ba90fa3d1ef16db37afdab9698f12">&#9670;&#160;</a></span>endpoint_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool USBPhy::endpoint_add </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t</td>          <td class="paramname"><span class="paramname"><em>endpoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_packet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usb_ep_type_t</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configure and enable an endpoint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to configure and enable </td></tr>
    <tr><td class="paramname">max_packet</td><td>The maximum packet size that can be sent or received </td></tr>
    <tr><td class="paramname">type</td><td>The type of endpoint this should be configured as - USB_EP_TYPE_BULK, USB_EP_TYPE_INT or USB_EP_TYPE_ISO </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot be used to configure endpoint 0. That must be done with ep0_set_max_packet </dd></dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a43dd83564baf19b76839c0a0ed3ad5f6">USBPhyHw</a>.</p>

</div>
</div>
<a id="ab761a1a648afb886ebc0321dac50e383" name="ab761a1a648afb886ebc0321dac50e383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab761a1a648afb886ebc0321dac50e383">&#9670;&#160;</a></span>endpoint_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool USBPhy::endpoint_read </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t</td>          <td class="paramname"><span class="paramname"><em>endpoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a read on the given endpoint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to start the read on </td></tr>
    <tr><td class="paramname">data</td><td><a class="el" href="classBuffer.html">Buffer</a> to fill with data </td></tr>
    <tr><td class="paramname">size</td><td>Size of the read buffer. This must be at least the max packet size for this endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the read was successfully started, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a84876a5be37ea23ecef91a092d1c52c9">USBPhyHw</a>.</p>

</div>
</div>
<a id="a73ccc62034eee7fd474323a6d1facb04" name="a73ccc62034eee7fd474323a6d1facb04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ccc62034eee7fd474323a6d1facb04">&#9670;&#160;</a></span>endpoint_read_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t USBPhy::endpoint_read_result </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t</td>          <td class="paramname"><span class="paramname"><em>endpoint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finish a read on the given endpoint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received </dd></dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a5604e9021e36936f6a487853cc688c17">USBPhyHw</a>.</p>

</div>
</div>
<a id="af605fd6f25ae8de2266e5e066f401d12" name="af605fd6f25ae8de2266e5e066f401d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af605fd6f25ae8de2266e5e066f401d12">&#9670;&#160;</a></span>endpoint_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::endpoint_remove </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t</td>          <td class="paramname"><span class="paramname"><em>endpoint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable an endpoint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to disable </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a16531f168c849169a8fb04a209feded7">USBPhyHw</a>.</p>

</div>
</div>
<a id="a1448e56f521cb9730f2660bb8d471d4f" name="a1448e56f521cb9730f2660bb8d471d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1448e56f521cb9730f2660bb8d471d4f">&#9670;&#160;</a></span>endpoint_stall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::endpoint_stall </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t</td>          <td class="paramname"><span class="paramname"><em>endpoint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a functional stall on the given endpoint</p>
<p>Set the HALT feature for this endpoint so that all further communication is aborted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to stall </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a09404803c4950ab2361a80ff4e23e797">USBPhyHw</a>.</p>

</div>
</div>
<a id="a8d3acf87f9c1785d9734553881fa48b8" name="a8d3acf87f9c1785d9734553881fa48b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3acf87f9c1785d9734553881fa48b8">&#9670;&#160;</a></span>endpoint_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structusb__ep__table__t.html">usb_ep_table_t</a> * USBPhy::endpoint_table </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the endpoint table</p>
<p>This function returns a table which describes the endpoints can be used, the functionality of those endpoints and the resource cost. </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#adf534de0f74c93c1fc75f74b882056d6">USBPhyHw</a>.</p>

</div>
</div>
<a id="a192f42e02cea8b5e9adb7ab5aaa0e198" name="a192f42e02cea8b5e9adb7ab5aaa0e198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192f42e02cea8b5e9adb7ab5aaa0e198">&#9670;&#160;</a></span>endpoint_unstall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::endpoint_unstall </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t</td>          <td class="paramname"><span class="paramname"><em>endpoint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Un-stall the endpoint</p>
<p>Clear the HALT feature on this endpoint so communication can resume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to stall </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a901a6e75b4833a0ced557fad44fc5d23">USBPhyHw</a>.</p>

</div>
</div>
<a id="af3098c2e0d14d537aea64dfb8a733753" name="af3098c2e0d14d537aea64dfb8a733753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3098c2e0d14d537aea64dfb8a733753">&#9670;&#160;</a></span>endpoint_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool USBPhy::endpoint_write </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t</td>          <td class="paramname"><span class="paramname"><em>endpoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a write on the given endpoint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to write to </td></tr>
    <tr><td class="paramname">data</td><td><a class="el" href="classBuffer.html">Buffer</a> to write </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the data was prepared for transmit, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#aac3a9362bc05e05c4386d43e7d0643f6">USBPhyHw</a>.</p>

</div>
</div>
<a id="a651a323135ae14467d568308f9f879f4" name="a651a323135ae14467d568308f9f879f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651a323135ae14467d568308f9f879f4">&#9670;&#160;</a></span>ep0_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::ep0_read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start receiving a packet of up to wMaxPacketSize on endpoint 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td><a class="el" href="classBuffer.html">Buffer</a> to fill with the data read </td></tr>
    <tr><td class="paramname">size</td><td>Size of buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a6dd112def9c9457c750ed2b971a42de6">USBPhyHw</a>.</p>

</div>
</div>
<a id="a0d9e51c417b5e8e0f8504de61a7afc21" name="a0d9e51c417b5e8e0f8504de61a7afc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9e51c417b5e8e0f8504de61a7afc21">&#9670;&#160;</a></span>ep0_read_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t USBPhy::ep0_read_result </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the contents of a received packet</p>
<dl class="section return"><dt>Returns</dt><dd>Size of data read </dd></dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#ae7eccf1dd720cfeae054dcaaf14d2099">USBPhyHw</a>.</p>

</div>
</div>
<a id="aebed09bfb9b700639185f7a87d04e4e7" name="aebed09bfb9b700639185f7a87d04e4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebed09bfb9b700639185f7a87d04e4e7">&#9670;&#160;</a></span>ep0_set_max_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t USBPhy::ep0_set_max_packet </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set wMaxPacketSize of endpoint 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_packet</td><td>The wMaxPacketSize value for endpoint 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual size of endpoint 0 </dd></dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#afdbb47d6376ee730605a56185c231be3">USBPhyHw</a>.</p>

</div>
</div>
<a id="a8008022bee75eb5aeaab562bfdb19848" name="a8008022bee75eb5aeaab562bfdb19848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8008022bee75eb5aeaab562bfdb19848">&#9670;&#160;</a></span>ep0_setup_read_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::ep0_setup_read_result </td>
          <td>(</td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the contents of the SETUP packet</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="classBuffer.html">Buffer</a> to fill with data </td></tr>
    <tr><td class="paramname">size</td><td>Size of buffer passed in </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a8233e9800e52038fcca0edcff8e93268">USBPhyHw</a>.</p>

</div>
</div>
<a id="a495e30a2fe39a7b94b80a391417efae8" name="a495e30a2fe39a7b94b80a391417efae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495e30a2fe39a7b94b80a391417efae8">&#9670;&#160;</a></span>ep0_stall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::ep0_stall </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Protocol stall on endpoint 0</p>
<p>Stall all IN and OUT packets on endpoint 0 until a setup packet is received. </p><dl class="section note"><dt>Note</dt><dd>The stall is cleared automatically when a setup packet is received </dd></dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#addfdbbc15166f3d25f31ed37c6ee4e87">USBPhyHw</a>.</p>

</div>
</div>
<a id="a92f09d7223d895c91dc474eb0c387cf4" name="a92f09d7223d895c91dc474eb0c387cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f09d7223d895c91dc474eb0c387cf4">&#9670;&#160;</a></span>ep0_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::ep0_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a packet on endpoint 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="classBuffer.html">Buffer</a> fill with data to send </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to send </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a6fe0dc5d60f90f1d080d2dcab63d0095">USBPhyHw</a>.</p>

</div>
</div>
<a id="aaf1f382debf03c40872933585bf9adcf" name="aaf1f382debf03c40872933585bf9adcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1f382debf03c40872933585bf9adcf">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUSBPhyEvents.html">USBPhyEvents</a> *</td>          <td class="paramname"><span class="paramname"><em>events</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize this <a class="el" href="classUSBPhy.html">USBPhy</a> instance</p>
<p>This function must be called before calling any other functions of this class, unless specifically noted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td><a class="el" href="classCallback.html">Callback</a> class to handle USB events </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a4d329d70e53db172ae813b3420fda784">USBPhyHw</a>.</p>

</div>
</div>
<a id="a8035c6b7baf34159ae0484a67033ac7c" name="a8035c6b7baf34159ae0484a67033ac7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8035c6b7baf34159ae0484a67033ac7c">&#9670;&#160;</a></span>powered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool USBPhy::powered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if USB power is present</p>
<p>Devices which don't support checking the USB power state must always return true.</p>
<dl class="section return"><dt>Returns</dt><dd>true if USB power is present, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a4295f591f21ef447132a33dfa606ae32">USBPhyHw</a>.</p>

</div>
</div>
<a id="a24c3df31fe8a96c9f984d29a58dad4d0" name="a24c3df31fe8a96c9f984d29a58dad4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c3df31fe8a96c9f984d29a58dad4d0">&#9670;&#160;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::process </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classCallback.html">Callback</a> used for performing USB processing</p>
<p><a class="el" href="classUSBPhy.html">USBPhy</a> processing should be triggered by calling <a class="el" href="classUSBPhyEvents.html#aa78edce81922d53fc70e0ea3554647f2">USBPhyEvents::start_process</a> and done inside process. All <a class="el" href="classUSBPhyEvents.html">USBPhyEvents</a> callbacks aside from <a class="el" href="classUSBPhyEvents.html#aa78edce81922d53fc70e0ea3554647f2">USBPhyEvents::start_process</a> must be called in the context of process </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#adc689fb3490a092086654b320df60ee5">USBPhyHw</a>.</p>

</div>
</div>
<a id="a3ecc7d51e674e1e457a1b9c4c6efcf48" name="a3ecc7d51e674e1e457a1b9c4c6efcf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecc7d51e674e1e457a1b9c4c6efcf48">&#9670;&#160;</a></span>remote_wakeup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::remote_wakeup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wake upstream devices </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#ab54eb8eb13df8dbf11754290dd0d95e3">USBPhyHw</a>.</p>

</div>
</div>
<a id="acf4173fbd828099cd6f1001196d554f8" name="acf4173fbd828099cd6f1001196d554f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4173fbd828099cd6f1001196d554f8">&#9670;&#160;</a></span>set_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::set_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <a class="el" href="classUSBPhy.html">USBPhy</a>'s address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>This device's USB address </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#ab0925a25581497b62b551eb24bf4fd2c">USBPhyHw</a>.</p>

</div>
</div>
<a id="acfbe07ff8e1afd2d04f227a0b769826e" name="acfbe07ff8e1afd2d04f227a0b769826e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbe07ff8e1afd2d04f227a0b769826e">&#9670;&#160;</a></span>sof_disable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::sof_disable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable the start of frame interrupt</p>
<p>Stop calling <a class="el" href="classUSBPhyEvents.html#a388cf96ba5f6133d0ea4392a32d9fc21">USBPhyEvents::sof</a>. </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#ac0c34400e55d94d6668bdcf9236809f5">USBPhyHw</a>.</p>

</div>
</div>
<a id="adcd6fc74f58bd2e32bf15add0bb67cee" name="adcd6fc74f58bd2e32bf15add0bb67cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd6fc74f58bd2e32bf15add0bb67cee">&#9670;&#160;</a></span>sof_enable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::sof_enable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable the start of frame interrupt</p>
<p>Call <a class="el" href="classUSBPhyEvents.html#a388cf96ba5f6133d0ea4392a32d9fc21">USBPhyEvents::sof</a> on every frame. </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a33392e7ce1f529a35dcf41698f60e420">USBPhyHw</a>.</p>

</div>
</div>
<a id="a0dd713b8ff8e6cd3cc7ce36cb6d8f41a" name="a0dd713b8ff8e6cd3cc7ce36cb6d8f41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd713b8ff8e6cd3cc7ce36cb6d8f41a">&#9670;&#160;</a></span>unconfigure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void USBPhy::unconfigure </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Leave the configured state</p>
<p>This is a notification to the <a class="el" href="classUSBPhy.html">USBPhy</a> indicating that the device is leaving the configured state. The <a class="el" href="classUSBPhy.html">USBPhy</a> can disable all endpoints other than endpoint 0. </p>

<p>Implemented in <a class="el" href="classUSBPhyHw.html#a8109d2bd82ffe4e19d47ec3ff85236f0">USBPhyHw</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/zoe/Mbed Programs/esp_code/mbed-os/hal/usb/include/usb/<a class="el" href="USBPhy_8h_source.html">USBPhy.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classUSBPhy.html">USBPhy</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
