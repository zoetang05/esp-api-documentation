<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: mbed::ATHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classmbed_1_1ATHandler.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmbed_1_1ATHandler-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mbed::ATHandler Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for sending AT commands and parsing AT responses.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ATHandler_8h_source.html">ATHandler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8c148197b0cb7dc72bd00da120ec9f62" id="r_a8c148197b0cb7dc72bd00da120ec9f62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c148197b0cb7dc72bd00da120ec9f62">ATHandler</a> (<a class="el" href="classmbed_1_1FileHandle.html">FileHandle</a> *fh, <a class="el" href="classevents_1_1EventQueue.html">events::EventQueue</a> &amp;queue, uint32_t timeout, const char *output_delimiter, uint16_t send_delay=0)</td></tr>
<tr class="separator:a8c148197b0cb7dc72bd00da120ec9f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2982bbff172c4b158c7ad679f32b4a5" id="r_ac2982bbff172c4b158c7ad679f32b4a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2982bbff172c4b158c7ad679f32b4a5">ATHandler</a> (<a class="el" href="classmbed_1_1FileHandle.html">FileHandle</a> *fh, <a class="el" href="classevents_1_1EventQueue.html">events::EventQueue</a> &amp;queue, mbed::chrono::milliseconds_u32 timeout, const char *output_delimiter, std::chrono::duration&lt; uint16_t, std::milli &gt; send_delay=std::chrono::milliseconds(0))</td></tr>
<tr class="separator:ac2982bbff172c4b158c7ad679f32b4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afe038fc1b18b91029a97ae14c73b9c" id="r_a2afe038fc1b18b91029a97ae14c73b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1FileHandle.html">FileHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2afe038fc1b18b91029a97ae14c73b9c">get_file_handle</a> ()</td></tr>
<tr class="separator:a2afe038fc1b18b91029a97ae14c73b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e3d71b965e7fe431360cf172a63da9" id="r_aa5e3d71b965e7fe431360cf172a63da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5e3d71b965e7fe431360cf172a63da9">lock</a> ()</td></tr>
<tr class="separator:aa5e3d71b965e7fe431360cf172a63da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044783bc022a795751250e180ed87b4b" id="r_a044783bc022a795751250e180ed87b4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044783bc022a795751250e180ed87b4b">unlock</a> ()</td></tr>
<tr class="separator:a044783bc022a795751250e180ed87b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2ab7afb2165ff68510480c0d3e6e22" id="r_adf2ab7afb2165ff68510480c0d3e6e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf2ab7afb2165ff68510480c0d3e6e22">unlock_return_error</a> ()</td></tr>
<tr class="separator:adf2ab7afb2165ff68510480c0d3e6e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad040a55dcf9137cebbe4ff2e21e1c4f3" id="r_ad040a55dcf9137cebbe4ff2e21e1c4f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad040a55dcf9137cebbe4ff2e21e1c4f3">set_urc_handler</a> (const char *prefix, <a class="el" href="classmbed_1_1Callback.html">Callback</a>&lt; void()&gt; <a class="el" href="group__platform__Callback.html#gab5b487a96d7f93eca70393685cd56f5f">callback</a>)</td></tr>
<tr class="separator:ad040a55dcf9137cebbe4ff2e21e1c4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a1610dca6a2b9357574b9906b5e6eb" id="r_a16a1610dca6a2b9357574b9906b5e6eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16a1610dca6a2b9357574b9906b5e6eb">get_last_error</a> () const</td></tr>
<tr class="separator:a16a1610dca6a2b9357574b9906b5e6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6c9d9e4b7b07176287dd28a8ea3032" id="r_a4d6c9d9e4b7b07176287dd28a8ea3032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbed_1_1device__err__t.html">device_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d6c9d9e4b7b07176287dd28a8ea3032">get_last_device_error</a> () const</td></tr>
<tr class="separator:a4d6c9d9e4b7b07176287dd28a8ea3032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6929b0aad444f1b9a5b60a01217c69" id="r_a4c6929b0aad444f1b9a5b60a01217c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c6929b0aad444f1b9a5b60a01217c69">set_at_timeout</a> (uint32_t timeout_milliseconds, bool default_timeout=false)</td></tr>
<tr class="separator:a4c6929b0aad444f1b9a5b60a01217c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd569e771ba365002bd4b9facc72ef0" id="r_a0fd569e771ba365002bd4b9facc72ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fd569e771ba365002bd4b9facc72ef0">set_at_timeout</a> (mbed::chrono::milliseconds_u32 timeout, bool default_timeout=false)</td></tr>
<tr class="separator:a0fd569e771ba365002bd4b9facc72ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffc1b0a03b6ce02ea578ef81f32e089" id="r_a7ffc1b0a03b6ce02ea578ef81f32e089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ffc1b0a03b6ce02ea578ef81f32e089">restore_at_timeout</a> ()</td></tr>
<tr class="separator:a7ffc1b0a03b6ce02ea578ef81f32e089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c8618ddb52d66c3ec70dcb1d159ba0" id="r_a27c8618ddb52d66c3ec70dcb1d159ba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27c8618ddb52d66c3ec70dcb1d159ba0">clear_error</a> ()</td></tr>
<tr class="separator:a27c8618ddb52d66c3ec70dcb1d159ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456bf36984af76a0df90543c2c05febe" id="r_a456bf36984af76a0df90543c2c05febe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a456bf36984af76a0df90543c2c05febe">flush</a> ()</td></tr>
<tr class="separator:a456bf36984af76a0df90543c2c05febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b210bf525133329e75dd2ae75460002" id="r_a4b210bf525133329e75dd2ae75460002"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b210bf525133329e75dd2ae75460002">process_oob</a> ()</td></tr>
<tr class="separator:a4b210bf525133329e75dd2ae75460002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0fb0d267d0c88c8b72d15138c8d5b7" id="r_aef0fb0d267d0c88c8b72d15138c8d5b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef0fb0d267d0c88c8b72d15138c8d5b7">set_is_filehandle_usable</a> (bool usable)</td></tr>
<tr class="separator:aef0fb0d267d0c88c8b72d15138c8d5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94407adf7676fab46c1440a58d82b7b7" id="r_a94407adf7676fab46c1440a58d82b7b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94407adf7676fab46c1440a58d82b7b7">sync</a> (int timeout_ms)</td></tr>
<tr class="separator:a94407adf7676fab46c1440a58d82b7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eb18a84839f50ffc83df81532d0215" id="r_a20eb18a84839f50ffc83df81532d0215"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20eb18a84839f50ffc83df81532d0215">sync</a> (std::chrono::duration&lt; int, std::milli &gt; timeout)</td></tr>
<tr class="separator:a20eb18a84839f50ffc83df81532d0215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ab3c27df8512fbac73febfbc3fda65" id="r_a45ab3c27df8512fbac73febfbc3fda65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45ab3c27df8512fbac73febfbc3fda65">set_send_delay</a> (uint16_t send_delay)</td></tr>
<tr class="separator:a45ab3c27df8512fbac73febfbc3fda65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1349a00da5592ee3a58797297f06c406" id="r_a1349a00da5592ee3a58797297f06c406"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1349a00da5592ee3a58797297f06c406">set_baud</a> (int baud_rate)</td></tr>
<tr class="separator:a1349a00da5592ee3a58797297f06c406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacb5e971f20468c5c10c27183347184" id="r_adacb5e971f20468c5c10c27183347184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adacb5e971f20468c5c10c27183347184">cmd_start</a> (const char *cmd)</td></tr>
<tr class="separator:adacb5e971f20468c5c10c27183347184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4b0589759c717b3301abf034f9b9f4" id="r_a8c4b0589759c717b3301abf034f9b9f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c4b0589759c717b3301abf034f9b9f4">cmd_start_stop</a> (const char *cmd, const char *cmd_chr, const char *format=&quot;&quot;,...)</td></tr>
<tr class="memdesc:a8c4b0589759c717b3301abf034f9b9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmd_start_stop Starts an AT command, writes given variadic arguments and stops the command. Use this command when you need multiple response parameters to be handled. NOTE: Does not lock <a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for process!  <br /></td></tr>
<tr class="separator:a8c4b0589759c717b3301abf034f9b9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dce5418cdcc4f11242ee55dff8c402c" id="r_a4dce5418cdcc4f11242ee55dff8c402c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dce5418cdcc4f11242ee55dff8c402c">at_cmd_str</a> (const char *cmd, const char *cmd_chr, char *resp_buf, size_t resp_buf_size, const char *format=&quot;&quot;,...)</td></tr>
<tr class="memdesc:a4dce5418cdcc4f11242ee55dff8c402c"><td class="mdescLeft">&#160;</td><td class="mdescRight">at_cmd_str Send an AT command and read a single string response. Locks and unlocks <a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for operation  <br /></td></tr>
<tr class="separator:a4dce5418cdcc4f11242ee55dff8c402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faed5a066af88e5ac789e3bea1e5c5f" id="r_a4faed5a066af88e5ac789e3bea1e5c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4faed5a066af88e5ac789e3bea1e5c5f">at_cmd_int</a> (const char *cmd, const char *cmd_chr, int &amp;resp, const char *format=&quot;&quot;,...)</td></tr>
<tr class="memdesc:a4faed5a066af88e5ac789e3bea1e5c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">at_cmd_int Send an AT command and read a single integer response. Locks and unlocks <a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for operation  <br /></td></tr>
<tr class="separator:a4faed5a066af88e5ac789e3bea1e5c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a95bf17e7ac99f8d1a776ac4cb19888" id="r_a6a95bf17e7ac99f8d1a776ac4cb19888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a95bf17e7ac99f8d1a776ac4cb19888">at_cmd_discard</a> (const char *cmd, const char *cmd_chr, const char *format=&quot;&quot;,...)</td></tr>
<tr class="memdesc:a6a95bf17e7ac99f8d1a776ac4cb19888"><td class="mdescLeft">&#160;</td><td class="mdescRight">at_cmd_discard Send an AT command and read and discard a response. Locks and unlocks <a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for operation  <br /></td></tr>
<tr class="separator:a6a95bf17e7ac99f8d1a776ac4cb19888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada30ce5e77da89590f6f266f0cfe3c2e" id="r_ada30ce5e77da89590f6f266f0cfe3c2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada30ce5e77da89590f6f266f0cfe3c2e">write_int</a> (int32_t <a class="el" href="wsf__trace_8c.html#aba18f3d521fde3af39c58b809a9c7ef0">param</a>)</td></tr>
<tr class="separator:ada30ce5e77da89590f6f266f0cfe3c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db6044f5f2ddc62ea9c51f39601eaaa" id="r_a4db6044f5f2ddc62ea9c51f39601eaaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4db6044f5f2ddc62ea9c51f39601eaaa">write_string</a> (const char *<a class="el" href="wsf__trace_8c.html#aba18f3d521fde3af39c58b809a9c7ef0">param</a>, bool useQuotations=true)</td></tr>
<tr class="separator:a4db6044f5f2ddc62ea9c51f39601eaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e9b1377cf4f95bd439e5411bbdb1d8" id="r_ae3e9b1377cf4f95bd439e5411bbdb1d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3e9b1377cf4f95bd439e5411bbdb1d8">cmd_stop</a> ()</td></tr>
<tr class="separator:ae3e9b1377cf4f95bd439e5411bbdb1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa4022b29ccf0046b1dae38e0dfe742" id="r_adfa4022b29ccf0046b1dae38e0dfe742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfa4022b29ccf0046b1dae38e0dfe742">cmd_stop_read_resp</a> ()</td></tr>
<tr class="separator:adfa4022b29ccf0046b1dae38e0dfe742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41084e3f3c160d67d70b755e7374884d" id="r_a41084e3f3c160d67d70b755e7374884d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41084e3f3c160d67d70b755e7374884d">write_bytes</a> (const uint8_t *data, size_t len)</td></tr>
<tr class="separator:a41084e3f3c160d67d70b755e7374884d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ca510584b1bb5cd20e548f971c4176" id="r_ad2ca510584b1bb5cd20e548f971c4176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2ca510584b1bb5cd20e548f971c4176">set_stop_tag</a> (const char *stop_tag_seq)</td></tr>
<tr class="separator:ad2ca510584b1bb5cd20e548f971c4176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087e820a5d7d8d8c879bd5b2e36524e3" id="r_a087e820a5d7d8d8c879bd5b2e36524e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a087e820a5d7d8d8c879bd5b2e36524e3">set_delimiter</a> (char delimiter)</td></tr>
<tr class="separator:a087e820a5d7d8d8c879bd5b2e36524e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2af39c64a8fa04234285242c0131557" id="r_ab2af39c64a8fa04234285242c0131557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2af39c64a8fa04234285242c0131557">set_default_delimiter</a> ()</td></tr>
<tr class="separator:ab2af39c64a8fa04234285242c0131557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ecfaf8304eadea7f803005d4b53c90" id="r_a05ecfaf8304eadea7f803005d4b53c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05ecfaf8304eadea7f803005d4b53c90">use_delimiter</a> (bool use_delimiter)</td></tr>
<tr class="separator:a05ecfaf8304eadea7f803005d4b53c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0afaff22b5d71c2cf809d62a3638425" id="r_ad0afaff22b5d71c2cf809d62a3638425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0afaff22b5d71c2cf809d62a3638425">skip_param</a> (uint32_t count=1)</td></tr>
<tr class="separator:ad0afaff22b5d71c2cf809d62a3638425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e9a10e5f4293dc5953ea94b7cb7b20" id="r_ad9e9a10e5f4293dc5953ea94b7cb7b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9e9a10e5f4293dc5953ea94b7cb7b20">skip_param</a> (ssize_t len, uint32_t count)</td></tr>
<tr class="separator:ad9e9a10e5f4293dc5953ea94b7cb7b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e962a902cb3482527f6a9d1b62f0f9" id="r_a04e962a902cb3482527f6a9d1b62f0f9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04e962a902cb3482527f6a9d1b62f0f9">read_bytes</a> (uint8_t *<a class="el" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, size_t len)</td></tr>
<tr class="separator:a04e962a902cb3482527f6a9d1b62f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c11340b1b4ae9f1021d8a89a04212d" id="r_a32c11340b1b4ae9f1021d8a89a04212d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32c11340b1b4ae9f1021d8a89a04212d">read_string</a> (char *str, size_t size, bool read_even_stop_tag=false)</td></tr>
<tr class="separator:a32c11340b1b4ae9f1021d8a89a04212d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4122a892f92868b62dd6a26b0f809dd6" id="r_a4122a892f92868b62dd6a26b0f809dd6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4122a892f92868b62dd6a26b0f809dd6">read_hex_string</a> (char *str, size_t size)</td></tr>
<tr class="separator:a4122a892f92868b62dd6a26b0f809dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9a10257585aa08578f1ffcc84c14e5" id="r_a1d9a10257585aa08578f1ffcc84c14e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d9a10257585aa08578f1ffcc84c14e5">write_hex_string</a> (const char *str, size_t size, bool quote_string=true)</td></tr>
<tr class="separator:a1d9a10257585aa08578f1ffcc84c14e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacda1e85ebf83ee2cbe2b9e250890e99" id="r_aacda1e85ebf83ee2cbe2b9e250890e99"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacda1e85ebf83ee2cbe2b9e250890e99">read_int</a> ()</td></tr>
<tr class="separator:aacda1e85ebf83ee2cbe2b9e250890e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9261ccc98a5d8a140c6cd305c17ddea" id="r_ae9261ccc98a5d8a140c6cd305c17ddea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9261ccc98a5d8a140c6cd305c17ddea">resp_start</a> (const char *prefix=NULL, bool stop=false)</td></tr>
<tr class="separator:ae9261ccc98a5d8a140c6cd305c17ddea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add18f5c6c8c17878d9b16ed75a5671f8" id="r_add18f5c6c8c17878d9b16ed75a5671f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add18f5c6c8c17878d9b16ed75a5671f8">resp_stop</a> ()</td></tr>
<tr class="separator:add18f5c6c8c17878d9b16ed75a5671f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac858ec4c10951dfaff749278f5f11969" id="r_ac858ec4c10951dfaff749278f5f11969"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac858ec4c10951dfaff749278f5f11969">info_resp</a> ()</td></tr>
<tr class="separator:ac858ec4c10951dfaff749278f5f11969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b313abd4aeb95201e908bb09b975c6" id="r_af2b313abd4aeb95201e908bb09b975c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2b313abd4aeb95201e908bb09b975c6">info_elem</a> (char start_tag)</td></tr>
<tr class="separator:af2b313abd4aeb95201e908bb09b975c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c3940b8c0bc0ff9f14b603cae61b72" id="r_ae0c3940b8c0bc0ff9f14b603cae61b72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0c3940b8c0bc0ff9f14b603cae61b72">consume_to_stop_tag</a> ()</td></tr>
<tr class="separator:ae0c3940b8c0bc0ff9f14b603cae61b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746689723d15953f6287b6b0ab206fdd" id="r_a746689723d15953f6287b6b0ab206fdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a746689723d15953f6287b6b0ab206fdd">get_3gpp_error</a> ()</td></tr>
<tr class="separator:a746689723d15953f6287b6b0ab206fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6da0bc63ece327f79d01c6ff262318e" id="r_ac6da0bc63ece327f79d01c6ff262318e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6da0bc63ece327f79d01c6ff262318e">set_debug</a> (bool debug_on)</td></tr>
<tr class="separator:ac6da0bc63ece327f79d01c6ff262318e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cabdc681e5bab6dbde08c17ba1658fb" id="r_a2cabdc681e5bab6dbde08c17ba1658fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cabdc681e5bab6dbde08c17ba1658fb">get_debug</a> () const</td></tr>
<tr class="separator:a2cabdc681e5bab6dbde08c17ba1658fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for sending AT commands and parsing AT responses. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8c148197b0cb7dc72bd00da120ec9f62" name="a8c148197b0cb7dc72bd00da120ec9f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c148197b0cb7dc72bd00da120ec9f62">&#9670;&#160;</a></span>ATHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATHandler::ATHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1FileHandle.html">FileHandle</a> *</td>          <td class="paramname"><span class="paramname"><em>fh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classevents_1_1EventQueue.html">events::EventQueue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>output_delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>send_delay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fh</td><td>file handle used for reading AT responses and writing AT commands </td></tr>
    <tr><td class="paramname">queue</td><td>Event queue used to transfer sigio events to this thread </td></tr>
    <tr><td class="paramname">timeout</td><td><a class="el" href="classmbed_1_1Timeout.html">Timeout</a> when reading for AT response </td></tr>
    <tr><td class="paramname">output_delimiter</td><td>delimiter used when parsing at responses, "\r" should be used as output_delimiter </td></tr>
    <tr><td class="paramname">send_delay</td><td>the minimum delay in ms between the end of last response and the beginning of a new command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2982bbff172c4b158c7ad679f32b4a5" name="ac2982bbff172c4b158c7ad679f32b4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2982bbff172c4b158c7ad679f32b4a5">&#9670;&#160;</a></span>ATHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATHandler::ATHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1FileHandle.html">FileHandle</a> *</td>          <td class="paramname"><span class="paramname"><em>fh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classevents_1_1EventQueue.html">events::EventQueue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mbed::chrono::milliseconds_u32</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>output_delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; uint16_t, std::milli &gt;</td>          <td class="paramname"><span class="paramname"><em>send_delay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::chrono::milliseconds(0)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fh</td><td>file handle used for reading AT responses and writing AT commands </td></tr>
    <tr><td class="paramname">queue</td><td>Event queue used to transfer sigio events to this thread </td></tr>
    <tr><td class="paramname">timeout</td><td><a class="el" href="classmbed_1_1Timeout.html">Timeout</a> when reading for AT response </td></tr>
    <tr><td class="paramname">output_delimiter</td><td>delimiter used when parsing at responses, "\r" should be used as output_delimiter </td></tr>
    <tr><td class="paramname">send_delay</td><td>the minimum delay in ms between the end of last response and the beginning of a new command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a95bf17e7ac99f8d1a776ac4cb19888" name="a6a95bf17e7ac99f8d1a776ac4cb19888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a95bf17e7ac99f8d1a776ac4cb19888">&#9670;&#160;</a></span>at_cmd_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> ATHandler::at_cmd_discard </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd_chr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>at_cmd_discard Send an AT command and read and discard a response. Locks and unlocks <a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for operation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command in form +&lt;CMD&gt; (will be used also in response reading, no extra chars allowed) </td></tr>
    <tr><td class="paramname">cmd_chr</td><td>Char to be added to specific AT command: '?', '=' or ''. Will be used as such so '=1' is valid as well. </td></tr>
    <tr><td class="paramname">format</td><td>Format string for variadic arguments to be added to AT command; No separator needed. Use d for integer, s for string and b for byte string (requires 2 arguments: string and length) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last error that happened when parsing AT responses </dd></dl>

</div>
</div>
<a id="a4faed5a066af88e5ac789e3bea1e5c5f" name="a4faed5a066af88e5ac789e3bea1e5c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faed5a066af88e5ac789e3bea1e5c5f">&#9670;&#160;</a></span>at_cmd_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> ATHandler::at_cmd_int </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd_chr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>resp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>at_cmd_int Send an AT command and read a single integer response. Locks and unlocks <a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for operation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command in form +&lt;CMD&gt; (will be used also in response reading, no extra chars allowed) </td></tr>
    <tr><td class="paramname">cmd_chr</td><td>Char to be added to specific AT command: '?', '=' or ''. Will be used as such so '=1' is valid as well. </td></tr>
    <tr><td class="paramname">resp</td><td>Integer to hold response </td></tr>
    <tr><td class="paramname">format</td><td>Format string for variadic arguments to be added to AT command; No separator needed. Use d for integer, s for string and b for byte string (requires 2 arguments: string and length) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last error that happened when parsing AT responses </dd></dl>

</div>
</div>
<a id="a4dce5418cdcc4f11242ee55dff8c402c" name="a4dce5418cdcc4f11242ee55dff8c402c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dce5418cdcc4f11242ee55dff8c402c">&#9670;&#160;</a></span>at_cmd_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> ATHandler::at_cmd_str </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd_chr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>resp_buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>resp_buf_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>at_cmd_str Send an AT command and read a single string response. Locks and unlocks <a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for operation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command in form +&lt;CMD&gt; (will be used also in response reading, no extra chars allowed) </td></tr>
    <tr><td class="paramname">cmd_chr</td><td>Char to be added to specific AT command: '?', '=' or ''. Will be used as such so '=1' is valid as well. </td></tr>
    <tr><td class="paramname">resp_buf</td><td>Response buffer </td></tr>
    <tr><td class="paramname">resp_buf_size</td><td>Response buffer size </td></tr>
    <tr><td class="paramname">format</td><td>Format string for variadic arguments to be added to AT command; No separator needed. Use d for integer, s for string and b for byte string (requires 2 arguments: string and length) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last error that happened when parsing AT responses </dd></dl>

</div>
</div>
<a id="a27c8618ddb52d66c3ec70dcb1d159ba0" name="a27c8618ddb52d66c3ec70dcb1d159ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c8618ddb52d66c3ec70dcb1d159ba0">&#9670;&#160;</a></span>clear_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::clear_error </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear pending error flag. By default, error is cleared only in <a class="el" href="#aa5e3d71b965e7fe431360cf172a63da9">lock()</a>. </p>

</div>
</div>
<a id="adacb5e971f20468c5c10c27183347184" name="adacb5e971f20468c5c10c27183347184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacb5e971f20468c5c10c27183347184">&#9670;&#160;</a></span>cmd_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::cmd_start </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the command writing by clearing the last error and writing the given command. In case of failure when writing, the last error is set to NSAPI_ERROR_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command to be written to modem </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c4b0589759c717b3301abf034f9b9f4" name="a8c4b0589759c717b3301abf034f9b9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4b0589759c717b3301abf034f9b9f4">&#9670;&#160;</a></span>cmd_start_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::cmd_start_stop </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd_chr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cmd_start_stop Starts an AT command, writes given variadic arguments and stops the command. Use this command when you need multiple response parameters to be handled. NOTE: Does not lock <a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for process! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command in form +&lt;CMD&gt; (will be used also in response reading, no extra chars allowed) </td></tr>
    <tr><td class="paramname">cmd_chr</td><td>Char to be added to specific AT command: '?', '=' or ''. Will be used as such so '=1' is valid as well. </td></tr>
    <tr><td class="paramname">format</td><td>Format string for variadic arguments to be added to AT command; No separator needed. Use d for integer, s for string and b for byte string (requires 2 arguments: string and length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3e9b1377cf4f95bd439e5411bbdb1d8" name="ae3e9b1377cf4f95bd439e5411bbdb1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e9b1377cf4f95bd439e5411bbdb1d8">&#9670;&#160;</a></span>cmd_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::cmd_stop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the AT command by writing command-line terminator CR to mark command as finished. </p>

</div>
</div>
<a id="adfa4022b29ccf0046b1dae38e0dfe742" name="adfa4022b29ccf0046b1dae38e0dfe742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa4022b29ccf0046b1dae38e0dfe742">&#9670;&#160;</a></span>cmd_stop_read_resp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::cmd_stop_read_resp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the AT command by writing command-line terminator CR to mark command as finished and reads the OK/ERROR response. </p>

</div>
</div>
<a id="ae0c3940b8c0bc0ff9f14b603cae61b72" name="ae0c3940b8c0bc0ff9f14b603cae61b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c3940b8c0bc0ff9f14b603cae61b72">&#9670;&#160;</a></span>consume_to_stop_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ATHandler::consume_to_stop_tag </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes the received content until current stop tag is found.</p>
<dl class="section return"><dt>Returns</dt><dd>true if stop tag is found, false otherwise </dd></dl>

</div>
</div>
<a id="a456bf36984af76a0df90543c2c05febe" name="a456bf36984af76a0df90543c2c05febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456bf36984af76a0df90543c2c05febe">&#9670;&#160;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::flush </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes the underlying stream </p>

</div>
</div>
<a id="a746689723d15953f6287b6b0ab206fdd" name="a746689723d15953f6287b6b0ab206fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746689723d15953f6287b6b0ab206fdd">&#9670;&#160;</a></span>get_3gpp_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ATHandler::get_3gpp_error </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last 3GPP error code. </p><dl class="section return"><dt>Returns</dt><dd>last 3GPP error code </dd></dl>

</div>
</div>
<a id="a2cabdc681e5bab6dbde08c17ba1658fb" name="a2cabdc681e5bab6dbde08c17ba1658fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cabdc681e5bab6dbde08c17ba1658fb">&#9670;&#160;</a></span>get_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ATHandler::get_debug </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get degug state set by <a class="el" href="#ac6da0bc63ece327f79d01c6ff262318e">set_debug</a></p>
<dl class="section return"><dt>Returns</dt><dd>current state of debug </dd></dl>

</div>
</div>
<a id="a2afe038fc1b18b91029a97ae14c73b9c" name="a2afe038fc1b18b91029a97ae14c73b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afe038fc1b18b91029a97ae14c73b9c">&#9670;&#160;</a></span>get_file_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1FileHandle.html">FileHandle</a> * ATHandler::get_file_handle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return used file handle.</p>
<dl class="section return"><dt>Returns</dt><dd>used file handle </dd></dl>

</div>
</div>
<a id="a4d6c9d9e4b7b07176287dd28a8ea3032" name="a4d6c9d9e4b7b07176287dd28a8ea3032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6c9d9e4b7b07176287dd28a8ea3032">&#9670;&#160;</a></span>get_last_device_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbed_1_1device__err__t.html">device_err_t</a> ATHandler::get_last_device_error </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the last device error while parsing AT responses. Actually AT error (CME/CMS).</p>
<dl class="section return"><dt>Returns</dt><dd>last error struct <a class="el" href="structmbed_1_1device__err__t.html">device_err_t</a> </dd></dl>

</div>
</div>
<a id="a16a1610dca6a2b9357574b9906b5e6eb" name="a16a1610dca6a2b9357574b9906b5e6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a1610dca6a2b9357574b9906b5e6eb">&#9670;&#160;</a></span>get_last_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> ATHandler::get_last_error </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the last error while parsing AT responses.</p>
<dl class="section return"><dt>Returns</dt><dd>last error </dd></dl>

</div>
</div>
<a id="af2b313abd4aeb95201e908bb09b975c6" name="af2b313abd4aeb95201e908bb09b975c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b313abd4aeb95201e908bb09b975c6">&#9670;&#160;</a></span>info_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ATHandler::info_elem </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>start_tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for matching the start tag. If needed, it ends the scope of a previous element. Sets the element scope if start tag is found and information response scope if start tag is not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_tag</td><td>tag to be matched to begin parsing an element of an information response </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if new element is found, false otherwise </dd></dl>

</div>
</div>
<a id="ac858ec4c10951dfaff749278f5f11969" name="ac858ec4c10951dfaff749278f5f11969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac858ec4c10951dfaff749278f5f11969">&#9670;&#160;</a></span>info_resp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ATHandler::info_resp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for matching the prefix given to <a class="el" href="#ae9261ccc98a5d8a140c6cd305c17ddea">resp_start()</a> call. If needed, it ends the scope of a previous information response. Sets the information response scope if new prefix is found and response scope if prefix is not found.</p>
<dl class="section return"><dt>Returns</dt><dd>true if prefix defined for information response is not empty string and is found, false otherwise. </dd></dl>

</div>
</div>
<a id="aa5e3d71b965e7fe431360cf172a63da9" name="aa5e3d71b965e7fe431360cf172a63da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e3d71b965e7fe431360cf172a63da9">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the mutex for file handle if AT_HANDLER_MUTEX is defined. </p>

</div>
</div>
<a id="a4b210bf525133329e75dd2ae75460002" name="a4b210bf525133329e75dd2ae75460002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b210bf525133329e75dd2ae75460002">&#9670;&#160;</a></span>process_oob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::process_oob </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to find oob's from the AT response. Call the urc callback if one is found. </p>

</div>
</div>
<a id="a04e962a902cb3482527f6a9d1b62f0f9" name="a04e962a902cb3482527f6a9d1b62f0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e962a902cb3482527f6a9d1b62f0f9">&#9670;&#160;</a></span>read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ATHandler::read_bytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads given number of bytes from receiving buffer without checking any subparameter delimiters, such as comma.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer for the read </td></tr>
    <tr><td class="paramname">len</td><td>maximum number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of successfully read bytes or -1 in case of error </dd></dl>

</div>
</div>
<a id="a4122a892f92868b62dd6a26b0f809dd6" name="a4122a892f92868b62dd6a26b0f809dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4122a892f92868b62dd6a26b0f809dd6">&#9670;&#160;</a></span>read_hex_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ATHandler::read_hex_string </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads chars representing hex ascii values and converts them to the corresponding chars. For example: "4156" to "AV". Terminates with null. Skips the quotation marks. Stops on delimiter or stop tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>output buffer for the read </td></tr>
    <tr><td class="paramname">size</td><td>maximum number of chars to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of output string or -1 in case of read timeout before delimiter or stop tag is found </dd></dl>

</div>
</div>
<a id="aacda1e85ebf83ee2cbe2b9e250890e99" name="aacda1e85ebf83ee2cbe2b9e250890e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacda1e85ebf83ee2cbe2b9e250890e99">&#9670;&#160;</a></span>read_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ATHandler::read_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads as string and converts result to integer. Supports only non-negative integers.</p>
<dl class="section return"><dt>Returns</dt><dd>the non-negative integer or -1 in case of error. </dd></dl>

</div>
</div>
<a id="a32c11340b1b4ae9f1021d8a89a04212d" name="a32c11340b1b4ae9f1021d8a89a04212d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c11340b1b4ae9f1021d8a89a04212d">&#9670;&#160;</a></span>read_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ATHandler::read_string </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>read_even_stop_tag</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads chars from reading buffer. Terminates with null. Skips the quotation marks. Stops on delimiter or stop tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>output buffer for the read </td></tr>
    <tr><td class="paramname">size</td><td>maximum number of chars to output including NULL </td></tr>
    <tr><td class="paramname">read_even_stop_tag</td><td>if true then try to read even if the stop tag was found previously </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of output string or -1 in case of read timeout before delimiter or stop tag is found </dd></dl>

</div>
</div>
<a id="ae9261ccc98a5d8a140c6cd305c17ddea" name="ae9261ccc98a5d8a140c6cd305c17ddea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9261ccc98a5d8a140c6cd305c17ddea">&#9670;&#160;</a></span>resp_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::resp_start </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>stop</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This looks for necessary matches: prefix, OK, ERROR, URCs and sets the correct scope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>string to be matched from receiving buffer. If not NULL and match succeeds, then scope will be set as information response(info_type) </td></tr>
    <tr><td class="paramname">stop</td><td>flag to indicate if we go to information response scope or not. (needed when nothing is expected to be received anymore after the prefix match: sms case: "&gt; ", bc95 reboot case) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add18f5c6c8c17878d9b16ed75a5671f8" name="add18f5c6c8c17878d9b16ed75a5671f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add18f5c6c8c17878d9b16ed75a5671f8">&#9670;&#160;</a></span>resp_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::resp_stop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ends all scopes starting from current scope. Consumes everything until the scope's stop tag is found, then goes to next scope until response scope is ending. URC match is checked during response scope ending, for every new line / CRLF.</p>
<p>Possible sequence: element scope -&gt; information response scope -&gt; response scope </p>

</div>
</div>
<a id="a7ffc1b0a03b6ce02ea578ef81f32e089" name="a7ffc1b0a03b6ce02ea578ef81f32e089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffc1b0a03b6ce02ea578ef81f32e089">&#9670;&#160;</a></span>restore_at_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::restore_at_timeout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restore timeout to previous timeout. Handy if there is a need to change timeout temporarily. </p>

</div>
</div>
<a id="a0fd569e771ba365002bd4b9facc72ef0" name="a0fd569e771ba365002bd4b9facc72ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd569e771ba365002bd4b9facc72ef0">&#9670;&#160;</a></span>set_at_timeout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_at_timeout </td>
          <td>(</td>
          <td class="paramtype">mbed::chrono::milliseconds_u32</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>default_timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set timeout in milliseconds for AT commands</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td><a class="el" href="classmbed_1_1Timeout.html">Timeout</a> in milliseconds </td></tr>
    <tr><td class="paramname">default_timeout</td><td>Store as default timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c6929b0aad444f1b9a5b60a01217c69" name="a4c6929b0aad444f1b9a5b60a01217c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6929b0aad444f1b9a5b60a01217c69">&#9670;&#160;</a></span>set_at_timeout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_at_timeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_milliseconds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>default_timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set timeout in milliseconds for AT commands</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_milliseconds</td><td><a class="el" href="classmbed_1_1Timeout.html">Timeout</a> in milliseconds </td></tr>
    <tr><td class="paramname">default_timeout</td><td>Store as default timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1349a00da5592ee3a58797297f06c406" name="a1349a00da5592ee3a58797297f06c406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1349a00da5592ee3a58797297f06c406">&#9670;&#160;</a></span>set_baud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_baud </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>baud_rate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets BufferedSerial filehandle to given baud rate</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baud_rate</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6da0bc63ece327f79d01c6ff262318e" name="ac6da0bc63ece327f79d01c6ff262318e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6da0bc63ece327f79d01c6ff262318e">&#9670;&#160;</a></span>set_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_debug </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>debug_on</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AT debugging, when enabled will print all data read and written, non-printable chars are printed as "[%d]".</p>
<p>AT debug can be enabled at compile time using MBED_CONF_CELLULAR_DEBUG_AT flag or at runtime calling <a class="el" href="#ac6da0bc63ece327f79d01c6ff262318e">set_debug()</a>. Note that MBED_CONF_MBED_TRACE_ENABLE must also be enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debug_on</td><td>Enable/disable debugging </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2af39c64a8fa04234285242c0131557" name="ab2af39c64a8fa04234285242c0131557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2af39c64a8fa04234285242c0131557">&#9670;&#160;</a></span>set_default_delimiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_default_delimiter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the delimiter to default value defined by DEFAULT_DELIMITER. </p>

</div>
</div>
<a id="a087e820a5d7d8d8c879bd5b2e36524e3" name="a087e820a5d7d8d8c879bd5b2e36524e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087e820a5d7d8d8c879bd5b2e36524e3">&#9670;&#160;</a></span>set_delimiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_delimiter </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the delimiter between parameters or between elements of the information response. Parameter's reading routines will stop when such char is read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>char to be set as _delimiter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef0fb0d267d0c88c8b72d15138c8d5b7" name="aef0fb0d267d0c88c8b72d15138c8d5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0fb0d267d0c88c8b72d15138c8d5b7">&#9670;&#160;</a></span>set_is_filehandle_usable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_is_filehandle_usable </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>usable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set is file handle usable. Some situations like after going to data mode, file handle is not usable anymore. Any items in queue are not to be processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usable</td><td>true for usable filehandle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ab3c27df8512fbac73febfbc3fda65" name="a45ab3c27df8512fbac73febfbc3fda65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ab3c27df8512fbac73febfbc3fda65">&#9670;&#160;</a></span>set_send_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_send_delay </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>send_delay</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the delay to be applied before sending any AT command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_delay</td><td>the minimum delay in ms between the end of last response and the beginning of a new command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2ca510584b1bb5cd20e548f971c4176" name="ad2ca510584b1bb5cd20e548f971c4176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ca510584b1bb5cd20e548f971c4176">&#9670;&#160;</a></span>set_stop_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_stop_tag </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>stop_tag_seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the stop tag for the current scope (response/information response/element) Parameter's reading routines will stop the reading when such tag is found and will set the found flag. Consume routines will read everything until such tag is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tag_seq</td><td>string to be set as stop tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad040a55dcf9137cebbe4ff2e21e1c4f3" name="ad040a55dcf9137cebbe4ff2e21e1c4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad040a55dcf9137cebbe4ff2e21e1c4f3">&#9670;&#160;</a></span>set_urc_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::set_urc_handler </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1Callback.html">mbed::Callback</a>&lt; void()&gt;</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set callback function for URC</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>URC text to look for, e.g. "+CMTI:". Maximum length is MBED_CONF_CELLULAR_AT_HANDLER_BUFFER_SIZE. </td></tr>
    <tr><td class="paramname">callback</td><td>function to call on prefix, or 0 to remove callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9e9a10e5f4293dc5953ea94b7cb7b20" name="ad9e9a10e5f4293dc5953ea94b7cb7b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e9a10e5f4293dc5953ea94b7cb7b20">&#9670;&#160;</a></span>skip_param() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::skip_param </td>
          <td>(</td>
          <td class="paramtype">ssize_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes the given length from the reading buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>length to be consumed from reading buffer </td></tr>
    <tr><td class="paramname">count</td><td>number of parameters to be skipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0afaff22b5d71c2cf809d62a3638425" name="ad0afaff22b5d71c2cf809d62a3638425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0afaff22b5d71c2cf809d62a3638425">&#9670;&#160;</a></span>skip_param() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::skip_param </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes the reading buffer up to the delimiter or stop_tag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of parameters to be skipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94407adf7676fab46c1440a58d82b7b7" name="a94407adf7676fab46c1440a58d82b7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94407adf7676fab46c1440a58d82b7b7">&#9670;&#160;</a></span>sync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ATHandler::sync </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize AT command and response handling to modem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td><a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> timeout when trying to sync. Will be restored when function returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is synchronization was successful, false in case of failure </dd></dl>

</div>
</div>
<a id="a20eb18a84839f50ffc83df81532d0215" name="a20eb18a84839f50ffc83df81532d0215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20eb18a84839f50ffc83df81532d0215">&#9670;&#160;</a></span>sync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ATHandler::sync </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; int, std::milli &gt;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize AT command and response handling to modem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td><a class="el" href="classmbed_1_1ATHandler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> timeout when trying to sync. Will be restored when function returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is synchronization was successful, false in case of failure </dd></dl>

</div>
</div>
<a id="a044783bc022a795751250e180ed87b4b" name="a044783bc022a795751250e180ed87b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044783bc022a795751250e180ed87b4b">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::unlock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks the mutex for file handle if AT_HANDLER_MUTEX is defined. </p>

</div>
</div>
<a id="adf2ab7afb2165ff68510480c0d3e6e22" name="adf2ab7afb2165ff68510480c0d3e6e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2ab7afb2165ff68510480c0d3e6e22">&#9670;&#160;</a></span>unlock_return_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__netsocket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> ATHandler::unlock_return_error </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the mutex for file handle if AT_HANDLER_MUTEX is defined and returns the last error.</p>
<dl class="section return"><dt>Returns</dt><dd>last error that happened when parsing AT responses </dd></dl>

</div>
</div>
<a id="a05ecfaf8304eadea7f803005d4b53c90" name="a05ecfaf8304eadea7f803005d4b53c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ecfaf8304eadea7f803005d4b53c90">&#9670;&#160;</a></span>use_delimiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::use_delimiter </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_delimiter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines behaviour for using or ignoring the delimiter within an AT command</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_delimiter</td><td>indicating if delimiter should be used or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41084e3f3c160d67d70b755e7374884d" name="a41084e3f3c160d67d70b755e7374884d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41084e3f3c160d67d70b755e7374884d">&#9670;&#160;</a></span>write_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ATHandler::write_bytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write bytes without any subparameter delimiters, such as comma. In case of failure when writing, the last error is set to NSAPI_ERROR_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>bytes to be written to modem </td></tr>
    <tr><td class="paramname">len</td><td>length of data string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters successfully written </dd></dl>

</div>
</div>
<a id="a1d9a10257585aa08578f1ffcc84c14e5" name="a1d9a10257585aa08578f1ffcc84c14e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9a10257585aa08578f1ffcc84c14e5">&#9670;&#160;</a></span>write_hex_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::write_hex_string </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>quote_string</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts contained chars to their hex ascii value and writes the resulting string to the file handle For example: "AV" to "4156".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input buffer to be converted to hex ascii </td></tr>
    <tr><td class="paramname">size</td><td>of the input param str </td></tr>
    <tr><td class="paramname">quote_string</td><td>if true it will add the double-quote character at beginning and end of string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada30ce5e77da89590f6f266f0cfe3c2e" name="ada30ce5e77da89590f6f266f0cfe3c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada30ce5e77da89590f6f266f0cfe3c2e">&#9670;&#160;</a></span>write_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::write_int </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes integer type AT command subparameter. Starts with the delimiter if not the first param after cmd_start. In case of failure when writing, the last error is set to NSAPI_ERROR_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>int to be written to modem as AT command subparameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4db6044f5f2ddc62ea9c51f39601eaaa" name="a4db6044f5f2ddc62ea9c51f39601eaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db6044f5f2ddc62ea9c51f39601eaaa">&#9670;&#160;</a></span>write_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ATHandler::write_string </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useQuotations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes string type AT command subparamater. Quotes are added to surround the given string. Starts with the delimiter if not the first param after cmd_start. In case of failure when writing, the last error is set to NSAPI_ERROR_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>string to be written to modem as AT command subparameter </td></tr>
    <tr><td class="paramname">useQuotations</td><td>flag indicating whether the string should be included in quotation marks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/cellular/include/cellular/framework/API/<a class="el" href="ATHandler_8h_source.html">ATHandler.h</a></li>
<li>/home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/cellular/source/framework/device/<b>ATHandler.cpp</b></li>
<li>/home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/cellular/tests/UNITTESTS/doubles/<b>ATHandler_stub.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mbed</b></li><li class="navelem"><a class="el" href="classmbed_1_1ATHandler.html">ATHandler</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
