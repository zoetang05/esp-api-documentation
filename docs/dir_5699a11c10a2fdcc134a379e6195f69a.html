<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: /home/zoe/Mbed Programs/esp_code/mbed-os/features/frameworks/utest Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_5699a11c10a2fdcc134a379e6195f69a.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">utest Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_b963f4ce05a3e02df75a0462bf3d2937.html">source</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_5d0f3f0706ce921b033e8a49e16a520d.html">utest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This test harness allows you to execute a specified series of (asynchronous) C++ test cases with sensible default reporting and useful customization options.</p>
<p>Please note that this is a purposefully lean test harness, only dealing with test execution and providing default reporting handlers. It specifically does not support auto-discovery of test cases and does not provide you with test macros or other convenience functions. Instead, the macros in the <a href="https://github.com/ARMmbed/mbed-os/tree/master/features/frameworks/unity">unity module</a> can be used for this purpose. However, you are not required to use these, and can use your own macros if you wish.</p>
<p>Furthermore, test failure recovery through the use of exceptions or <code>longjmp</code> is not supported; the test will either continue and ignore failures or die by busy-waiting.</p>
<h1><a class="anchor" id="autotoc_md715"></a>
Theory of Operation</h1>
<p>A test specification contains a setup handler, several test cases and a teardown handler. Each test case contains a textual description, setup, teardown and failure handler as well as the actual test handler.</p>
<p>The order of handler execution is:</p>
<ol type="1">
<li><a class="el" href="classTest.html">Test</a> setup handler.</li>
</ol>
<ol type="1">
<li>For each test case:<ol type="a">
<li><a class="el" href="classTest.html">Test</a> case setup handler.</li>
</ol>
<ol type="a">
<li><a class="el" href="classTest.html">Test</a> case execution handler.</li>
</ol>
<ol type="a">
<li>(wait for timeout or callback validation in case of an asynchronous test case.)</li>
</ol>
<ol type="a">
<li>(repeat test case execution handler if specified.)</li>
</ol>
<ol type="a">
<li><a class="el" href="classTest.html">Test</a> case teardown handler.</li>
</ol>
</li>
</ol>
<ol type="1">
<li><a class="el" href="classTest.html">Test</a> teardown handler.</li>
</ol>
<h1><a class="anchor" id="autotoc_md716"></a>
Example</h1>
<p>The following example showcases a lot of functionality and proper integration with the <a href="https://github.com/ARMmbed/mbed-os-tools/tree/master/packages/mbed-greentea">Greentea test tool</a>, while making use of the <a href="https://github.com/ARMmbed/mbed-os/tree/master/features/frameworks/unity">unity test macros</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;greentea-client/test_env.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;utest/utest.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;unity/unity.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>utest::v1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> test_simple() {</div>
<div class="line">    TEST_ASSERT_EQUAL(0, 0);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Simple test called\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_enumeration" href="group__frameworks.html#gadac4eb876b0749ceaf64bc1c7b59f631">status_t</a> test_repeats_setup(<span class="keyword">const</span> <a class="code hl_class" href="classCase.html">Case</a> *<span class="keyword">const</span> source, <span class="keyword">const</span> <span class="keywordtype">size_t</span> index_of_case) {</div>
<div class="line">    <span class="comment">// Call the default handler for proper reporting</span></div>
<div class="line">    <a class="code hl_enumeration" href="group__frameworks.html#gadac4eb876b0749ceaf64bc1c7b59f631">status_t</a> status = <a class="code hl_function" href="group__frameworks.html#ga5c78197c262250e697cd0eafc11fe500">greentea_case_setup_handler</a>(source, index_of_case);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Setting up for &#39;%s&#39;\n&quot;</span>, source-&gt;<a class="code hl_function" href="group__frameworks.html#ga00ac4c37ad74fff55863659412aca3d4">get_description</a>());</div>
<div class="line">    <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structutest_1_1v1_1_1control__t.html">control_t</a> test_repeats(<span class="keyword">const</span> <span class="keywordtype">size_t</span> call_count) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Called for the %u. time\n&quot;</span>, call_count);</div>
<div class="line">    TEST_ASSERT_NOT_EQUAL(3, call_count);</div>
<div class="line">    <span class="comment">// Specify how often this test is repeated ie. n total calls</span></div>
<div class="line">    <span class="keywordflow">return</span> (call_count &lt; 2) ? <a class="code hl_variable" href="group__frameworks.html#gab420ffbae93279d33867bd4f45b55841">CaseRepeatAll</a> : <a class="code hl_variable" href="group__frameworks.html#gaa356b32daf0b692cb4797df6e06a877b">CaseNext</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> test_callback_validate() {</div>
<div class="line">    <span class="comment">// You may also use assertions here!</span></div>
<div class="line">    TEST_ASSERT_EQUAL_PTR(0, 0);</div>
<div class="line">    <span class="comment">// Validate the callback</span></div>
<div class="line">    <a class="code hl_function" href="group__frameworks.html#ga512cf682045733f4a3d7d6056cbc6709">Harness::validate_callback</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structutest_1_1v1_1_1control__t.html">control_t</a> test_asynchronous() {</div>
<div class="line">    TEST_ASSERT_TRUE_MESSAGE(<span class="keyword">true</span>, <span class="stringliteral">&quot;(true == false) o_O&quot;</span>);</div>
<div class="line">    <span class="comment">// Set up a callback in the future. This may also be an interrupt!</span></div>
<div class="line">    EventQueue *queue = mbed_event_queue();</div>
<div class="line">    queue-&gt;call_in(100, test_callback_validate);</div>
<div class="line">    <span class="comment">// Set a 200ms timeout starting from now</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="group__frameworks.html#ga78304d81eb3b0532e0882d64e9fb1498">CaseTimeout</a>(200);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structutest_1_1v1_1_1control__t.html">control_t</a> test_asynchronous_timeout(<span class="keyword">const</span> <span class="keywordtype">size_t</span> call_count) {</div>
<div class="line">    TEST_ASSERT_TRUE_MESSAGE(<span class="keyword">true</span>, <span class="stringliteral">&quot;(true == false) o_O&quot;</span>);</div>
<div class="line">    <span class="comment">// Set a 200ms timeout starting from now,</span></div>
<div class="line">    <span class="comment">// but automatically repeat only this handler on timeout.</span></div>
<div class="line">    <span class="keywordflow">if</span> (call_count &gt;= 5) {</div>
<div class="line">        <span class="comment">// but after the 5th call, the callback finally gets validated</span></div>
<div class="line">        EventQueue *queue = <a class="code hl_function" href="group__events-public-api.html#ga5c682c869d471092af6733e59d4103a2">mbed_event_queue</a>();</div>
<div class="line">        queue-&gt;call_in(100, test_callback_validate);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="group__frameworks.html#ga5e9eb1f5ca73db71cbfbbcc58b8149a3">CaseRepeatHandlerOnTimeout</a>(200);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom setup handler required for proper Greentea support</span></div>
<div class="line"><a class="code hl_enumeration" href="group__frameworks.html#gadac4eb876b0749ceaf64bc1c7b59f631">status_t</a> greentea_setup(<span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_cases) {</div>
<div class="line">    <a class="code hl_function" href="group__frameworks.html#ga24b3a20448267bd1eabe3ef72582db1b">GREENTEA_SETUP</a>(20, <span class="stringliteral">&quot;default_auto&quot;</span>);</div>
<div class="line">    <span class="comment">// Call the default reporting function</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="group__frameworks.html#gac048b76c8768f9f9b5f0fd695f5486db">greentea_test_setup_handler</a>(number_of_cases);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Specify all your test cases here</span></div>
<div class="line"><a class="code hl_class" href="classCase.html">Case</a> cases[] = {</div>
<div class="line">    <a class="code hl_class" href="classCase.html">Case</a>(<span class="stringliteral">&quot;Simple Test&quot;</span>, test_simple),</div>
<div class="line">    <a class="code hl_class" href="classCase.html">Case</a>(<span class="stringliteral">&quot;Repeating Test&quot;</span>, test_repeats_setup, test_repeats),</div>
<div class="line">    <a class="code hl_class" href="classCase.html">Case</a>(<span class="stringliteral">&quot;Asynchronous Test (200ms timeout)&quot;</span>, test_asynchronous),</div>
<div class="line">    <a class="code hl_class" href="classCase.html">Case</a>(<span class="stringliteral">&quot;Asynchronous Timeout Repeat&quot;</span>, test_asynchronous_timeout)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Declare your test specification with a custom setup handler</span></div>
<div class="line"><a class="code hl_class" href="classutest_1_1v1_1_1Specification.html">Specification</a> specification(greentea_setup, cases);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{   <span class="comment">// Run the test specification</span></div>
<div class="line">    <a class="code hl_function" href="group__frameworks.html#gab3dbd973627ecb1691bc73c7ec43b5f9">Harness::run</a>(specification);</div>
<div class="line">}</div>
<div class="ttc" id="aclassCase_html"><div class="ttname"><a href="classCase.html">Case</a></div><div class="ttdef"><b>Definition</b> utest_case.h:109</div></div>
<div class="ttc" id="aclassutest_1_1v1_1_1Specification_html"><div class="ttname"><a href="classutest_1_1v1_1_1Specification.html">utest::v1::Specification</a></div><div class="ttdef"><b>Definition</b> utest_specification.h:49</div></div>
<div class="ttc" id="agroup__events-public-api_html_ga5c682c869d471092af6733e59d4103a2"><div class="ttname"><a href="group__events-public-api.html#ga5c682c869d471092af6733e59d4103a2">mbed::mbed_event_queue</a></div><div class="ttdeci">events::EventQueue * mbed_event_queue()</div><div class="ttdef"><b>Definition</b> mbed_shared_queues.cpp:57</div></div>
<div class="ttc" id="agroup__frameworks_html_ga00ac4c37ad74fff55863659412aca3d4"><div class="ttname"><a href="group__frameworks.html#ga00ac4c37ad74fff55863659412aca3d4">Case::get_description</a></div><div class="ttdeci">const char * get_description() const</div><div class="ttdef"><b>Definition</b> utest_case.cpp:188</div></div>
<div class="ttc" id="agroup__frameworks_html_ga24b3a20448267bd1eabe3ef72582db1b"><div class="ttname"><a href="group__frameworks.html#ga24b3a20448267bd1eabe3ef72582db1b">GREENTEA_SETUP</a></div><div class="ttdeci">void GREENTEA_SETUP(const int timeout, const char *host_test)</div><div class="ttdoc">Handshake with host and send setup data (timeout and host test name)</div><div class="ttdef"><b>Definition</b> greentea_test_env.cpp:99</div></div>
<div class="ttc" id="agroup__frameworks_html_ga512cf682045733f4a3d7d6056cbc6709"><div class="ttname"><a href="group__frameworks.html#ga512cf682045733f4a3d7d6056cbc6709">utest::v1::Harness::validate_callback</a></div><div class="ttdeci">static void validate_callback(const control_t control=control_t())</div><div class="ttdef"><b>Definition</b> utest_harness.cpp:267</div></div>
<div class="ttc" id="agroup__frameworks_html_ga5c78197c262250e697cd0eafc11fe500"><div class="ttname"><a href="group__frameworks.html#ga5c78197c262250e697cd0eafc11fe500">utest::v1::greentea_case_setup_handler</a></div><div class="ttdeci">utest::v1::status_t greentea_case_setup_handler(const Case *const source, const size_t index_of_case)</div><div class="ttdoc">Registers the test case setup with greentea.</div><div class="ttdef"><b>Definition</b> utest_greentea_handlers.cpp:121</div></div>
<div class="ttc" id="agroup__frameworks_html_ga5e9eb1f5ca73db71cbfbbcc58b8149a3"><div class="ttname"><a href="group__frameworks.html#ga5e9eb1f5ca73db71cbfbbcc58b8149a3">utest::v1::CaseRepeatHandlerOnTimeout</a></div><div class="ttdeci">control_t CaseRepeatHandlerOnTimeout(uint32_t ms)</div><div class="ttdef"><b>Definition</b> utest_types.h:272</div></div>
<div class="ttc" id="agroup__frameworks_html_ga78304d81eb3b0532e0882d64e9fb1498"><div class="ttname"><a href="group__frameworks.html#ga78304d81eb3b0532e0882d64e9fb1498">utest::v1::CaseTimeout</a></div><div class="ttdeci">control_t CaseTimeout(uint32_t ms)</div><div class="ttdoc">Alias class for asynchronous timeout control in milliseconds.</div><div class="ttdef"><b>Definition</b> utest_types.h:265</div></div>
<div class="ttc" id="agroup__frameworks_html_gaa356b32daf0b692cb4797df6e06a877b"><div class="ttname"><a href="group__frameworks.html#gaa356b32daf0b692cb4797df6e06a877b">utest::v1::CaseNext</a></div><div class="ttdeci">const base_control_t CaseNext</div><div class="ttdoc">does not repeat this test case and immediately moves on to the next one without timeout</div><div class="ttdef"><b>Definition</b> utest_types.cpp:119</div></div>
<div class="ttc" id="agroup__frameworks_html_gab3dbd973627ecb1691bc73c7ec43b5f9"><div class="ttname"><a href="group__frameworks.html#gab3dbd973627ecb1691bc73c7ec43b5f9">utest::v1::Harness::run</a></div><div class="ttdeci">static bool run(const Specification &amp;specification)</div><div class="ttdef"><b>Definition</b> utest_harness.cpp:92</div></div>
<div class="ttc" id="agroup__frameworks_html_gab420ffbae93279d33867bd4f45b55841"><div class="ttname"><a href="group__frameworks.html#gab420ffbae93279d33867bd4f45b55841">utest::v1::CaseRepeatAll</a></div><div class="ttdeci">const base_control_t CaseRepeatAll</div><div class="ttdoc">repeats the test case handler with calling teardown and setup handlers</div><div class="ttdef"><b>Definition</b> utest_types.cpp:123</div></div>
<div class="ttc" id="agroup__frameworks_html_gac048b76c8768f9f9b5f0fd695f5486db"><div class="ttname"><a href="group__frameworks.html#gac048b76c8768f9f9b5f0fd695f5486db">utest::v1::greentea_test_setup_handler</a></div><div class="ttdeci">utest::v1::status_t greentea_test_setup_handler(const size_t number_of_cases)</div><div class="ttdef"><b>Definition</b> utest_greentea_handlers.cpp:98</div></div>
<div class="ttc" id="agroup__frameworks_html_gadac4eb876b0749ceaf64bc1c7b59f631"><div class="ttname"><a href="group__frameworks.html#gadac4eb876b0749ceaf64bc1c7b59f631">utest::v1::status_t</a></div><div class="ttdeci">status_t</div><div class="ttdoc">status_t</div><div class="ttdef"><b>Definition</b> utest_types.h:52</div></div>
<div class="ttc" id="astructutest_1_1v1_1_1control__t_html"><div class="ttname"><a href="structutest_1_1v1_1_1control__t.html">utest::v1::control_t</a></div><div class="ttdef"><b>Definition</b> utest_types.h:175</div></div>
</div><!-- fragment --><p>Running this test will output the following:</p>
<div class="fragment"><div class="line">{{timeout;20}}</div>
<div class="line">{{host_test_name;default_auto}}</div>
<div class="line">{{description;utest greentea example}}</div>
<div class="line">{{test_id;MBED_OS}}</div>
<div class="line">{{start}}</div>
<div class="line">&gt;&gt;&gt; Running 4 test cases...</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; Running case #1: &#39;Simple Test&#39;...</div>
<div class="line">Simple test called</div>
<div class="line">&gt;&gt;&gt; &#39;Simple Test&#39;: 1 passed, 0 failed</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; Running case #2: &#39;Repeating Test&#39;...</div>
<div class="line">Setting up for &#39;Repeating Test&#39;</div>
<div class="line">Called for the 1. time</div>
<div class="line">&gt;&gt;&gt; &#39;Repeating Test&#39;: 1 passed, 0 failed</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; Running case #2: &#39;Repeating Test&#39;...</div>
<div class="line">Setting up for &#39;Repeating Test&#39;</div>
<div class="line">Called for the 2. time</div>
<div class="line">&gt;&gt;&gt; &#39;Repeating Test&#39;: 2 passed, 0 failed</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; Running case #3: &#39;Asynchronous Test (200ms timeout)&#39;...</div>
<div class="line">&gt;&gt;&gt; &#39;Asynchronous Test (200ms timeout)&#39;: 1 passed, 0 failed</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; Running case #4: &#39;Asynchronous Timeout Repeat&#39;...</div>
<div class="line">&gt;&gt;&gt; failure with reason &#39;Ignored: Timed Out&#39;</div>
<div class="line">&gt;&gt;&gt; failure with reason &#39;Ignored: Timed Out&#39;</div>
<div class="line">&gt;&gt;&gt; failure with reason &#39;Ignored: Timed Out&#39;</div>
<div class="line">&gt;&gt;&gt; failure with reason &#39;Ignored: Timed Out&#39;</div>
<div class="line">&gt;&gt;&gt; failure with reason &#39;Ignored: Timed Out&#39;</div>
<div class="line">&gt;&gt;&gt; &#39;Asynchronous Timeout Repeat&#39;: 1 passed, 0 failed</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; Test cases: 4 passed, 0 failed</div>
<div class="line">{{success}}</div>
<div class="line">{{end}}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md717"></a>
Detailed Description</h1>
<h2><a class="anchor" id="autotoc_md718"></a>
Handlers</h2>
<p>There are five handler types you can, but do not have to, override to customize operation. Please see the <code>utest/types.h</code> file for a detailed description.</p>
<ol type="1">
<li><code>status_t test_setup_handler_t(const size_t number_of_cases)</code>: called before execution of any test case.</li>
</ol>
<ol type="1">
<li><code>void test_teardown_handler_t(const size_t passed, const size_t failed, const failure_t failure)</code>: called after execution of all test cases, and if testing is aborted.</li>
</ol>
<ol type="1">
<li><code>void test_failure_handler_t(const failure_t failure)</code>: called whenever a failure occurs anywhere in the specification.</li>
</ol>
<ol type="1">
<li><code>status_t case_setup_handler_t(const Case *const source, const size_t index_of_case)</code>: called before execution of each test case.</li>
</ol>
<ol type="1">
<li><code>status_t case_teardown_handler_t(const Case *const source, const size_t passed, const size_t failed, const failure_t reason)</code>: called after execution of each test case, and if testing is aborted.</li>
</ol>
<ol type="1">
<li><code>status_t case_failure_handler_t(const Case *const source, const failure_t reason)</code>: called whenever a failure occurs during the execution of a test case.</li>
</ol>
<p>All handlers are defaulted for integration with the <a href="https://github.com/ARMmbed/mbed-os-tools/tree/master/packages/mbed-greentea">Greentea testing tool</a>.</p>
<h2><a class="anchor" id="autotoc_md719"></a>
Test Case Handlers</h2>
<p>There are three test case handlers:</p>
<ol type="1">
<li><code>void case_handler_t(void)</code>: executes once, if the case setup succeeded.</li>
</ol>
<ol type="1">
<li><code>control_t case_control_handler_t(void)</code>: executes (asynchronously) as many times as you specify, if the case setup succeeded.</li>
</ol>
<ol type="1">
<li><code>control_t case_call_count_handler_t(const size_t call_count)</code>: executes (asynchronously) as many times as you specify, if the case setup succeeded.</li>
</ol>
<p>To specify a test case you must wrap it into a <code><a class="el" href="classCase.html">Case</a></code> class: <code><a class="el" href="classCase.html">Case</a>("mandatory description", case_handler)</code>. You may override the setup, teardown and failure handlers in this wrapper class as well. The <code><a class="el" href="classCase.html">Case</a></code> constructor is overloaded to allow you a comfortable declaration of all your callbacks and the order of arguments is:</p>
<ol type="1">
<li>Description (required).</li>
</ol>
<ol type="1">
<li>Setup handler (optional).</li>
</ol>
<ol type="1">
<li><a class="el" href="classTest.html">Test</a> case handler (required).</li>
</ol>
<ol type="1">
<li>Teardown handler (optional).</li>
</ol>
<ol type="1">
<li>Failure handler (optional).</li>
</ol>
<h3><a class="anchor" id="autotoc_md720"></a>
Test Case Attributes</h3>
<p>You can modify test case behavior by returning <code>control_t</code> modifiers:</p>
<ul>
<li><code>CaseNext</code>: never repeats and immediately moves to next test case</li>
<li><code>CaseNoRepeat</code>: never repeats.</li>
<li><code>CaseRepeatAll</code>: repeats test case <b>with</b> setup and teardown handlers.</li>
<li><code>CaseRepeatHandler</code>: repeats test case <b>without</b> set and teardown handlers.</li>
<li><code>CaseNoTimeout</code>: immediately moves to next test case.</li>
<li><code>CaseAwait</code>: waits indefinitely for callback validation (<em>use with caution</em>).</li>
<li><code>CaseTimeout(uint32_t ms)</code>: waits for callback validation for <code>ms</code> milliseconds, times out after that (fails with <code>REASON_TIMEOUT</code>).</li>
<li><code>CaseRepeatAllOnTimeout(uint32_t ms)</code>: waits for callback validation for <code>ms</code> milliseconds, repeats test case <b>with</b> setup and teardown handlers on time out.</li>
<li><code>CaseRepeatHandlerOnTimeout(uint32_t ms)</code>: waits for callback validation for <code>ms</code> milliseconds, repeats test case <b>without</b> setup and teardown handlers on time out.</li>
</ul>
<p>Returning <code>CaseRepeatAll</code> from your test case handler tells the test harness to repeat the test handler. You can use the <code>call_count</code> (starts counting at 1) to decide when to stop. By default the setup and teardown handlers are called on every repeated test cases, however, you may only repeat the case handler by returning <code>CaseRepeatHandler</code>. To stop the harness from repeating the test case, return <code>CaseNext</code>.</p>
<p>For asynchronous test cases, you must return a <code>CaseTimeout(uint32_t ms)</code>. If you want to automatically repeat the test case on a timeout, use <code>CaseRepeatAllOnTimeout(uint32_t ms)</code> and <code>CaseRepeatHandlerOnTimeout(uint32_t ms)</code>.</p>
<p>To validate your callback, you must call <code>Harness::validate_callback()</code> in your asynchronous callback before the timeout fires. This will schedule the execution of the next test case.</p>
<p>For repeating asynchronous cases, you can "add" both attributes together: <code>CaseTimeout(200) + CaseRepeatAll</code> will wait for 200ms for the callback validation and then repeat the test case. See the section on arbitration logic for more details.</p>
<p>Note that you can also add attributes during callback validation, however, only repeat attributes are considered. This allows you to return <code>CaseTimeout(500)</code> to wait up to 500ms for the callback validation and delegate the decision to repeat to the time the callback occurs: <code>Harness::validate_callback(CaseRepeatHandler)</code>.</p>
<p>Keep in mind that you can only validate a callback once. If you need to wait for several callbacks, you need to write your own helper function that validates the expected callback only when all your custom callbacks arrive. This custom functionality is purposefully not part of this test harness, you can achieve it externally with additional code.</p>
<h2><a class="anchor" id="autotoc_md721"></a>
Failure Handlers</h2>
<p>A failure may occur during any phase of the test. The appropriate failure handler is then called with <code>failure_t</code>, which contains the failure reason and location.</p>
<p>The failure reasons are:</p>
<ul>
<li><code>REASON_NONE</code>: No failure occurred</li>
<li><code>REASON_UNKNOWN</code>: An unknown failure occurred</li>
<li><code>REASON_CASES</code>: A failure occurred in at least one test case</li>
<li><code>REASON_EMPTY_CASE</code>: The test case contains only empty handlers</li>
<li><code>REASON_TIMEOUT</code>: An expected asynchronous call timed out</li>
<li><code>REASON_ASSERTION</code>: An assertion failed</li>
<li><code>REASON_TEST_SETUP</code>: <a class="el" href="classTest.html">Test</a> setup failed</li>
<li><code>REASON_TEST_TEARDOWN</code>: <a class="el" href="classTest.html">Test</a> teardown failed</li>
<li><code>REASON_CASE_SETUP</code>: <a class="el" href="classCase.html">Case</a> setup failed</li>
<li><code>REASON_CASE_HANDLER</code>: <a class="el" href="classCase.html">Case</a> handler failed</li>
<li><code>REASON_CASE_TEARDOWN</code>: <a class="el" href="classCase.html">Case</a> teardown failed</li>
<li><code>REASON_CASE_INDEX</code>: <a class="el" href="classCase.html">Case</a> index returned from test setup or case teardown handler is invalid</li>
<li><code>REASON_SCHEDULER</code>: Underlying scheduler is not asynchronous</li>
</ul>
<p>The failure locations are:</p>
<ul>
<li><code>LOCATION_NONE</code>: No location information</li>
<li><code>LOCATION_UNKNOWN</code>: A failure occurred in an unknown location</li>
<li><code>LOCATION_TEST_SETUP</code>: A failure occurred in the test setup</li>
<li><code>LOCATION_TEST_TEARDOWN</code>: A failure occurred in the test teardown</li>
<li><code>LOCATION_CASE_SETUP</code>: A failure occurred in the case setup</li>
<li><code>LOCATION_CASE_HANDLER</code>: A failure occurred in the case handler</li>
<li><code>LOCATION_CASE_TEARDOWN</code>: A failure occurred in the case teardown</li>
</ul>
<p>If the setup or teardown handlers fail, they may return a <code>STATUS_ABORT</code> code, which will call the failure handler with the appropriate failure reason (<code>REASON_CASE_{SETUP|TEARDOWN}</code>) and failure location (<code>LOCATION_CASE_{SETUP|TEARDOWN}</code>). If the setup handler fails, the test case is never executed. Instead, the teardown handler is called in an attempt to salvage the situation. Please note that if a teardown handler fails, the system can be considered too unstable to continue testing.</p>
<p>You may also raise a failure manually by calling <code>Harness::raise_failure(failure_reason_t reason)</code>. In fact, this is how you can integrate assertion failures from custom test macros, as done with the unity macros, which raise a failure with the <code>REASON_ASSERTION</code> reason.</p>
<p>When waiting for an asynchronous callback, if the timeout fires, <code>REASON_TIMEOUT</code> is raised.</p>
<p>The failure handler decides whether to continue or abort testing by returning <code>STATUS_CONTINUE</code> or <code>STATUS_ABORT</code> respectively. You can also ignore any raised failure by returning <code>STATUS_IGNORE</code> and the harness will then not count this failure. In case of an abort, the test harness dies by busy waiting in a forever loop. This is needed because we cannot unwind the stack without exception support, and the asynchronous nature of the test harness breaks with using <code>longjmp</code>s.</p>
<p>Note that when <code>REASON_IGNORE</code> is <code>OR</code>ed into the failure reason, the failure handler is expected to return <code>STATUS_IGNORE</code>. This is done automatically for test cases repeating after a timeout, and the default failure handlers also report this failure, but tell the harness to ignore it. Furthermore, the unity macros may decide to ignore assertion failures as well, in which case the assertion is ignored intentionally.</p>
<h2><a class="anchor" id="autotoc_md722"></a>
Default Handlers</h2>
<p>Three sets of default handlers with different behaviors are provided for your convenience:</p>
<ol type="1">
<li><code>greentea_abort_handlers</code> (default): Greentea-style reporting, aborts on the first failure, but requires custom test setup handler.</li>
</ol>
<ol type="1">
<li><code>greentea_continue_handlers</code>: Greentea-style reporting, always continues testing, but requires custom test setup handler.</li>
</ol>
<ol type="1">
<li><code>verbose_continue_handlers</code>: always continues testing and reporting, except when a teardown failed.</li>
</ol>
<ol type="1">
<li><code>selftest_handlers</code>: Greentea-style reporting, but aborts on the first assertion failure raised. This allows the use of unity macros for self testing without recursive failure handler calls.</li>
</ol>
<p>These default handlers are called when you have not overridden a custom handler, and they only contain reporting functionality and do not modify global state.</p>
<p>You can specify which default handlers you want to use when wrapping your test cases in the <code>Specification</code> class:</p>
<div class="fragment"><div class="line"><span class="comment">// Declare your test specification with a custom setup handler</span></div>
<div class="line"><span class="comment">// and set the default handlers to the predefined “greentea continue” behavior</span></div>
<div class="line"><a class="code hl_class" href="classutest_1_1v1_1_1Specification.html">Specification</a> specification(greentea_setup, cases, <a class="code hl_variable" href="group__frameworks.html#ga94dd5f75a0eea1204f2c4ce9ec0cf6a4">greentea_continue_handlers</a>);</div>
<div class="ttc" id="agroup__frameworks_html_ga94dd5f75a0eea1204f2c4ce9ec0cf6a4"><div class="ttname"><a href="group__frameworks.html#ga94dd5f75a0eea1204f2c4ce9ec0cf6a4">utest::v1::greentea_continue_handlers</a></div><div class="ttdeci">const handlers_t greentea_continue_handlers</div><div class="ttdoc">The greentea default handlers that always continue on failure.</div><div class="ttdef"><b>Definition</b> utest_greentea_handlers.cpp:40</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md723"></a>
Custom Handlers</h2>
<p>You may override any of the default handlers with your own custom handler.</p>
<p>To ignore a handler completely and not call a custom or default handler, you may use the <code>ignore_handler</code> hint. To explicitly invoke the default handler, use the <code>default_handler</code> hint.</p>
<p>To use your own custom handler, provide a function with the correct signature for the handler that you want to customize and provide it in your test case wrapper or specification wrapper. To turn a <code>failure_t</code> into a meaningful string use the <code>stringify(failure_t)</code> method.</p>
<p><b>We strongly recommend that you call the predefined <code>greentea_*</code> handlers inside your custom callback, as they report the current condition in a properly formatted fashion.</b> By calling these handlers inside your custom callback your unit test does not need to be modified if the test logging needs to be changed in the future.</p>
<p>For the <code>Specification</code> class the order of arguments is:</p>
<ol type="1">
<li><a class="el" href="classTest.html">Test</a> setup handler (optional).</li>
</ol>
<ol type="1">
<li>Array of test cases (required).</li>
</ol>
<ol type="1">
<li><a class="el" href="classTest.html">Test</a> teardown handler (optional).</li>
</ol>
<ol type="1">
<li><a class="el" href="classTest.html">Test</a> failure handler (optional).</li>
</ol>
<ol type="1">
<li>Default handlers (optional).</li>
</ol>
<h2><a class="anchor" id="autotoc_md724"></a>
Test Case Attribute Arbitration</h2>
<p>When adding conflicting modifiers together</p>
<ul>
<li>the more restrictive (=shorter) timeout is chosen, but <code>CaseNoTimeout</code> always wins arbitration: <code>CaseNoTimeout</code> &gt; <code>CaseTimeout(100)</code> &gt; <code>CaseTimeout(200)</code> &gt; <code>CaseAwait</code>.</li>
<li>the more invasive repeat method is chosen, but <code>CaseNoRepeat</code> always wins arbitration: <code>CaseNoRepeat</code> &gt; <code>CaseRepeatAll</code>/<code>CaseRepeatAllOnTimeout(ms)</code> &gt; <code>CaseRepeatHandler</code>/<code>CaseRepeatHandlerOnTimeout(ms)</code>.</li>
<li><code>CaseNext</code> always wins arbitration.</li>
</ul>
<p>The following table shows this arbitration logic in detail:</p>
<p>| + | <code>CaseNext</code> | <code>CaseNoRepeat</code> | <code>CaseRepeatAll</code> | <code>CaseRepeatHandler</code> | <code>CaseNoTimeout</code> | <code>CaseAwait</code> | <code>CaseTimeout(aa)</code> | <code>CaseRepeatAllOnTimeout(aa)</code> | <code>CaseRepeatHandlerOnTimeout(aa)</code> |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | <code>CaseNext</code> | no repeat &amp;<br  />
 no timeout | <code>CaseNoRepeat</code> | no repeat &amp;<br  />
 no timeout | no repeat | <code>CaseRepeatAll</code> | no repeat &amp;<br  />
 no timeout | no repeat | repeat all | <code>CaseRepeatHandler</code> | no repeat &amp;<br  />
 no timeout | no repeat | repeat all | repeat handler | <code>CaseNoTimeout</code> | no repeat &amp;<br  />
 no timeout | no repeat &amp;<br  />
 no timeout | repeat all &amp;<br  />
 no timeout | repeat handler &amp;<br  />
 no timeout | no timeout | <code>CaseAwait</code> | no repeat &amp;<br  />
 no timeout | no repeat &amp;<br  />
 infinite timeout | repeat all &amp;<br  />
 infinite timeout | repeat handler &amp;<br  />
 infinite timeout | no timeout | infinite timeout | <code>CaseTimeout(bb)</code> | no repeat &amp;<br  />
 no timeout | no repeat &amp;<br  />
 <code>bb</code>ms timeout | repeat all &amp;<br  />
 <code>bb</code>ms timeout | repeat handler &amp;<br  />
 <code>bb</code>ms timeout | no timeout | <code>bb</code>ms timeout | <code>min(aa,bb)</code>ms timeout | <code>CaseRepeatAllOnTimeout(bb)</code> | no repeat &amp;<br  />
 no timeout | no repeat &amp;<br  />
 <code>bb</code>ms timeout | repeat all on validate &amp; repeat all on <code>bb</code>ms timeout | repeat all on validate &amp; repeat all on <code>bb</code>ms timeout | repeat all &amp; no timeout | repeat all on <code>bb</code>ms timeout | repeat all on <code>min(aa,bb)</code>ms timeout | repeat all on <code>min(aa,bb)</code>ms timeout | | <code>CaseRepeatHandlerOnTimeout(bb)</code> | no repeat &amp;<br  />
 no timeout | no repeat &amp;<br  />
 <code>bb</code>ms timeout | repeat all on validate &amp; repeat all on <code>bb</code>ms timeout | repeat handler on validate &amp; repeat handler on <code>bb</code>ms timeout | repeat handler &amp; no timeout | repeat handler on <code>bb</code>ms timeout | repeat handler on <code>min(aa,bb)</code>ms timeout | repeat all on <code>min(aa,bb)</code>ms timeout | repeat handler on <code>min(aa,bb)</code>ms timeout</p>
<h2><a class="anchor" id="autotoc_md725"></a>
Atomicity</h2>
<p>All handlers execute with interrupts enabled, <b>except the case failure handler!</b>. This means you can write test cases that poll for interrupts to be completed inside any handler, except the failure handler.</p>
<p>If you setup an interrupt that validates its callback using <code>Harness::validate_callback()</code> inside a test case and it fires before the test case completed, the validation will be buffered. If the test case then returns a timeout value, but the callback is already validated, the test harness just continues normally.</p>
<h2><a class="anchor" id="autotoc_md726"></a>
Custom Scheduler</h2>
<p>By default, a <a class="el" href="classTimeout.html">Timeout</a> object is used for scheduling the harness operations. In case this is not available you can provide your own custom scheduler implementation and make the harness use it with the <code>Harness::set_scheduler(your_custom_implementation)</code> function.</p>
<p>The scheduler requirements are very simple: Execute a <code>void(void)</code> function in you main loop (with a delay of <em>N</em> ms). Only one function is scheduled by the harness <em>at any given time</em>. Note that you do not need to implement the delay functionality, if your tests do not require timeouts. You will still be able to use repeating test cases, but an error is thrown if your tests attempt to use a timeout, when your underlying scheduler does not support it.</p>
<p>There are two functions you need to implement:</p>
<ul>
<li><code>void* post_callback(const utest_v1_harness_callback_t callback, const uint32_t delay_ms)</code>: schedules a <code>void(void)</code> callback function in <em>N</em> ms.</li>
<li><code>int32_t cancel_callback_t(void *handle)</code>: cancels an asynchronous callback.</li>
</ul>
<p>Please see <a href="utest/scheduler.h">their doxygen documentation for implementation details</a>.</p>
<h2><a class="anchor" id="autotoc_md727"></a>
Example Synchronous Scheduler</h2>
<p>Here is the most <a href="test/minimal_scheduler/main.cpp">basic scheduler implementation without any asynchronous support</a>. Note that this does not require any hardware support at all, but you cannot use timeouts in your test cases! </p><div class="fragment"><div class="line"><span class="keyword">volatile</span> <a class="code hl_typedef" href="group__frameworks.html#gac9393c31c218ad7fab7d1b069908fb1b">utest_v1_harness_callback_t</a> minimal_callback;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>* utest_minimal_post(<span class="keyword">const</span> <a class="code hl_typedef" href="group__frameworks.html#gac9393c31c218ad7fab7d1b069908fb1b">utest_v1_harness_callback_t</a> callback, <span class="keyword">const</span> uint32_t delay_ms) {</div>
<div class="line">    minimal_callback = callback;</div>
<div class="line">    <span class="comment">// this scheduler does not support asynchronous callbacks</span></div>
<div class="line">    <span class="keywordflow">return</span> (delay_ms ? NULL : (<span class="keywordtype">void</span>*)1);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">static</span> int32_t utest_minimal_cancel(<span class="keywordtype">void</span>*) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;  <span class="comment">// canceling not supported either</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_struct" href="structutest__v1__scheduler__t.html">utest_v1_scheduler_t</a> utest_minimal_scheduler = {utest_minimal_post, utest_minimal_cancel};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// [...] Add your test cases and specification here.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main() <span class="comment">// or whatever your custom entry point is</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// You MUST set the custom scheduler before running the specification.</span></div>
<div class="line">    <a class="code hl_function" href="group__frameworks.html#ga540ad538043028ad2778f64e284f0ce5">Harness::set_scheduler</a>(utest_minimal_scheduler);</div>
<div class="line">    <a class="code hl_function" href="group__frameworks.html#gab3dbd973627ecb1691bc73c7ec43b5f9">Harness::run</a>(specification);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span>(1) {</div>
<div class="line">        <span class="keywordflow">if</span> (minimal_callback) {</div>
<div class="line">            <span class="comment">// copy the callback and reset the shared memory</span></div>
<div class="line">            <a class="code hl_typedef" href="group__frameworks.html#gac9393c31c218ad7fab7d1b069908fb1b">utest_v1_harness_callback_t</a> callback = minimal_callback;</div>
<div class="line">            minimal_callback = NULL;</div>
<div class="line">            callback(); <span class="comment">// execute the copied callback</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__frameworks_html_ga540ad538043028ad2778f64e284f0ce5"><div class="ttname"><a href="group__frameworks.html#ga540ad538043028ad2778f64e284f0ce5">utest::v1::Harness::set_scheduler</a></div><div class="ttdeci">static bool set_scheduler(utest_v1_scheduler_t scheduler)</div><div class="ttdef"><b>Definition</b> utest_harness.cpp:74</div></div>
<div class="ttc" id="agroup__frameworks_html_gac9393c31c218ad7fab7d1b069908fb1b"><div class="ttname"><a href="group__frameworks.html#gac9393c31c218ad7fab7d1b069908fb1b">utest_v1_harness_callback_t</a></div><div class="ttdeci">void(* utest_v1_harness_callback_t)(void)</div><div class="ttdef"><b>Definition</b> utest_scheduler.h:38</div></div>
<div class="ttc" id="astructutest__v1__scheduler__t_html"><div class="ttname"><a href="structutest__v1__scheduler__t.html">utest_v1_scheduler_t</a></div><div class="ttdef"><b>Definition</b> utest_scheduler.h:96</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md728"></a>
Example Asynchronous Scheduler</h2>
<p>Here is the a <a href="test/minimal_scheduler_async/main.cpp">complete scheduler implementation with any asynchronous support</a>. Note that this does require at least a hardware timer, in this case we have used <code>mbed-hal/us_ticker</code>! Note that you must not execute the callback in the timer interrupt context, but in the main loop context! </p><div class="fragment"><div class="line"><span class="keyword">volatile</span> <a class="code hl_typedef" href="group__frameworks.html#gac9393c31c218ad7fab7d1b069908fb1b">utest_v1_harness_callback_t</a> minimal_callback;</div>
<div class="line"><span class="keyword">volatile</span> <a class="code hl_typedef" href="group__frameworks.html#gac9393c31c218ad7fab7d1b069908fb1b">utest_v1_harness_callback_t</a> ticker_callback;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structticker__data__t.html">ticker_data_t</a> *ticker_data;</div>
<div class="line"><a class="code hl_typedef" href="group__hal.html#ga72ca2ef9e5e60ec062b314f8f8e5cf47">ticker_event_t</a> ticker_event;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ticker_handler(uint32_t) {</div>
<div class="line">    minimal_callback = ticker_callback; <span class="comment">// interrupt context!</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>* utest_minimal_post(<span class="keyword">const</span> <a class="code hl_typedef" href="group__frameworks.html#gac9393c31c218ad7fab7d1b069908fb1b">utest_v1_harness_callback_t</a> callback, <span class="keyword">const</span> uint32_t delay_ms) {</div>
<div class="line">    <span class="keywordflow">if</span> (delay_ms) {</div>
<div class="line">        ticker_callback = callback;</div>
<div class="line">        <a class="code hl_function" href="group__hal__ticker.html#gae9c36d7fa2ba5b731e7aafc05c512e02">ticker_insert_event</a>(ticker_data, &amp;ticker_event, <a class="code hl_function" href="group__hal__ticker.html#ga7f9e2016a0302926df321e7b81318325">ticker_read</a>(ticker_data) + delay_ms * 1000, 0);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> minimal_callback = callback;</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)1;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">static</span> int32_t utest_minimal_cancel(<span class="keywordtype">void</span>*) {</div>
<div class="line">    <a class="code hl_function" href="group__hal__ticker.html#gaee3349009506fd27a43c4e17870f57c1">ticker_remove_event</a>(ticker_data, &amp;ticker_event);</div>
<div class="line">    <span class="keywordflow">return</span> 0;   <span class="comment">// canceling is supported</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_struct" href="structutest__v1__scheduler__t.html">utest_v1_scheduler_t</a> utest_minimal_scheduler = {utest_minimal_post, utest_minimal_cancel};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// [...] Add your test cases and specification here.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main() <span class="comment">// or whatever your custom entry point is</span></div>
<div class="line">{</div>
<div class="line">    ticker_data = <a class="code hl_function" href="group__hal__us__ticker.html#gaea9a7a9b5d33d8dafc7d50dff7116e21">get_us_ticker_data</a>(); <span class="comment">// initialize the ticker data.</span></div>
<div class="line">    <a class="code hl_function" href="group__hal__ticker.html#ga7a28cf9580776f56606d6d69172e053f">ticker_set_handler</a>(ticker_data, ticker_handler);</div>
<div class="line">    <span class="comment">// You MUST set the custom scheduler before running the specification.</span></div>
<div class="line">    <a class="code hl_function" href="group__frameworks.html#ga540ad538043028ad2778f64e284f0ce5">Harness::set_scheduler</a>(utest_minimal_scheduler);</div>
<div class="line">    <a class="code hl_function" href="group__frameworks.html#gab3dbd973627ecb1691bc73c7ec43b5f9">Harness::run</a>(specification);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span>(1) {</div>
<div class="line">        <span class="keywordflow">if</span> (minimal_callback) {</div>
<div class="line">            <span class="comment">// copy the callback and reset the shared memory</span></div>
<div class="line">            <a class="code hl_typedef" href="group__frameworks.html#gac9393c31c218ad7fab7d1b069908fb1b">utest_v1_harness_callback_t</a> <a class="code hl_function" href="group__platform__Callback.html#gab5b487a96d7f93eca70393685cd56f5f">callback</a> = minimal_callback;</div>
<div class="line">            minimal_callback = NULL;</div>
<div class="line">            <a class="code hl_function" href="group__platform__Callback.html#gab5b487a96d7f93eca70393685cd56f5f">callback</a>(); <span class="comment">// execute the copied callback</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__hal__ticker_html_ga7a28cf9580776f56606d6d69172e053f"><div class="ttname"><a href="group__hal__ticker.html#ga7a28cf9580776f56606d6d69172e053f">ticker_set_handler</a></div><div class="ttdeci">void ticker_set_handler(const ticker_data_t *const ticker, ticker_event_handler handler)</div><div class="ttdef"><b>Definition</b> mbed_ticker_api.c:472</div></div>
<div class="ttc" id="agroup__hal__ticker_html_ga7f9e2016a0302926df321e7b81318325"><div class="ttname"><a href="group__hal__ticker.html#ga7f9e2016a0302926df321e7b81318325">ticker_read</a></div><div class="ttdeci">timestamp_t ticker_read(const ticker_data_t *const ticker)</div><div class="ttdef"><b>Definition</b> mbed_ticker_api.c:577</div></div>
<div class="ttc" id="agroup__hal__ticker_html_gae9c36d7fa2ba5b731e7aafc05c512e02"><div class="ttname"><a href="group__hal__ticker.html#gae9c36d7fa2ba5b731e7aafc05c512e02">ticker_insert_event</a></div><div class="ttdeci">void ticker_insert_event(const ticker_data_t *const ticker, ticker_event_t *obj, timestamp_t timestamp, uint32_t id)</div><div class="ttdef"><b>Definition</b> mbed_ticker_api.c:524</div></div>
<div class="ttc" id="agroup__hal__ticker_html_gaee3349009506fd27a43c4e17870f57c1"><div class="ttname"><a href="group__hal__ticker.html#gaee3349009506fd27a43c4e17870f57c1">ticker_remove_event</a></div><div class="ttdeci">void ticker_remove_event(const ticker_data_t *const ticker, ticker_event_t *obj)</div><div class="ttdef"><b>Definition</b> mbed_ticker_api.c:552</div></div>
<div class="ttc" id="agroup__hal__us__ticker_html_gaea9a7a9b5d33d8dafc7d50dff7116e21"><div class="ttname"><a href="group__hal__us__ticker.html#gaea9a7a9b5d33d8dafc7d50dff7116e21">get_us_ticker_data</a></div><div class="ttdeci">const ticker_data_t * get_us_ticker_data(void)</div><div class="ttdef"><b>Definition</b> mbed_us_ticker_api.c:107</div></div>
<div class="ttc" id="agroup__hal_html_ga72ca2ef9e5e60ec062b314f8f8e5cf47"><div class="ttname"><a href="group__hal.html#ga72ca2ef9e5e60ec062b314f8f8e5cf47">ticker_event_t</a></div><div class="ttdeci">struct ticker_event_s ticker_event_t</div></div>
<div class="ttc" id="agroup__platform__Callback_html_gab5b487a96d7f93eca70393685cd56f5f"><div class="ttname"><a href="group__platform__Callback.html#gab5b487a96d7f93eca70393685cd56f5f">mbed::callback</a></div><div class="ttdeci">Callback&lt; R(ArgTs...)&gt; callback(R(*func)(ArgTs...)=nullptr) noexcept</div><div class="ttdef"><b>Definition</b> Callback.h:678</div></div>
<div class="ttc" id="astructticker__data__t_html"><div class="ttname"><a href="structticker__data__t.html">ticker_data_t</a></div><div class="ttdef"><b>Definition</b> ticker_api.h:144</div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5fdebfbd0a4b5643a5e85bf3c8b1558b.html">mbed-os</a></li><li class="navelem"><a class="el" href="dir_c6fb7cfc6dd92a7f08bce53368056667.html">features</a></li><li class="navelem"><a class="el" href="dir_7b9915a6b90f4633002965b77ce294d4.html">frameworks</a></li><li class="navelem"><a class="el" href="dir_5699a11c10a2fdcc134a379e6195f69a.html">utest</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
