<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: /home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/netsocket/tests/TESTS/netsocket Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_b01f97f01f75e114367267730950ea9b.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">netsocket Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_46abfd73b370dc4c0ce94c0c32a25066.html">dns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_a85e7b93b77a6cf10c7bbc557d760177.html">nidd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_56466533108078e534467bb9020a6ab6.html">tcp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_ad207d3d56cb668504681b3d7cee7d92.html">tls</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_dccdcf037bca285ad696917c46aaeefa.html">udp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><a href="test__params_8h_source.html"><span class="icondoc"></span></a>&#160;</td><td class="memItemRight" valign="bottom"><b>test_params.h</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is a test plan for the Mbed OS <a class="el" href="classSocket.html">Socket</a> API. This describes all test cases and their intended behaviors. When an API document is not clear, use this as a reference for implementing correct behavior.</p>
<p><b>NOTE:</b> Because testing is a moving target, this test plan might define more test cases than Mbed OS implements. Refer to test case priorities for a list of test cases that the target must pass to be compliant with the Mbed OS socket API.</p>
<h1><a class="anchor" id="autotoc_md315"></a>
Target API</h1>
<p>The target for this plan is to test:</p>
<ul>
<li><a href="https://github.com/ARMmbed/mbed-os/blob/master/connectivity/netsocket/Socket.h">Socket</a>.</li>
<li><a href="https://github.com/ARMmbed/mbed-os/blob/master/connectivity/netsocket/UDPSocket.h">UDPSocket</a>.</li>
<li><a href="https://github.com/ARMmbed/mbed-os/blob/master/connectivity/netsocket/TCPSocket.h">TCPSocket</a>.</li>
<li><a href="https://github.com/ARMmbed/mbed-os/blob/master/connectivity/netsocket/TLSSocket.h">TLSSocket</a>.</li>
<li><a href="https://github.com/ARMmbed/mbed-os/blob/master/connectivity/netsocket/DNS.h">DNS</a>.</li>
</ul>
<p>Please see the <a href="https://os.mbed.com/docs/mbed-os/latest/apis/network-socket.html">Network Socket documentation</a> for reference.</p>
<h1><a class="anchor" id="autotoc_md316"></a>
Tools to use</h1>
<ul>
<li>Mbed OS.</li>
<li>Standard Mbed OS development tools as described in the <a href="https://os.mbed.com/docs/latest/tools/index.html">Mbed OS tools overview</a>.</li>
<li><a class="el" href="classTest.html">Test</a> server.</li>
</ul>
<p>These test cases themselves do not require any special tooling, other than the test server described in "Test environment" chapter.</p>
<h1><a class="anchor" id="autotoc_md317"></a>
Test environment</h1>
<p>As a general guideline, network connectivity with public Internet access is required. This satisfies <a class="el" href="classSocket.html">Socket</a> tests, but specific connectivity methods might require some extra configuration or devices within the network.</p>
<p>The test environment consist of DUTs, network connection and the test server. Arm provides a public test server, but it can be installed locally as well, if an isolated test environment is required.</p>
<h2><a class="anchor" id="autotoc_md318"></a>
Public test server</h2>
<p>Address: <code>echo.mbedcloudtesting.com</code>.</p>
<p>Both IPv4 and IPv6 addresses are available from a public <a class="el" href="classDNS.html">DNS</a> service:</p>
<div class="fragment"><div class="line">$ host echo.mbedcloudtesting.com</div>
<div class="line">echo.mbedcloudtesting.com has address 52.215.34.155</div>
<div class="line">echo.mbedcloudtesting.com has IPv6 address 2a05:d018:21f:3800:8584:60f8:bc9f:e614</div>
</div><!-- fragment --><p><b>Open services in the test server</b></p>
<ul>
<li>Echo protocol, <a href="https://tools.ietf.org/html/rfc862">RFC 862</a> is enabled on both TCP and UDP on port 7. <a class="el" href="classPort.html">Port</a> 2007 for TLS</li>
<li>Discard protocol, <a href="https://tools.ietf.org/html/rfc863">RFC 863</a> is enabled in both TCP and UDP on port 9. <a class="el" href="classPort.html">Port</a> 2009 for TLS.</li>
<li>Character generator protocol, <a href="https://tools.ietf.org/html/rfc864">RFC 864</a> is enabled in both TCP and UDP on port 19. <a class="el" href="classPort.html">Port</a> 2019 for TLS. The output pattern follows the proposed example pattern in RFC.</li>
<li>Daytime protocol, <a href="https://tools.ietf.org/html/rfc867">RFC 867</a> in both TCP and UDP on port 13. <a class="el" href="classPort.html">Port</a> 2013 for TLS.</li>
<li>Time protocol, <a href="https://tools.ietf.org/html/rfc868">RFC 868</a> in both TCP and UDP on port 37.</li>
</ul>
<p>Configure the firewall to allow this traffic to access the test server.</p>
<p><b>Example configuration for Debian/Ubuntu Linux</b></p>
<p>These services are available on many operating systems, and installing them is out of scope of this document. Below is an example of how to install these services into a Debian/Ubuntu based Linux distribution using standard Inet Daemon:</p>
<div class="fragment"><div class="line">$ sudo apt install inetutils-inetd</div>
<div class="line">$ nano /etc/inetd.conf</div>
</div><!-- fragment --><p>Enable following services from /etc/inetd.conf:</p>
<div class="fragment"><div class="line">#:INTERNAL: Internal services</div>
<div class="line">discard     stream  tcp6    nowait  root    internal</div>
<div class="line">discard     dgram   udp6    wait    root    internal</div>
<div class="line">echo        stream  tcp6    nowait  root    internal</div>
<div class="line">echo        dgram   udp6    wait    root    internal</div>
<div class="line">chargen     stream  tcp6    nowait  root    internal</div>
<div class="line">chargen     dgram   udp6    wait    root    internal</div>
<div class="line">daytime     stream  tcp6    nowait  root    internal</div>
<div class="line">time        stream  tcp6    nowait  root    internal</div>
</div><!-- fragment --><p>Below is an example of how to install these services in TLS version into a Debian/Ubuntu based Linux distribution using Stunnel4 Daemon:</p>
<div class="fragment"><div class="line">$ sudo apt install stunnel4</div>
<div class="line">$ nano /etc/stunnel/stunnel.conf</div>
</div><!-- fragment --><p>Enable following services from /etc/inetd.conf:</p>
<div class="fragment"><div class="line">; **************************************************************************</div>
<div class="line">; * Service definitions (remove all services for inetd mode)               *</div>
<div class="line">; **************************************************************************</div>
<div class="line"> </div>
<div class="line">[echo]</div>
<div class="line">accept  = :::2007</div>
<div class="line">connect = 7</div>
<div class="line">cert = /etc/letsencrypt/live/&lt;test_server_url&gt;/fullchain.pem</div>
<div class="line">key = /etc/letsencrypt/live/&lt;test_server_url&gt;/privkey.pem</div>
<div class="line"> </div>
<div class="line">[discard]</div>
<div class="line">accept  = :::2009</div>
<div class="line">connect = 9</div>
<div class="line">cert = /etc/letsencrypt/live/&lt;test_server_url&gt;/fullchain.pem</div>
<div class="line">key = /etc/letsencrypt/live/&lt;test_server_url&gt;/privkey.pem</div>
<div class="line"> </div>
<div class="line">[daytime]</div>
<div class="line">accept  = :::2013</div>
<div class="line">connect = 13</div>
<div class="line">cert =/etc/letsencrypt/live/&lt;test_server_url&gt;/fullchain.pem</div>
<div class="line">key = /etc/letsencrypt/live/&lt;test_server_url&gt;/privkey.pem</div>
<div class="line"> </div>
<div class="line">[chargen]</div>
<div class="line">accept  = :::2019</div>
<div class="line">connect = 19</div>
<div class="line">cert = /etc/letsencrypt/live/&lt;test_server_url&gt;/fullchain.pem</div>
<div class="line">key = /etc/letsencrypt/live/&lt;test_server_url&gt;/privkey.pem</div>
</div><!-- fragment --><p>Get, update and install certificate files by certbot (Provided by Let's Encrypt <a href="https://letsencrypt.org/">https://letsencrypt.org/</a>).</p>
<ul>
<li><p class="startli">Install lighthttpd server:</p>
<div class="fragment"><div class="line">$ sudo apt-get install lighttpd</div>
<div class="line">$ sudo rm -rf /var/www/html/*</div>
<div class="line">$ sudo echo &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Empty&lt;/h1&gt;&quot; &gt; /var/www/html/index.html</div>
<div class="line">$ sudo echo &quot;&lt;/body&gt;&lt;/html&gt;&quot; &gt;&gt; /var/www/html/index.html</div>
<div class="line">$ sudo chown www-data:www-data /var/www/html/index.html</div>
<div class="line">$ sudo systemctl restart lighttpd.service</div>
</div><!-- fragment --></li>
<li><p class="startli">Install and set up certbot:</p>
<div class="fragment"><div class="line">$ sudo apt-get update</div>
<div class="line">$ sudo apt-get install software-properties-common</div>
<div class="line">$ sudo add-apt-repository ppa:certbot/certbot</div>
<div class="line">$ sudo apt-get update</div>
<div class="line">$ sudo apt-get install certbot</div>
<div class="line">$ sudo certbot certonly</div>
<div class="line">$ sudo certbot certonly --webroot -w /var/www/html -d &lt;test_server_url&gt;</div>
</div><!-- fragment --></li>
<li><p class="startli">Set test server to renew certificate before expiry.</p>
<div class="fragment"><div class="line">$ sudo echo &quot;SHELL=/bin/sh&quot; &gt; /etc/cron.d/certbot</div>
<div class="line">$ sudo echo &quot;PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin&quot; &gt; /etc/cron.d/certbot</div>
<div class="line">$ sudo echo &quot;0 */12 * * * root test -x /usr/bin/certbot -a \! -d /run/systemd/system &amp;&amp; perl -e &#39;sleep int(rand(43200))&#39; &amp;&amp; certbot -q renew&quot; &gt; /etc/cron.d/certbot</div>
</div><!-- fragment --></li>
</ul>
<p>Where &lt;test_server_url&gt; is the test server URL.</p>
<p><b>Testing the connectivity</b></p>
<p>You can connect to the test server with an NMAP tool:</p>
<div class="fragment"><div class="line">$ nmap -sT -p7,9,13,37,2007,2009,2013 echo.mbedcloudtesting.com</div>
<div class="line"> </div>
<div class="line">Starting Nmap 7.01 ( https://nmap.org ) at 2019-01-07 16:45 CET</div>
<div class="line">Nmap scan report for echo.mbedcloudtesting.com (52.215.34.155)</div>
<div class="line">Host is up (0.027s latency).</div>
<div class="line">Other addresses for echo.mbedcloudtesting.com (not scanned): 2a05:d018:21f:3800:3164:2a5c:75b3:970b</div>
<div class="line">rDNS record for 52.215.34.155: ec2-52-215-34-155.eu-west-1.compute.amazonaws.com</div>
<div class="line">PORT     STATE SERVICE</div>
<div class="line">7/tcp    open  echo</div>
<div class="line">9/tcp    open  discard</div>
<div class="line">13/tcp   open  daytime</div>
<div class="line">37/tcp   open  time</div>
<div class="line">2007/tcp open  dectalk</div>
<div class="line">2009/tcp open  news</div>
<div class="line">2013/tcp open  raid-am</div>
<div class="line"> </div>
<div class="line">Nmap done: 1 IP address (1 host up) scanned in 0.10 seconds</div>
<div class="line"> </div>
<div class="line">$ sudo nmap -sU -p7,9,13,37,2007,2009,2013 echo.mbedcloudtesting.com</div>
<div class="line"> </div>
<div class="line">Starting Nmap 7.01 ( https://nmap.org ) at 2019-01-08 15:05 CET</div>
<div class="line">Nmap scan report for echo.mbedcloudtesting.com (52.215.34.155)</div>
<div class="line">Host is up (0.044s latency).</div>
<div class="line">Other addresses for echo.mbedcloudtesting.com (not scanned): 2a05:d018:21f:3800:3164:2a5c:75b3:970b</div>
<div class="line">rDNS record for 52.215.34.155: ec2-52-215-34-155.eu-west-1.compute.amazonaws.com</div>
<div class="line">PORT     STATE         SERVICE</div>
<div class="line">7/udp    open          echo</div>
<div class="line">9/udp    open|filtered discard</div>
<div class="line">13/udp   closed        daytime</div>
<div class="line">37/udp   closed        time</div>
<div class="line">2007/udp closed        raid-am</div>
<div class="line">2009/udp closed        whosockami</div>
<div class="line">2013/udp closed        raid-cd</div>
<div class="line"> </div>
<div class="line">Nmap done: 1 IP address (1 host up) scanned in 1.78 seconds</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md319"></a>
Ethernet test environment</h2>
<p><img src="eth_environment.png" alt="Ethernet" class="inline"/></p>
<p>The Ethernet test environment consists of devices, an Ethernet switch and an optional firewall that allows connecting to the Echo server.</p>
<h2><a class="anchor" id="autotoc_md320"></a>
Wi-Fi test environment</h2>
<p><img src="wifi_environment.png" alt="Wi-Fi" class="inline"/></p>
<p>The Wi-Fi test environment is equivalent to the Ethernet test environment, except that the Wi-Fi test environment has two separate access points or one with dual SSID. Connectivity to echo server is required, but it can be hosted locally, as specified in the Ethernet environment.</p>
<h1><a class="anchor" id="autotoc_md321"></a>
Test case priorities</h1>
<p>Please refer to the following table for priorities of test cases. Priorities are labeled as MUST and SHOULD. MUST means this is a requirement and therefore mandatory to pass the test. SHOULD means it is recommended to pass the test if the driver implements the feature in question.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"><a class="el" href="classTest.html">Test</a> case   </th><th class="markdownTableHeadNone">Priority    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">UDPSOCKET_OPEN_DESTRUCT   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">UDPSOCKET_OPEN_LIMIT   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">UDPSOCKET_OPEN_TWICE   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">UDPSOCKET_OPEN_CLOSE_REPEAT   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">UDPSOCKET_BIND_PORT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">UDPSOCKET_BIND_PORT_FAIL   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">UDPSOCKET_BIND_ADDRESS_INVALID   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">UDPSOCKET_BIND_WRONG_TYPE   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">UDPSOCKET_BIND_ADDRESS   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">12   </td><td class="markdownTableBodyNone">UDPSOCKET_BIND_UNOPENED   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">13   </td><td class="markdownTableBodyNone">UDPSOCKET_SENDTO_INVALID   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">14   </td><td class="markdownTableBodyNone">UDPSOCKET_SENDTO_REPEAT   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">15   </td><td class="markdownTableBodyNone">UDPSOCKET_ECHOTEST   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">UDPSOCKET_ECHOTEST_NONBLOCK   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">17   </td><td class="markdownTableBodyNone">UDPSOCKET_RECV_TIMEOUT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">18   </td><td class="markdownTableBodyNone">UDPSOCKET_SENDTO_TIMEOUT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">19   </td><td class="markdownTableBodyNone">TCPSOCKET_OPEN_DESTRUCT   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">20   </td><td class="markdownTableBodyNone">TCPSOCKET_OPEN_LIMIT   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">21   </td><td class="markdownTableBodyNone">TCPSOCKET_OPEN_TWICE   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">22   </td><td class="markdownTableBodyNone">TCPSOCKET_OPEN_CLOSE_REPEAT   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">23   </td><td class="markdownTableBodyNone">TCPSOCKET_BIND_PORT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">24   </td><td class="markdownTableBodyNone">TCPSOCKET_BIND_PORT_FAIL   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">27   </td><td class="markdownTableBodyNone">TCPSOCKET_BIND_ADDRESS_INVALID   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">28   </td><td class="markdownTableBodyNone">TCPSOCKET_BIND_WRONG_TYPE   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">29   </td><td class="markdownTableBodyNone">TCPSOCKET_BIND_ADDRESS   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">30   </td><td class="markdownTableBodyNone">TCPSOCKET_BIND_UNOPENED   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">31   </td><td class="markdownTableBodyNone">TCPSOCKET_CONNECT_INVALID   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">TCPSOCKET_SEND_REPEAT   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">33   </td><td class="markdownTableBodyNone">TCPSOCKET_ECHOTEST   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">34   </td><td class="markdownTableBodyNone">TCPSOCKET_ECHOTEST_NONBLOCK   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">35   </td><td class="markdownTableBodyNone">TCPSOCKET_RECV_TIMEOUT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">36   </td><td class="markdownTableBodyNone">TCPSOCKET_SEND_TIMEOUT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">37   </td><td class="markdownTableBodyNone">TCPSOCKET_ENDPOINT_CLOSE   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">38   </td><td class="markdownTableBodyNone">UDPSOCKET_ECHOTEST_BURST   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">39   </td><td class="markdownTableBodyNone">UDPSOCKET_ECHOTEST_BURST_NONBLOCK   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">40   </td><td class="markdownTableBodyNone">TCPSOCKET_ECHOTEST_BURST   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">41   </td><td class="markdownTableBodyNone">TCPSOCKET_ECHOTEST_BURST_NONBLOCK   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">42   </td><td class="markdownTableBodyNone">TCPSOCKET_RECV_100K   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">43   </td><td class="markdownTableBodyNone">TCPSOCKET_RECV_100K_NONBLOCK   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">44   </td><td class="markdownTableBodyNone">TCPSOCKET_THREAD_PER_SOCKET_SAFETY   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">45   </td><td class="markdownTableBodyNone">TCPSOCKET_SETSOCKOPT_KEEPALIVE_VALID   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">46   </td><td class="markdownTableBodyNone">TLSSOCKET_OPEN_DESTRUCT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">47   </td><td class="markdownTableBodyNone">TLSSOCKET_OPEN_LIMIT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">48   </td><td class="markdownTableBodyNone">TLSSOCKET_OPEN_TWICE   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">49   </td><td class="markdownTableBodyNone">TLSSOCKET_CONNECT_INVALID   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">50   </td><td class="markdownTableBodyNone">TLSSOCKET_HANDSHAKE_INVALID   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">51   </td><td class="markdownTableBodyNone">TLSSOCKET_SEND_CLOSED   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">52   </td><td class="markdownTableBodyNone">TLSSOCKET_SEND_UNCONNECTED   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">53   </td><td class="markdownTableBodyNone">TLSSOCKET_SEND_REPEAT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">54   </td><td class="markdownTableBodyNone">TLSSOCKET_SEND_TIMEOUT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">55   </td><td class="markdownTableBodyNone">TLSSOCKET_ECHOTEST   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">56   </td><td class="markdownTableBodyNone">TLSSOCKET_ECHOTEST_NONBLOCK   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">57   </td><td class="markdownTableBodyNone">TLSSOCKET_ENDPOINT_CLOSE   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">58   </td><td class="markdownTableBodyNone">TLSSOCKET_NO_CERT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">59   </td><td class="markdownTableBodyNone">TLSSOCKET_RECV_TIMEOUT   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">60   </td><td class="markdownTableBodyNone">TLSSOCKET_SIMULTANEOUS_TEST   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">61   </td><td class="markdownTableBodyNone">TLSSOCKET_ECHOTEST_BURST   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">62   </td><td class="markdownTableBodyNone">TLSSOCKET_ECHOTEST_BURST_NONBLOCK   </td><td class="markdownTableBodyNone">SHOULD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">63   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">64   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS_CACHE   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">65   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS_CANCEL   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">66   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS_EXTERNAL_EVENT_QUEUE   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">67   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS_INVALID_HOST   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">68   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS_NON_ASYNC_AND_ASYNC   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">69   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS_SIMULTANEOUS_CACHE   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">70   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS_SIMULTANEOUS_REPEAT   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">71   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS_SIMULTANEOUS   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">72   </td><td class="markdownTableBodyNone">ASYNCHRONOUS_DNS_TIMEOUTS   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">73   </td><td class="markdownTableBodyNone">SYNCHRONOUS_DNS   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">74   </td><td class="markdownTableBodyNone">SYNCHRONOUS_DNS_CACHE   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">75   </td><td class="markdownTableBodyNone">SYNCHRONOUS_DNS_INVALID_HOST   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">76   </td><td class="markdownTableBodyNone">SYNCHRONOUS_DNS_MULTIPLE   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">77   </td><td class="markdownTableBodyNone">UDPSOCKET_ECHOTEST_CONNECT_SEND_RECV   </td><td class="markdownTableBodyNone">MUST    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">78   </td><td class="markdownTableBodyNone">UDPSOCKET_ECHOTEST_NONBLOCK_CONNECT_SEND_RECV   </td><td class="markdownTableBodyNone">MUST   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md322"></a>
Building test binaries</h1>
<p>To test the board and driver, test against the Mbed OS master branch to get the most recent, up-to-date test cases and drivers.</p>
<p>To create a build environment:</p>
<div class="fragment"><div class="line">mbed new network_test</div>
<div class="line">cd network_test</div>
<div class="line">cd mbed-os</div>
<div class="line">git checkout master</div>
<div class="line">cd ..</div>
</div><!-- fragment --><p>Also, building socket test cases requires a special macro to enable all tests, so create an <code>mbed_app.json</code> file with the following content at minimum:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;config&quot;: {</div>
<div class="line">        &quot;echo-server-addr&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;IP address of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;\&quot;echo.mbedcloudtesting.com\&quot;&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-port&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Port of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;7&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-discard-port&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Discard port of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;9&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-port-tls&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Echo port of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;2007&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-discard-port-tls&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Discard port of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;2009&quot;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Wi-Fi tests require some more configuration, so for Wi-Fi purposes, the <code>mbed_app.json</code> might look like this:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;config&quot;: {</div>
<div class="line">        &quot;wifi-secure-ssid&quot;: {</div>
<div class="line">            &quot;help&quot;: &quot;WiFi SSID for WPA2 secured network&quot;,</div>
<div class="line">            &quot;value&quot;: &quot;\&quot;test-network\&quot;&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;wifi-unsecure-ssid&quot;: {</div>
<div class="line">            &quot;help&quot;: &quot;WiFi SSID for unsecure netwrok&quot;,</div>
<div class="line">            &quot;value&quot;: &quot;\&quot;unsecure-test-net\&quot;&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;wifi-password&quot;: {</div>
<div class="line">            &quot;help&quot;: &quot;WiFi Password&quot;,</div>
<div class="line">            &quot;value&quot;: &quot;\&quot;password\&quot;&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;wifi-secure-protocol&quot;: {</div>
<div class="line">            &quot;help&quot;: &quot;WiFi security protocol, valid values are WEP, WPA, WPA2, WPA_WPA2&quot;,</div>
<div class="line">            &quot;value&quot;: &quot;\&quot;WPA2\&quot;&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;wifi-ch-secure&quot;: {</div>
<div class="line">            &quot;help&quot;: &quot;Channel number of secure SSID&quot;,</div>
<div class="line">            &quot;value&quot;: 6</div>
<div class="line">        },</div>
<div class="line">        &quot;wifi-ch-unsecure&quot;: {</div>
<div class="line">            &quot;help&quot;: &quot;Channel number of unsecure SSID&quot;,</div>
<div class="line">            &quot;value&quot;: 6</div>
<div class="line">        },</div>
<div class="line">        &quot;ap-mac-secure&quot;: {</div>
<div class="line">            &quot;help&quot;: &quot;BSSID of secure AP in form of AA:BB:CC:DD:EE:FF&quot;,</div>
<div class="line">            &quot;value&quot;: &quot;\&quot;58:8b:f3:99:f2:9c\&quot;&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;ap-mac-unsecure&quot;: {</div>
<div class="line">            &quot;help&quot;: &quot;BSSID of unsecure AP in form of \&quot;AA:BB:CC:DD:EE:FF\&quot;&quot;,</div>
<div class="line">            &quot;value&quot;: &quot;\&quot;58:8b:f3:99:c2:08\&quot;&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;max-scan-size&quot;: {</div>
<div class="line">            &quot;help&quot;: &quot;How many networks may appear in Wifi scan result&quot;,</div>
<div class="line">            &quot;value&quot;: 30</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-addr&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;IP address of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;\&quot;echo.mbedcloudtesting.com\&quot;&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-port&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Port of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;7&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-discard-port&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Discard port of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;9&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-port-tls&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Port of echo server for TLS&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;2007&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-discard-port-tls&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Discard port of echo server for TLS&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;2009&quot;</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line">    &quot;target_overrides&quot;: {</div>
<div class="line">        &quot;*&quot;: {</div>
<div class="line">            &quot;target.network-default-interface-type&quot;: &quot;WIFI&quot;,</div>
<div class="line">            &quot;nsapi.default-wifi-ssid&quot;: &quot;\&quot;WIFI_SSID\&quot;&quot;,</div>
<div class="line">            &quot;nsapi.default-wifi-password&quot;: &quot;\&quot;WIFI_PASSWORD\&quot;&quot;,</div>
<div class="line">            &quot;nsapi.default-wifi-security&quot;: &quot;WPA_WPA2&quot;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Cellular tests require some more configuration, so for cellular purposes, the <code>mbed_app.json</code> might look like this: NOTE! These are just typical settings needed for cellular. Actual configuration values depend on used target HW, SIM, modem and network capabilities.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;config&quot;: {</div>
<div class="line">        &quot;echo-server-addr&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;IP address of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;\&quot;echo.mbedcloudtesting.com\&quot;&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-port&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Port of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;7&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-discard-port&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Discard port of echo server&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;9&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-port-tls&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Port of echo server for TLS&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;2007&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;echo-server-discard-port-tls&quot; : {</div>
<div class="line">            &quot;help&quot; : &quot;Discard port of echo server for TLS&quot;,</div>
<div class="line">            &quot;value&quot; : &quot;2009&quot;</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line">    &quot;target_overrides&quot;: {</div>
<div class="line">        &quot;*&quot;: {</div>
<div class="line">            &quot;target.network-default-interface-type&quot;: &quot;CELLULAR&quot;,</div>
<div class="line">            &quot;nsapi.default-cellular-sim-pin&quot;: &quot;\&quot;SIM PIN if needed\&quot;&quot;,</div>
<div class="line">            &quot;nsapi.default-cellular-plmn&quot;: &quot;\&quot;PLMN if needed\&quot;&quot;,</div>
<div class="line">            &quot;nsapi.default-cellular-apn&quot;: &quot;\&quot;APN if needed\&quot;&quot;,</div>
<div class="line">            &quot;nsapi.default-cellular-username&quot;: &quot;\&quot;SIM USERNAME if needed\&quot;&quot;,</div>
<div class="line">            &quot;nsapi.default-cellular-password&quot;: &quot;\&quot;SIM PASSWORD if needed\&quot;&quot;,</div>
<div class="line">            &quot;lwip.ipv4-enabled&quot;: true,</div>
<div class="line">            &quot;lwip.ipv6-enabled&quot;: true,</div>
<div class="line">            &quot;lwip.tcp-enabled&quot;: true,</div>
<div class="line">            &quot;lwip.ppp-enabled&quot;: true,</div>
<div class="line">            &quot;lwip.ethernet-enabled&quot;: false,</div>
<div class="line">            &quot;&lt;YOUR MODEM TARGET&gt;.provide-default&quot;: true,</div>
<div class="line">            &quot;cellular.radio-access-technology&quot;: &lt;see supported values from cellular mbed_lib.json&gt;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Please, see <code>mbed-os/tools/test_configs</code> folder for examples for different technologies.</p>
<p>Now build the test binaries:</p>
<div class="fragment"><div class="line">mbed test --compile -t &lt;toolchain&gt; -m &lt;target&gt; -n mbed-os-tests-network-*,mbed-os-tests-netsocket*</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md323"></a>
Running tests</h1>
<p>Run this when the device is connected to network, or if the wireless device is near the access point:</p>
<div class="fragment"><div class="line">mbed test -n mbed-os-tests-network-*,mbed-os-tests-netsocket*</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md324"></a>
Test cases for Socket class</h1>
<p>These tests are the same as those for <a class="el" href="classUDPSocket.html">UDPSocket</a> and <a class="el" href="classTCPSocket.html">TCPSocket</a>. The <a class="el" href="classSocket.html">Socket</a> class is abstract, so it cannot be instantiated; therefore, these test cases are implemented using both <a class="el" href="classTCPSocket.html">TCPSocket</a> and <a class="el" href="classUDPSocket.html">UDPSocket</a>. Some of these tests are also implemented for the TLSSocket class. In such case, the certificate has to be set for the <a class="el" href="classSocket.html">Socket</a> before calling <code>open()</code>, unless specified otherwise in the test's description.</p>
<h2><a class="anchor" id="autotoc_md325"></a>
SOCKET_OPEN_DESTRUCT</h2>
<p><b>Description:</b></p>
<p>Call <code>Socket::open()</code>, and then destruct the socket.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create an object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Delete the object.</li>
</ol>
<ol type="1">
<li>Repeat 100 times.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code>Socket::open()</code> always returns <code>NSAPI_ERROR_OK</code>.</p>
<h2><a class="anchor" id="autotoc_md326"></a>
SOCKET_OPEN_LIMIT</h2>
<p><b>Description:</b></p>
<p>Call <code>Socket::open()</code> until it runs out of memory or another internal limit in the stack is reached.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create an object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Repeat until <code>NSAPI_ERROR_NO_MEMORY</code> or <code>NSAPI_ERROR_NO_SOCKET</code> error code is returned.</li>
</ol>
<ol type="1">
<li>Call "delete" for all previously allocated sockets.</li>
</ol>
<ol type="1">
<li>Repeat.</li>
</ol>
<p><b>Expected result:</b></p>
<p>It can reserve at least four sockets. After freeing all sockets, it can reserve the same number of sockets.</p>
<h2><a class="anchor" id="autotoc_md327"></a>
SOCKET_OPEN_TWICE</h2>
<p><b>Description:</b></p>
<p>Call <code>Socket::open()</code> twice.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create an object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code>Socket::open()</code> first call (socket was not opened) returns <code>NSAPI_ERROR_OK</code> and nexts calls (socet was opened by previous call Socket::open()) return <code>NSAPI_ERROR_PARAMETER</code>.</p>
<h2><a class="anchor" id="autotoc_md328"></a>
SOCKET_OPEN_CLOSE_REPEAT</h2>
<p><b>Description:</b></p>
<p>Call <code>Socket::open()</code> followed by <code><a class="el" href="classSocket.html#ad3cb707ab2cbc9d74a0095c61be37367">Socket::close()</a></code> and then again <code>Socket::open()</code>. Should allows you to reuse the same object.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create an object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::close(stack)</code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::close(stack)</code>.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>Socket::open()</code> and <code><a class="el" href="classSocket.html#ad3cb707ab2cbc9d74a0095c61be37367">Socket::close()</a></code> calls return <code>NSAPI_ERROR_OK</code>.</p>
<h2><a class="anchor" id="autotoc_md329"></a>
SOCKET_BIND_PORT</h2>
<p><b>Description:</b></p>
<p>Call <code>Socket::bind(port)</code>.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create an object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classSocket.html#a0f6e5f208f386894c07eeb325476273b">Socket::bind</a>(&lt;any unused port number&gt;);</code>.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All calls return <code>NSAPI_ERROR_OK</code>.</p>
<h2><a class="anchor" id="autotoc_md330"></a>
SOCKET_BIND_PORT_FAIL</h2>
<p><b>Description:</b></p>
<p>Call <code>Socket::bind(port)</code> on a port number that is already used.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create an object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classSocket.html#a0f6e5f208f386894c07eeb325476273b">Socket::bind</a>(&lt;any unused port number&gt;);</code>.</li>
</ol>
<ol type="1">
<li>Repeat steps 1-3 for a new socket.</li>
</ol>
<ol type="1">
<li>Destroy both sockets.</li>
</ol>
<p><b>Expected result:</b></p>
<p>The second <code><a class="el" href="classSocket.html#a0f6e5f208f386894c07eeb325476273b">Socket::bind()</a></code> returns <code>NSAPI_ERROR_PARAMETER</code>.</p>
<h2><a class="anchor" id="autotoc_md331"></a>
SOCKET_BIND_ADDRESS_INVALID</h2>
<p><b>Description:</b></p>
<p>Call <code>Socket::bind(address, port)</code> with an address not assigned to you.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create an object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Check whether the device is IPv4 or IPv6 connected.<ol type="a">
<li>For IPv4: Call <code><a class="el" href="classSocket.html#a0f6e5f208f386894c07eeb325476273b">Socket::bind</a>("190.2.3.4", &lt;any unused port number&gt;);</code>.</li>
</ol>
<ol type="a">
<li>For IPv6: Call <code><a class="el" href="classSocket.html#a0f6e5f208f386894c07eeb325476273b">Socket::bind</a>("fe80::ff01", &lt;any unused port number&gt;);</code>.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code><a class="el" href="classSocket.html#a0f6e5f208f386894c07eeb325476273b">Socket::bind()</a></code> returns <code>NSAPI_ERROR_PARAMETER</code>.</p>
<h2><a class="anchor" id="autotoc_md332"></a>
SOCKET_BIND_ADDRESS_WRONG_TYPE</h2>
<p><b>Description:</b></p>
<p>Call <code>Socket::bind(SocketAddress)</code> with an address that is not the wrong type for the connection.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create a object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Check whether the device is IPv4 or IPv6 connected:<ul>
<li>For IPv4: Create <code><a class="el" href="classSocketAddress.html">SocketAddress</a>("fe80::ff01", &lt;any unused port number&gt;);</code>.</li>
<li>For IPv6: Create <code><a class="el" href="classSocketAddress.html">SocketAddress</a>("190.2.3.4", &lt;any unused port number&gt;);</code>.</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Call <code>Socket::bind(address);</code>.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code><a class="el" href="classSocket.html#a0f6e5f208f386894c07eeb325476273b">Socket::bind()</a></code> returns <code>NSAPI_ERROR_PARAMETER</code>.</p>
<h2><a class="anchor" id="autotoc_md333"></a>
SOCKET_BIND_ADDRESS</h2>
<p><b>Description:</b></p>
<p>Call <code>Socket::bind(SocketAddress)</code>.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create an object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::open(stack)</code>.</li>
</ol>
<ol type="1">
<li>Get address by calling <code><a class="el" href="classNetworkInterface.html#a3caf98844ea0d3a19b2fe7648536be25">NetworkInterface::get_ip_address()</a>;</code>.</li>
</ol>
<ol type="1">
<li>Create a <a class="el" href="classSocketAddress.html">SocketAddress</a> object using this address and any unused port number.</li>
</ol>
<ol type="1">
<li>Call <code>Socket::bind(address);</code>.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All calls return <code>NSAPI_ERROR_OK</code>.</p>
<h2><a class="anchor" id="autotoc_md334"></a>
SOCKET_BIND_UNOPENED</h2>
<p><b>Description:</b></p>
<p>Call <code><a class="el" href="classSocket.html#a0f6e5f208f386894c07eeb325476273b">Socket::bind()</a></code> on a socket that has not been opened.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create an object by calling <code>new <a class="el" href="classSocket.html">Socket()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classSocket.html#a0f6e5f208f386894c07eeb325476273b">Socket::bind</a>(&lt;any unused port number&gt;);</code>.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code>NSAPI_ERROR_NO_SOCKET</code></p>
<h1><a class="anchor" id="autotoc_md335"></a>
Test cases for UDPSocket class</h1>
<h2><a class="anchor" id="autotoc_md336"></a>
UDPSOCKET_OPEN_DESTRUCT</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_DESTRUCT</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md337"></a>
UDPSOCKET_OPEN_LIMIT</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_LIMIT</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md338"></a>
UDPSOCKET_OPEN_TWICE</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_TWICE</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md339"></a>
UDPSOCKET_OPEN_CLOSE_REPEAT</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_CLOSE_REPEAT</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md340"></a>
UDPSOCKET_BIND_PORT</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_PORT</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md341"></a>
UDPSOCKET_BIND_PORT_FAIL</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_PORT_FAIL</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md342"></a>
UDPSOCKET_BIND_ADDRESS_INVALID</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_ADDRESS_INVALID</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md343"></a>
UDPSOCKET_BIND_WRONG_TYPE</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_WRONG_TYPE</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md344"></a>
UDPSOCKET_BIND_ADDRESS</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_ADDRESS</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md345"></a>
UDPSOCKET_BIND_UNOPENED</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_UNOPENED</code> for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md346"></a>
UDPSOCKET_SENDTO_REPEAT</h2>
<p><b>Description:</b></p>
<p>Repeatedly send small packets.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classUDPSocket.html">UDPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 9, "hello", 5);</code>.</li>
</ol>
<ol type="1">
<li>Repeat 100 times.</li>
</ol>
<ol type="1">
<li>Fail if <code>NSAPI_ERROR_NO_MEMORY</code> is returned two times in a row.</li>
</ol>
<ol type="1">
<li>Wait 1 second before retrying.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>sendto()</code> calls return 5.</p>
<h2><a class="anchor" id="autotoc_md347"></a>
UDPSOCKET_ECHOTEST</h2>
<p><b>Description:</b></p>
<p>Repeatedly send packets to echo server and read incoming packets back. Verify different packet sizes work.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classUDPSocket.html">UDPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = loop index&gt;, &lt;loop index&gt;);</code>.</li>
</ol>
<ol type="1">
<li>Wait for incoming packet.<ul>
<li>If timeout happens, retry sending and receiving a maximum of three times.</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Verify incoming content is the same as the sent content.</li>
</ol>
<ol type="1">
<li>Repeat 1,200 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<ul>
<li>At least one <code>sendto()</code> call of every size returns the packet size.</li>
<li>Errors returned from <code>recvfrom()</code> calls are tolerated.</li>
<li>Calculate packet loss rate. The maximum tolerated packet loss rate is 30%.</li>
</ul>
<h2><a class="anchor" id="autotoc_md348"></a>
UDPSOCKET_ECHOTEST_NONBLOCK</h2>
<p><b>Description:</b></p>
<p>Repeatedly send packets to echo server and read incoming packets back. Verify different packet sizes work. Use <a class="el" href="classSocket.html">Socket</a> in nonblocking mode.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classUDPSocket.html">UDPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>UDPSocket::set_blocking(false)</code>.</li>
</ol>
<ol type="1">
<li>Register event handler with <code><a class="el" href="classInternetSocket.html#a73f4a6bc3257295800883f03994b7fb8">UDPSocket::sigio()</a></code>.</li>
</ol>
<ol type="1">
<li>Create another thread that constantly waits for a signal from the <code>sigio()</code> handler.</li>
</ol>
<ol type="1">
<li>When it's received, try <code><a class="el" href="classInternetDatagramSocket.html#a76fca153b4fb769cba3aa2035f84a3e6">UDPSocket::recvfrom()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = loop index&gt;, &lt;loop index&gt;);</code>.</li>
</ol>
<ol type="1">
<li>Wait for an incoming packet for one second.<ul>
<li>If nothing is received, retry a maximum of three times.</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="1">
<li>Repeat 1,200 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<ul>
<li>At least one <code>sendto()</code> call of every size returns the packet size.</li>
<li>Errors returned from <code>recvfrom()</code> calls are tolerated.</li>
<li>Calculate packet loss rate. The maximum tolerated packet loss rate is 30%.</li>
</ul>
<h2><a class="anchor" id="autotoc_md349"></a>
UDPSOCKET_ECHOTEST_CONNECT_SEND_RECV</h2>
<p><b>Description:</b></p>
<p>This test is exactly the same test as UDPSOCKET_ECHOTEST, except instead of using <code>sendto()</code> and <code>recvfrom()</code> methods, this uses TCPSocket-like <code>connect()</code>, <code>send()</code> and <code>recv()</code> methods.</p>
<h2><a class="anchor" id="autotoc_md350"></a>
UDPSOCKET_ECHOTEST_NONBLOCK_CONNECT_SEND_RECV</h2>
<p><b>Description:</b></p>
<p>This test is exactly the same test as UDPSOCKET_ECHOTEST_NONBLOCK_CONNECT_SEND_RECV, except instead of using <code>sendto()</code> and <code>recvfrom()</code> methods, this uses TCPSocket-like <code>connect()</code>, <code>send()</code> and <code>recv()</code> methods.</p>
<h2><a class="anchor" id="autotoc_md351"></a>
UDPSOCKET_RECV_TIMEOUT</h2>
<p><b>Description:</b></p>
<p><a class="el" href="classTest.html">Test</a> whether timeouts are obeyed in UDPSockets.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>UDPSocket::set_timeout(100)</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classInternetDatagramSocket.html#a4be827001a83184b14c737a5a4ed86a9">UDPSocket::sendto</a>("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 100&gt;, 100);</code>.</li>
</ol>
<ol type="1">
<li>Repeat five times.<ol type="a">
<li>Record a time with millisecond precision.</li>
</ol>
<ol type="a">
<li>Call <code><a class="el" href="classInternetDatagramSocket.html#a76fca153b4fb769cba3aa2035f84a3e6">UDPSocket::recvfrom()</a></code>.</li>
</ol>
<ol type="a">
<li>Record a time with millisecond precision.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Repeat the test case 10 times.</li>
</ol>
<p><b>Expected result:</b></p>
<p>Each <code>sendto()</code> call returns 100.</p>
<p>Within each loop, one <code>recvfrom()</code> may return the received packet size (100). Other calls return <code>NSAPI_ERROR_WOULD_BLOCK</code>.</p>
<p>When <code>NSAPI_ERROR_WOULD_BLOCK</code> is received, check that time consumed is more that 100 milliseconds but less than 200 milliseconds.</p>
<h2><a class="anchor" id="autotoc_md352"></a>
UDPSOCKET_SENDTO_TIMEOUT</h2>
<p><b>Description:</b></p>
<p><a class="el" href="classTest.html">Test</a> whether timeouts are obeyed in UDPSockets.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Record time.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classInternetDatagramSocket.html#a4be827001a83184b14c737a5a4ed86a9">UDPSocket::sendto</a>("echo.mbedcloudtesting.com", 9, &lt;random packet, size = 100&gt;, 100);</code>.</li>
</ol>
<ol type="1">
<li>Record time.</li>
</ol>
<ol type="1">
<li>Call <code>UDPSocket::set_timeout(1000)</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classInternetDatagramSocket.html#a4be827001a83184b14c737a5a4ed86a9">UDPSocket::sendto</a>("echo.mbedcloudtesting.com", 9, &lt;random packet, size = 100&gt;, 100);</code>.</li>
</ol>
<ol type="1">
<li>Record time.</li>
</ol>
<p><b>Expected result:</b></p>
<p>Each <code>sendto()</code> call returns 100.</p>
<p>All <code>sendto()</code> calls return faster than 100 milliseconds because UDP sending does not block that long.</p>
<h1><a class="anchor" id="autotoc_md353"></a>
Test cases for TCPSocket class</h1>
<h2><a class="anchor" id="autotoc_md354"></a>
TCPSOCKET_OPEN_DESTRUCT</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_DESTRUCT</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md355"></a>
TCPSOCKET_OPEN_LIMIT</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_LIMIT</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md356"></a>
TCPSOCKET_OPEN_TWICE</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_TWICE</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md357"></a>
TCPSOCKET_OPEN_CLOSE_REPEAT</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_CLOSE_REPEAT</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md358"></a>
TCPSOCKET_BIND_PORT</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_PORT</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md359"></a>
TCPSOCKET_BIND_PORT_FAIL</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_PORT_FAIL</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md360"></a>
TCPSOCKET_BIND_ADDRESS_INVALID</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_ADDRESS_INVALID</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md361"></a>
TCPSOCKET_BIND_WRONG_TYPE</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_WRONG_TYPE</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md362"></a>
TCPSOCKET_BIND_ADDRESS</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_ADDRESS</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md363"></a>
TCPSOCKET_BIND_UNOPENED</h2>
<p><b>Description:</b> Run <code>SOCKET_BIND_UNOPENED</code> for <a class="el" href="classTCPSocket.html">TCPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md364"></a>
TCPSOCKET_CONNECT_INVALID</h2>
<p><b>Description:</b></p>
<p>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect()</a></code> with invalid parameters.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html">TCPSocket</a>:connect( NULL, 9);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html">TCPSocket</a>:connect( "", 9);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html">TCPSocket</a>:connect( "", 0);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html">TCPSocket</a>:connect( "echo.mbedcloudtesting.com", 9);</code>.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>connect()</code> calls return an error code except the number 4, which returns <code>NSAPI_ERROR_OK</code>.</p>
<h2><a class="anchor" id="autotoc_md365"></a>
TCPSOCKET_SEND_REPEAT</h2>
<p><b>Description:</b></p>
<p>Repeatedly send small packets.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 9);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a8b3dcd672c499cee312d8f246b5d82df">TCPSocket::send</a>("hello", 5);</code>.</li>
</ol>
<ol type="1">
<li>Repeat 100 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect()</a></code> returns <code>NSAPI_ERROR_OK</code>.</p>
<p>All <code>send()</code> calls return 5.</p>
<h2><a class="anchor" id="autotoc_md366"></a>
TCPSOCKET_ECHOTEST</h2>
<p><b>Description:</b></p>
<p>Repeatedly send packets to echo server and read incoming packets back. Verify different packet sizes work.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 7);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a8b3dcd672c499cee312d8f246b5d82df">TCPSocket::send</a>(&lt;random packet, size = loop index&gt;, &lt;size&gt;);</code>.<ol type="a">
<li>If less than &lt;loop index&gt; was returned, size = sent bytes.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a1abab1c5e182d0d96f1c1ac53c60a7a0">TCPSocket::recv</a>(buffer, &lt;size&gt;);</code>.</li>
</ol>
<ol type="1">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="1">
<li>Repeat 1,200 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>send()</code> calls return the packet size or less. All <code>recv()</code> calls return the same sized packet that was sent with same content.</p>
<p>NOTE: This is stream, so <code>recv()</code> might return less data than requested. Keep calling <code>recv()</code> until all data you have sent is returned.</p>
<h2><a class="anchor" id="autotoc_md367"></a>
TCPSOCKET_ECHOTEST_NONBLOCK</h2>
<p><b>Description:</b></p>
<p>Repeatedly send packets to echo server and read incoming packets back. Verify different packet sizes work. Use <a class="el" href="classSocket.html">Socket</a> in nonblocking mode.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 7);</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TCPSocket::set_blocking(false)</code>.</li>
</ol>
<ol type="1">
<li>Register event handler with <code><a class="el" href="classInternetSocket.html#a73f4a6bc3257295800883f03994b7fb8">TCPSocket::sigio()</a></code>.</li>
</ol>
<ol type="1">
<li>Create another thread that constantly waits for a signal from <code>sigio()</code> handler.</li>
</ol>
<ol type="1">
<li>When it's received, try <code><a class="el" href="classTCPSocket.html#a1abab1c5e182d0d96f1c1ac53c60a7a0">TCPSocket::recv</a>(buf+index, &lt;loop index&gt; - index)</code>, where index is the amount of data already received.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html">TCPSocket</a>:send(&lt;random packet, size = loop index&gt;, &lt;loop index&gt;);</code>.<ol type="a">
<li>If less than &lt;loop index&gt; is returned, try immediately sending the remaining bytes.</li>
</ol>
<ol type="a">
<li>If <code>NSAPI_ERROR_WOULD_BLOCK</code> is returned, wait for <code>sigio()</code> call to happen.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Wait for incoming packet for one second.</li>
</ol>
<ol type="1">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="1">
<li>Set index for receiving thread to zero.</li>
</ol>
<ol type="1">
<li>Repeat 1,200 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>send()</code> calls return the packet size or less. All <code>recv()</code> calls return <code>NSAPI_ERROR_WOULD_BLOCK</code> or a packet size equal to or less than what has been sent.</p>
<h2><a class="anchor" id="autotoc_md368"></a>
TCPSOCKET_RECV_TIMEOUT</h2>
<p><b>Description:</b></p>
<p><a class="el" href="classTest.html">Test</a> whether timeouts are obeyed in TCPSockets.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 7);</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TCPSocket::set_timeout(100);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a8b3dcd672c499cee312d8f246b5d82df">TCPSocket::send</a>(&lt;random packet, size = 100&gt;;, 100);</code>.</li>
</ol>
<ol type="1">
<li>Repeat 5 times.<ol type="a">
<li>Record a time with millisecond precision.</li>
</ol>
<ol type="a">
<li>Call <code><a class="el" href="classTCPSocket.html#a1abab1c5e182d0d96f1c1ac53c60a7a0">TCPSocket::recv()</a></code>.</li>
</ol>
<ol type="a">
<li>Record a time with millisecond precision.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Repeat the test case 10 times.</li>
</ol>
<p><b>Expected result:</b></p>
<p>Each <code>send()</code> call returns 100.</p>
<p>Within each loop, one <code>recv()</code> may return the received packet size (100). Other calls return <code>NSAPI_ERROR_WOULD_BLOCK</code>.</p>
<p>When <code>NSAPI_ERROR_WOULD_BLOCK</code> is received, check the time consumed is more that 100 milliseconds but less than 200 milliseconds.</p>
<h2><a class="anchor" id="autotoc_md369"></a>
TCPSOCKET_SEND_TIMEOUT</h2>
<p><b>Description:</b></p>
<p>Repeatedly send small packets in a given time limit.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html">TCPSocket</a>:connect("echo.mbedcloudtesting.com", 9);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html">TCPSocket</a>:set_blocking(false);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html">TCPSocket</a>:send("hello", 5);</code>.</li>
</ol>
<ol type="1">
<li>Repeat 10 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect()</a></code> return <code>NSAPI_ERROR_OK</code>.</p>
<p>All <code>send()</code> calls return in less than 800 milliseconds.</p>
<h2><a class="anchor" id="autotoc_md370"></a>
TCPSOCKET_ENDPOINT_CLOSE</h2>
<p><b>Description:</b></p>
<p><a class="el" href="classTest.html">Test</a> whether you tolerate an endpoint closing the connection.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 13);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a1abab1c5e182d0d96f1c1ac53c60a7a0">TCPSocket::recv</a>(&lt;buffer&gt;, 30);</code>.</li>
</ol>
<ol type="1">
<li>Repeat until <code>recv()</code> returns 0.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classInternetSocket.html#a6b9cc41e4eea294476d223954929c7e7" title="defined(DOXYGEN_ONLY)">TCPSocket::close()</a>;</code>.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>Connect returns <code>NSAPI_ERROR_OK</code>.</p>
<p>The first <code>recv()</code> returns datetime string length (It is between 10 and 30 bytes).</p>
<p>The second <code>recv()</code> returns zero because the endpoint closed the connection. <code>close()</code> returns <code>NSAPI_ERROR_OK</code>.</p>
<h2><a class="anchor" id="autotoc_md371"></a>
TCPSOCKET_SETSOCKOPT_KEEPALIVE_VALID</h2>
<p><b>Description:</b></p>
<p><a class="el" href="classTest.html">Test</a> you can request setting valid TCP keepalive values.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>TCPSocket::setsockopt(keepalive, [0,1 or 7200]);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 9);</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TCPSocket::getsockopt(keepalive);</code>.</li>
</ol>
<p><b>Postconditions:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classInternetSocket.html#a6b9cc41e4eea294476d223954929c7e7" title="defined(DOXYGEN_ONLY)">TCPSocket::close()</a>;</code>.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code>TCPSocket::getsockopt(keepalive)</code> returns the same value as that set with <code><a class="el" href="classInternetSocket.html#a44d991807fbabdb65c365935035c110b">TCPSocket::setsockopt()</a></code> or <code>NSAPI_ERROR_UNSUPPORTED</code>.</p>
<h1><a class="anchor" id="autotoc_md372"></a>
Test cases for TLSSocket class</h1>
<h2><a class="anchor" id="autotoc_md373"></a>
TLSSOCKET_OPEN_DESTRUCT</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_DESTRUCT</code> for TLSSocket.</p>
<h2><a class="anchor" id="autotoc_md374"></a>
TLSSOCKET_OPEN_LIMIT</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_LIMIT</code> for TLSSocket.</p>
<h2><a class="anchor" id="autotoc_md375"></a>
TLSSOCKET_OPEN_TWICE</h2>
<p><b>Description:</b> Run <code>SOCKET_OPEN_TWICE</code> for TLSSocket.</p>
<h2><a class="anchor" id="autotoc_md376"></a>
TLSSOCKET_CONNECT_INVALID</h2>
<p><b>Description:</b> Run <code>SOCKET_CONNECT_INVALID</code> for TLSSocket.</p>
<h2><a class="anchor" id="autotoc_md377"></a>
TLSSOCKET_HANDSHAKE_INVALID</h2>
<p><b>Description:</b></p>
<p>Execute the TLS handshake by calling <code>TLSSocket::connect()</code>. The server must not match the certificate used by os.mbed.com.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create TLSSocket.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::open()</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::connect("os.mbed.com", 2009)</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::close()</code>.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code>TLSSocket::connect</code> must return an error.</p>
<h2><a class="anchor" id="autotoc_md378"></a>
TLSSOCKET_SEND_CLOSED</h2>
<p><b>Description:</b></p>
<p>Make an HTTP request to a closed socket.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create TLSSocket.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::open()</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::connect("echo.mbedcloudtesting.com", 2007)</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::close()</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::send("12345", 5)</code>.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code>TLSSocket::send</code> must return an error.</p>
<h2><a class="anchor" id="autotoc_md379"></a>
TLSSOCKET_SEND_REPEAT</h2>
<p><b>Description:</b> Run <code>SOCKET_SEND_REPEAT</code> for TLSSOCKET by using port number 2009.</p>
<h2><a class="anchor" id="autotoc_md380"></a>
TLSSOCKET_SEND_TIMEOUT</h2>
<p><b>Description:</b> Run <code>SOCKET_SEND_TIMEOUT</code> for TLSSOCKET by using port number 2009.</p>
<h2><a class="anchor" id="autotoc_md381"></a>
TLSSOCKET_SEND_UNCONNECTED</h2>
<p><b>Description:</b></p>
<p>Make an HTTP request to an unconnected socket.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create TLSSocket.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::open()</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::send("12345", 5)</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::connect("echo.mbedcloudtesting.com", 2007)</code>.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code>TLSSocket::send</code> must return an error.</p>
<h2><a class="anchor" id="autotoc_md382"></a>
TLSSOCKET_ECHOTEST</h2>
<p><b>Description:</b> Run <code>SOCKET_ECHOTEST</code> for TLSSOCKET by using port number 2007.</p>
<h2><a class="anchor" id="autotoc_md383"></a>
TLSSOCKET_ECHOTEST_NONBLOCK</h2>
<p><b>Description:</b> Run <code>SOCKET_ECHOTEST_NONBLOCK</code> for TLSSOCKET by using port number 2007.</p>
<h2><a class="anchor" id="autotoc_md384"></a>
TLSSOCKET_ENDPOINT_CLOSE</h2>
<p><b>Description:</b> Run <code>SOCKET_ENDPOINT_CLOSE</code> for TLSSOCKET by using port number 2013.</p>
<h2><a class="anchor" id="autotoc_md385"></a>
TLSSOCKET_NO_CERT</h2>
<p><b>Description:</b></p>
<p>Verify TLS <a class="el" href="classSocket.html">Socket</a> fails to connect without a certificate.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Create TLSSocket, without adding a default certificate.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::open()</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TLSSocket::connect("echo.mbedcloudtesting.com", 2009)</code>.</li>
</ol>
<p><b>Expected result:</b></p>
<p><code>TLSSocket::connect</code> must return an error if the certificate is not present.</p>
<h2><a class="anchor" id="autotoc_md386"></a>
TLSSOCKET_RECV_TIMEOUT</h2>
<p><b>Description:</b></p>
<p>Run <code>TCPSOCKET_RECV_TIMEOUT</code> for TLSSOCKET by using port number 2007.</p>
<h2><a class="anchor" id="autotoc_md387"></a>
TLSSOCKET_SIMULTANEOUS_TEST</h2>
<p><b>Description:</b></p>
<p>Simultaneously send packets to echo server on two opened sockets and read incoming packets back. Verify TLS sockets open and operate simultaneously.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li>TLSSockets are open and one additional thread has been created.</li>
</ol>
<ol type="1">
<li>Both threads get their own socket instance.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>(Simultaneously with step 2), on the main thread:<ol type="a">
<li>Call <code>TLSSocket::connect("echo.mbedcloudtesting.com", 2007);</code>.</li>
</ol>
<ol type="a">
<li>Call <code>TLSSocket::send(&lt;random packet, size = loop index&gt;, &lt;loop index&gt;);</code>.<ul>
<li>If less than &lt;loop index&gt; is returned, size = sent bytes.</li>
</ul>
</li>
</ol>
<ol type="a">
<li>Call <code>TLSSocket::recv(buffer, &lt;size&gt;);</code>.</li>
</ol>
<ol type="a">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="a">
<li>Repeat 100 times.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>(Simultaneously with step 1), on the additional thread:<ol type="a">
<li>Call <code>TLSSocket::connect("echo.mbedcloudtesting.com", 2007);</code>.</li>
</ol>
<ol type="a">
<li>Call &lsquo;TLSSocket::send(&lt;random packet, size = loop index&gt;, &lt;loop index&gt;);&rsquo;.<ul>
<li>If less than &lt;loop index&gt; is returned, size = sent bytes.</li>
</ul>
</li>
</ol>
<ol type="a">
<li>Call <code>TLSSocket::recv(buffer, &lt;size&gt;);</code>.</li>
</ol>
<ol type="a">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="a">
<li>Repeat 100 times.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Wait for the additional thread to end.</li>
</ol>
<ol type="1">
<li>Close and destroy the sockets.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>send()</code> calls return the packet size or less. All <code>recv()</code> calls on the main thread return the same sized packet that was sent with the same content. All <code>recv()</code> calls on the additional thread return the valid daytime string.</p>
<h1><a class="anchor" id="autotoc_md388"></a>
Performance tests</h1>
<h2><a class="anchor" id="autotoc_md389"></a>
UDPSOCKET_ECHOTEST_BURST</h2>
<p><b>Description:</b></p>
<p>Send a burst of packets to the echo server and read incoming packets back.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classUDPSocket.html">UDPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 100&gt;, 100);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 200&gt;, 200);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 300&gt;, 300);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 120&gt;, 120);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 500&gt;, 500);</code>.</li>
</ol>
<ol type="1">
<li>Wait for incoming packets for five seconds.</li>
</ol>
<ol type="1">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="1">
<li>Allow packet reordering.</li>
</ol>
<ol type="1">
<li>Repeat 100 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>sendto()</code> calls return the packet size.</p>
<p>All <code>recvfrom()</code> calls return the same sized packet that was sent with same content. Allow packet reordering.</p>
<p>Calculate packet loss rate. The maximum tolerated packet loss rate is 30%.</p>
<p>The number of successful rounds is higher than 70.</p>
<h2><a class="anchor" id="autotoc_md390"></a>
UDPSOCKET_ECHOTEST_BURST_NONBLOCK</h2>
<p><b>Description:</b></p>
<p>Send a burst of packets to the echo server and read incoming packets back. Use <a class="el" href="classSocket.html">Socket</a> in nonblocking mode.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classUDPSocket.html">UDPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>UDPSocket::set_blocking(false)</code>.</li>
</ol>
<ol type="1">
<li>Register event handler with <code><a class="el" href="classInternetSocket.html#a73f4a6bc3257295800883f03994b7fb8">UDPSocket::sigio()</a></code>.</li>
</ol>
<ol type="1">
<li>Create another thread that constantly waits signal from sigio() handler.</li>
</ol>
<ol type="1">
<li>When received, try <code><a class="el" href="classInternetDatagramSocket.html#a76fca153b4fb769cba3aa2035f84a3e6">UDPSocket::recvfrom()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 100&gt;, 100);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 200&gt;, 200);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 300&gt;, 300);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 120&gt;, 120);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classUDPSocket.html">UDPSocket</a>:sendto("echo.mbedcloudtesting.com", 7, &lt;random packet, size = 500&gt;, 500);</code>.</li>
</ol>
<ol type="1">
<li>Wait for incoming packets for five seconds.</li>
</ol>
<ol type="1">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="1">
<li>Allow packet reordering.</li>
</ol>
<ol type="1">
<li>Repeat 100 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>sendto()</code> calls return the packet size.</p>
<p>All <code>recvfrom()</code> calls return the same sized packet that was sent with the same content. Allow packet reordering.</p>
<p>Calculate packet loss rate. The maximum tolerated packet loss rate is 30%.</p>
<p>The number of successful rounds is higher than 70.</p>
<h2><a class="anchor" id="autotoc_md391"></a>
TCPSOCKET_ECHOTEST_BURST</h2>
<p><b>Description:</b></p>
<p>Send a burst of packets to the echo server and read incoming packets back.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 7);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a8b3dcd672c499cee312d8f246b5d82df">TCPSocket::send</a>(&lt;random packet, size = 100&gt;, 100);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a8b3dcd672c499cee312d8f246b5d82df">TCPSocket::send</a>(&lt;random packet, size = 200&gt;, 200);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a8b3dcd672c499cee312d8f246b5d82df">TCPSocket::send</a>(&lt;random packet, size = 300&gt;, 300);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a8b3dcd672c499cee312d8f246b5d82df">TCPSocket::send</a>(&lt;random packet, size = 120&gt;, 120);</code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#a8b3dcd672c499cee312d8f246b5d82df">TCPSocket::send</a>(&lt;random packet, size = 500&gt;, 500);</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TCPSocket::recv(buf, 1220)</code>.</li>
</ol>
<ol type="1">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="1">
<li>Repeat 100 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>send()</code> calls return the packet size.</p>
<p>NOTE: This is stream, so <code>recv()</code> might return less data than requested. Keep calling <code>recv()</code> with the remaining size until all data you have sent is returned.</p>
<p>Consecutive calls to <code>recv()</code> return all the data that has been sent. The total amount of returned data must match 1220.</p>
<h2><a class="anchor" id="autotoc_md392"></a>
TCPSOCKET_ECHOTEST_BURST_NONBLOCK</h2>
<p><b>Description:</b></p>
<p>Send a burst of packets to the echo server and read incoming packets back. Use <a class="el" href="classSocket.html">Socket</a> in nonblocking mode.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Register event handler with <code><a class="el" href="classInternetSocket.html#a73f4a6bc3257295800883f03994b7fb8">TCPSocket::sigio()</a></code>.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 7);</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TCPSocket::set_blocking(false)</code>.</li>
</ol>
<ol type="1">
<li>Create another thread that constantly waits for a signal from <code>sigio()</code> handler.</li>
</ol>
<ol type="1">
<li>When it's received, try <code><a class="el" href="classTCPSocket.html#a1abab1c5e182d0d96f1c1ac53c60a7a0">TCPSocket::recv()</a></code>.</li>
</ol>
<ol type="1">
<li>For randomly generated packets sized 100, 200, 300, 120 and 500:<ol type="a">
<li>Call <code>TCPSocket::send(packet, size);</code>.</li>
</ol>
<ol type="a">
<li>If less than size is sent, repeat with remaining.</li>
</ol>
<ol type="a">
<li>If <code>NSAPI_ERROR_WOULD_BLOCK</code> returned, wait for next <code>sigio()</code>.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Wait for incoming packets for five seconds.</li>
</ol>
<ol type="1">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="1">
<li>Allow <code>recv()</code> to return smaller pieces.</li>
</ol>
<ol type="1">
<li>Repeat 100 times.</li>
</ol>
<ol type="1">
<li>Destroy the socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All <code>send()</code> calls return <code>NSAPI_ERROR_WOULD_BLOCK</code> or a size less than or equal to what has been requested.</p>
<p>All <code>recv()</code> calls return a value less than or equal to what has been sent. With consecutive calls, the sizes should match.</p>
<p>When <code>recv()</code> returns <code>NSAPI_ERROR_WOULD_BLOCK</code>, wait for the next <code>sigio()</code> event. No other error codes are allowed.</p>
<h2><a class="anchor" id="autotoc_md393"></a>
TCPSOCKET_RECV_100K</h2>
<p><b>Description:</b></p>
<p>Download 100kB of data.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 19);</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TCPSocket::recv(buffer, 100);</code>.</li>
</ol>
<ol type="1">
<li>Verify input according to a known pattern.</li>
</ol>
<ol type="1">
<li>Loop until 100kB of data received.</li>
</ol>
<ol type="1">
<li>Close socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>Each <code>recv()</code> call returns 100 bytes of data or fewer. No errors are returned.</p>
<p>Measure time taken for receiving and report speed.</p>
<h2><a class="anchor" id="autotoc_md394"></a>
TCPSOCKET_RECV_100K_NONBLOCK</h2>
<p><b>Description:</b></p>
<p>Download 100kB of data.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li><a class="el" href="classTCPSocket.html">TCPSocket</a> is open.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 19);</code>.</li>
</ol>
<ol type="1">
<li>Call <code>TCPSocket::set_blocking(false)</code>.</li>
</ol>
<ol type="1">
<li>Create another thread that constantly waits for a signal from <code>sigio()</code> handler.</li>
</ol>
<ol type="1">
<li>When it's received, try <code><a class="el" href="classTCPSocket.html#a1abab1c5e182d0d96f1c1ac53c60a7a0">TCPSocket::recv()</a></code>.<ol type="a">
<li>Call <code>TCPSocket::recv(buffer, 100);</code>.</li>
</ol>
<ol type="a">
<li>Verify input according to a known pattern.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Wait until 100kB of data received.</li>
</ol>
<ol type="1">
<li>Close socket.</li>
</ol>
<p><b>Expected result:</b></p>
<p>Each <code>recv()</code> call returns 100 bytes of data or less or <code>NSAPI_ERROR_WOULD_BLOCK</code>, in which case thread waits for another <code>sigio()</code>. No errors are returned.</p>
<p>Measure time taken for receiving and report speed.</p>
<h2><a class="anchor" id="autotoc_md395"></a>
TCPSOCKET_THREAD_PER_SOCKET_SAFETY</h2>
<p><b>Description:</b></p>
<p>Run two threads that both exercise the underlying stack and driver through a dedicated socket.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface and stack are initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<ol type="1">
<li>Two TCPSockets are open, and one additional thread has been created.</li>
</ol>
<ol type="1">
<li>Both threads get their own socket instance.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code><a class="el" href="classTCPSocket.html#aa66e671c88998ae8981fb6e0edc97241">TCPSocket::connect</a>("echo.mbedcloudtesting.com", 7)</code> in both threads - in the main thread executing the test case and on the additional one.<ul>
<li>(Simultaneously with the next step) on the main thread:<ol type="a">
<li>For randomly generated packets, sized 1001, 901, 801,...,101,1 do<ol type="i">
<li>Call <code>TCPSocket::send(packet, size);</code>.</li>
</ol>
<ol type="i">
<li>Verify incoming content was the same that was sent.</li>
</ol>
<ol type="i">
<li>Allow <code>recv()</code> to return smaller pieces.</li>
</ol>
</li>
</ol>
</li>
<li>(Simultaneously with the earlier step) on the additional thread:<ol type="a">
<li>For randomly generated packets, sized 10:<ol type="i">
<li>Call <code>TCPSocket::send(packet, size);</code>.</li>
</ol>
<ol type="i">
<li>Verify incoming content is the same as sent content.</li>
</ol>
<ol type="i">
<li>Allow <code>recv()</code> to return smaller pieces.</li>
</ol>
<ol type="i">
<li>Stop the thread if inconsistencies are found, and report it to main thread.</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Kill the additional thread.</li>
</ol>
<ol type="1">
<li>Close and destroy the sockets.</li>
</ol>
<p><b>Expected result:</b></p>
<p>The echo server returns data to both threads and received data matches to send data. The additional thread isn't stopped prematurely.</p>
<h1><a class="anchor" id="autotoc_md396"></a>
Test cases for DNS class</h1>
<h2><a class="anchor" id="autotoc_md397"></a>
ASYNCHRONOUS_DNS</h2>
<p><b>Description:</b></p>
<p>Verify the basic functionality of asynchronous <a class="el" href="classDNS.html">DNS</a>. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code> with a valid host name, and verify the result.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> with a valid host name and a callback.</li>
</ol>
<ol type="1">
<li>Verify the callback is called with correct parameters.</li>
</ol>
<p><b>Expected result:</b></p>
<p><a class="el" href="classCallback.html">Callback</a> is called with <code>NSAPI_ERROR_OK</code> and IP address.</p>
<h2><a class="anchor" id="autotoc_md398"></a>
ASYNCHRONOUS_DNS_SIMULTANEOUS</h2>
<p><b>Description:</b></p>
<p>Verify simultaneous asynchronous <a class="el" href="classDNS.html">DNS</a> queries work correctly. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code> 6 times with different host names. Wait for all requests to complete, and verify the result. The cache does not contain host names used in asynchronous request.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> 6 times with different host names. Host names are not found from the cache.</li>
</ol>
<ol type="1">
<li>Verify the last <code>gethostbyname_async()</code> operation is rejected because there is room only for five simultaneous operations.</li>
</ol>
<ol type="1">
<li>Verify the callback is called with correct parameters five times.</li>
</ol>
<p><b>Expected result:</b></p>
<p>The sixth <code>gethostbyname_async()</code> is rejected. <a class="el" href="classCallback.html">Callback</a> is called with <code>NSAPI_ERROR_OK</code> and IP address five times.</p>
<h2><a class="anchor" id="autotoc_md399"></a>
ASYNCHRONOUS_DNS_SIMULTANEOUS_CACHE</h2>
<p><b>Description:</b></p>
<p>Verify the caching of <a class="el" href="classDNS.html">DNS</a> results works correctly with simultaneous asynchronous <a class="el" href="classDNS.html">DNS</a> queries. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code> six times with different host names. Wait for all requests to complete, and verify the result. The cache contains at least one host name used in asynchronous request. You can achieve this, for example, by running the "Asynchronous DNS simultaneous" test before this test and using the same host names in this run.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> six times with different host names. At least one host name is found from cache.</li>
</ol>
<ol type="1">
<li>Verify that callback is called with correct parameters six times.</li>
</ol>
<p><b>Expected result:</b></p>
<p><a class="el" href="classCallback.html">Callback</a> is called with <code>NSAPI_ERROR_OK</code> and IP address six times.</p>
<h2><a class="anchor" id="autotoc_md400"></a>
ASYNCHRONOUS_DNS_CACHE</h2>
<p><b>Description:</b></p>
<p>Verify the caching of <a class="el" href="classDNS.html">DNS</a> results works correctly. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code> five times with the same host name and verify the result after each request. For the first request, the cache does not contain the host name. Verify the first request completes more slowly than the requests made after it (where the response is found from cache).</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> with a host name. For the first request, the host name is not found from cache.</li>
</ol>
<ol type="1">
<li>Verify the callback is called with correct parameters.</li>
</ol>
<ol type="1">
<li>Repeat the sequence four times using the same host name.</li>
</ol>
<ol type="1">
<li>For each request, calculate how long it takes for the <a class="el" href="classDNS.html">DNS</a> query to complete.</li>
</ol>
<p><b>Expected result:</b></p>
<p>The callback is called with <code>NSAPI_ERROR_OK</code> and IP address five times. The first request is complete before the requests made after it (where the response is found from cache).</p>
<h2><a class="anchor" id="autotoc_md401"></a>
ASYNCHRONOUS_DNS_NON_ASYNC_AND_ASYNC</h2>
<p><b>Description:</b></p>
<p>Verify synchronous (in other words, blocking) <a class="el" href="classDNS.html">DNS</a> queries and asynchronous (in other words, nonblocking) queries work at the same time. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code>. Right after that, make six synchronous <code><a class="el" href="classNetworkInterface.html#a64cebbbe94d1453474d75555fe9b37bb">NetworkInterface::gethostbyname()</a></code> calls with different host names.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> with a host name. The host name is not found from cache.</li>
</ol>
<ol type="1">
<li>Call <code>gethostbyname()</code> six times with different host names (none of the names are the same as that in step 1).</li>
</ol>
<ol type="1">
<li>Verify each <code>gethostbyname()</code> returns success.</li>
</ol>
<ol type="1">
<li>Verify the asynchronous callback is called with correct parameters.</li>
</ol>
<p><b>Expected result:</b></p>
<p>All operations return <code>NSAPI_ERROR_OK</code> and IP address.</p>
<h2><a class="anchor" id="autotoc_md402"></a>
ASYNCHRONOUS_DNS_CANCEL</h2>
<p><b>Description:</b></p>
<p>Verify the asynchronous <a class="el" href="classDNS.html">DNS</a> query cancel works correctly. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code> six times with different host names. The cache contains three host names used in requests. You can achieve this, for example, by running the "Asynchronous DNS synchronous and asynchronous" test before this test and using the same host names in this run. For each request that was given an unique ID, call cancel. Verify the callback is not called for canceled requests.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> six times with different host names. The cache contains a maximum of three host names used in requests.</li>
</ol>
<ol type="1">
<li>Call <code>gethostbyname_async_cancel()</code> for each request that was given an unique ID.</li>
</ol>
<ol type="1">
<li>Verify that for canceled requests, callback is not called.</li>
</ol>
<ol type="1">
<li>Verify that for other requests, callback is called.</li>
</ol>
<p><b>Expected result:</b></p>
<p><a class="el" href="classCallback.html">Callback</a> is called only for requests that were not canceled.</p>
<h2><a class="anchor" id="autotoc_md403"></a>
ASYNCHRONOUS_DNS_EXTERNAL_EVENT_QUEUE</h2>
<p><b>Description:</b></p>
<p>Verify that providing an external event queue works correctly. Define a thread and an event queue running on it. Define a <a class="el" href="classDNS.html">DNS</a> call in callback function that uses the event queue (call_in_callback_cb_t). Enable external event queue. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code> six times with different host names.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Define a thread and an event queue running on it.</li>
</ol>
<ol type="1">
<li>Define a <a class="el" href="classDNS.html">DNS</a> call in a callback function that uses the event queue (call_in_callback_cb_t).</li>
</ol>
<ol type="1">
<li>Start thread and event queue.</li>
</ol>
<ol type="1">
<li>Set <a class="el" href="classDNS.html">DNS</a> callback function using the <code>nsapi_dns_call_in_set()</code> call.</li>
</ol>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> six times with different host names. The host names are not found from cache.</li>
</ol>
<ol type="1">
<li>Verify the last <code>gethostbyname_async()</code> operation is rejected because there is room only for five simultaneous operations.</li>
</ol>
<ol type="1">
<li>Verify the callback is called with correct parameters five times.</li>
</ol>
<ol type="1">
<li>Restore the default <a class="el" href="classDNS.html">DNS</a> callback function using the <code>nsapi_dns_call_in_set()</code> call.</li>
</ol>
<p><b>Expected result:</b></p>
<p>The sixth <code>gethostbyname_async()</code> is rejected. <a class="el" href="classCallback.html">Callback</a> is called with <code>NSAPI_ERROR_OK</code> and IP address five times.</p>
<h2><a class="anchor" id="autotoc_md404"></a>
ASYNCHRONOUS_DNS_INVALID_HOST</h2>
<p><b>Description:</b></p>
<p>Verify the <a class="el" href="classDNS.html">DNS</a> failure error is provided for invalid hosts. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code> six times with different host names. The first, third and fifth host names are invalid.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> six times with different host names. Host names are not found from cache. The first, third and fifth host names are invalid.</li>
</ol>
<ol type="1">
<li>Verify the last <code>gethostbyname_async()</code> operation is rejected because there is room only for five simultaneous operations.</li>
</ol>
<ol type="1">
<li>Verify the callback is called with correct parameters five times.</li>
</ol>
<p><b>Expected result:</b></p>
<p>The sixth <code>gethostbyname_async()</code> is rejected. <a class="el" href="classCallback.html">Callback</a> is called with <code>NSAPI_ERROR_DNS_FAILURE</code> for the first, third and fifth host names. <a class="el" href="classCallback.html">Callback</a> is called with <code>NSAPI_ERROR_OK</code> and IP address for the second and fourth host names.</p>
<h2><a class="anchor" id="autotoc_md405"></a>
ASYNCHRONOUS_DNS_TIMEOUTS</h2>
<p><b>Description:</b></p>
<p><a class="el" href="classTest.html">Test</a> <a class="el" href="classDNS.html">DNS</a> timeouts using an external event queue that is modified to time out the events faster than the standard event queue. In this test, the event queue does not delay events; instead, it handles those immediately. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code> six times with different host names. All or some of the request time out, and the timeout return value is returned.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Define a thread and an event queue running on it.</li>
</ol>
<ol type="1">
<li>Define a <a class="el" href="classDNS.html">DNS</a> call in callback function that uses the event queue (call_in_callback_cb_t). The callback function does not delay callbacks; instead it handles those immediately.</li>
</ol>
<ol type="1">
<li>Start thread and event queue.</li>
</ol>
<ol type="1">
<li>Set <a class="el" href="classDNS.html">DNS</a> callback function using the <code>nsapi_dns_call_in_set()</code> call.</li>
</ol>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> six times with a different host names. Host names are not found from cache.</li>
</ol>
<ol type="1">
<li>Verify the last <code>gethostbyname_async()</code> operation is rejected because there is room only for five simultaneous operations.</li>
</ol>
<ol type="1">
<li>Verify the callback is called with correct parameters five times.</li>
</ol>
<p><b>Expected result:</b></p>
<p>The sixth <code>gethostbyname_async()</code> is rejected. At least for one operation, the callback is called with the <code>NSAPI_ERROR_TIMEOUT</code> value.</p>
<h2><a class="anchor" id="autotoc_md406"></a>
ASYNCHRONOUS_DNS_SIMULTANEOUS_REPEAT</h2>
<p><b>Description:</b></p>
<p>Verify the simultaneous asynchronous <a class="el" href="classDNS.html">DNS</a> queries work correctly when repeated in sequence. Call <code><a class="el" href="classNetworkInterface.html#a16b40661a2159338f20b90dfdf675c78">NetworkInterface::gethostbyname_async()</a></code> five times with different host names. Wait for all requests to complete, and verify the result. Repeat the procedure 100 times.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname_async()</code> five times with different host names, providing a callback to be called when the operation completes.</li>
</ol>
<ol type="1">
<li>Verify the callback is called with correct parameters five times for the first operation.</li>
</ol>
<ol type="1">
<li>Repeat steps 1-2 100 times.</li>
</ol>
<p><b>Expected result:</b></p>
<p>A callback, registered for <code>gethostbyname_async()</code>, is called with <code>NSAPI_ERROR_OK</code> and an IP address five times for every one of 100 repetitions of the test.</p>
<h2><a class="anchor" id="autotoc_md407"></a>
SYNCHRONOUS_DNS</h2>
<p><b>Description:</b></p>
<p>Verify the basic functionality of synchronous <a class="el" href="classDNS.html">DNS</a>. Call <code><a class="el" href="classNetworkInterface.html#a64cebbbe94d1453474d75555fe9b37bb">NetworkInterface::gethostbyname()</a></code> with a valid host name, and verify the result.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname()</code> with a valid host name.</li>
</ol>
<ol type="1">
<li>Verify the address was resolved and the return value was valid.</li>
</ol>
<p><b>Expected result:</b></p>
<p>Return value is <code>NSAPI_ERROR_OK</code> and IP address is obtained from the function call.</p>
<h2><a class="anchor" id="autotoc_md408"></a>
SYNCHRONOUS_DNS_MULTIPLE</h2>
<p><b>Description:</b></p>
<p>Verify the basic functionality of synchronous <a class="el" href="classDNS.html">DNS</a>. Call <code><a class="el" href="classNetworkInterface.html#a64cebbbe94d1453474d75555fe9b37bb">NetworkInterface::gethostbyname()</a></code> with a list of six host names, and verify the result.</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname()</code> with a list of six host names.</li>
</ol>
<ol type="1">
<li>Verify each of the addresses was resolved and the return value was valid.</li>
</ol>
<p><b>Expected result:</b></p>
<p>Return value is <code>NSAPI_ERROR_OK</code> and IP addresses are obtained from the function call.</p>
<h2><a class="anchor" id="autotoc_md409"></a>
SYNCHRONOUS_DNS_CACHE</h2>
<p><b>Description:</b></p>
<p>Verify the caching of <a class="el" href="classDNS.html">DNS</a> results works correctly. Call <code><a class="el" href="classNetworkInterface.html#a64cebbbe94d1453474d75555fe9b37bb">NetworkInterface::gethostbyname()</a></code> five times with the same host name, and verify the result after each request. For the first request, the cache does not contain the host name. Verify the first request completes before the requests made after it (where the response is found from cache).</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname()</code> with a host name. For the first request, the host name is not found in cache, and an error is returned.</li>
</ol>
<ol type="1">
<li>Verify the address was resolved and the return value was valid.</li>
</ol>
<ol type="1">
<li>Repeat the sequence four times using the same host name.</li>
</ol>
<ol type="1">
<li>For each request, calculate how long it takes the <a class="el" href="classDNS.html">DNS</a> query to complete.</li>
</ol>
<p><b>Expected result:</b></p>
<p>The return value is <code>NSAPI_ERROR_OK</code>, and the IP address is obtained from the function call five times. The first request completes before the requests made after it (where the response is found from cache).</p>
<h2><a class="anchor" id="autotoc_md410"></a>
SYNCHRONOUS_DNS_INVALID_HOST</h2>
<p><b>Description:</b></p>
<p>Verify the <a class="el" href="classDNS.html">DNS</a> failure error is provided for invalid hosts. Call <code><a class="el" href="classNetworkInterface.html#a64cebbbe94d1453474d75555fe9b37bb">NetworkInterface::gethostbyname()</a></code> six times with different host names. The first, third and fifth host names are invalid (for example by adding an incorrect suffix, such as "google.com_invalid").</p>
<p><b>Preconditions:</b></p>
<ol type="1">
<li>Network interface is initialized.</li>
</ol>
<ol type="1">
<li>Network connection is up.</li>
</ol>
<p><b><a class="el" href="classTest.html">Test</a> steps:</b></p>
<ol type="1">
<li>Call <code>gethostbyname()</code> six times with different host names. Host names are not found from cache. The first, third and fifth host names are invalid.</li>
</ol>
<ol type="1">
<li>Verify the return value was valid and for valid hostnames the address was resolved six times.</li>
</ol>
<p><b>Expected result:</b></p>
<p>The return value is <code>NSAPI_ERROR_DNS_FAILURE</code> for the first, third and fifth host names, which were invalidated at the beginning of the test. The return value is <code>NSAPI_ERROR_OK</code>, and the IP address is obtained for the second and fourth host names, which were valid.</p>
<h1><a class="anchor" id="autotoc_md411"></a>
Subset for driver test</h1>
<h2><a class="anchor" id="autotoc_md412"></a>
For physical layer driver (emac, PPP):</h2>
<ul>
<li>TCPSOCKET_ECHOTEST.</li>
<li>TCPSOCKET_ECHOTEST_BURST.</li>
<li>TCPSOCKET_ECHOTEST_BURST_NONBLOCK.</li>
<li>TCPSOCKET_ECHOTEST_NONBLOCK.</li>
<li>TCPSOCKET_RECV_100K.</li>
<li>TCPSOCKET_RECV_100K_NONBLOCK.</li>
<li>TCPSOCKET_RECV_TIMEOUT.</li>
<li>TCPSOCKET_SEND_REPEAT.</li>
<li>UDPSOCKET_BIND_SENDTO.</li>
<li>UDPSOCKET_ECHOTEST.</li>
<li>UDPSOCKET_ECHOTEST_NONBLOCK.</li>
<li>UDPSOCKET_RECV_TIMEOUT.</li>
<li>UDPSOCKET_SENDTO_INVALID.</li>
<li>UDPSOCKET_SENDTO_REPEAT.</li>
<li>UDPSOCKET_SENDTO_TIMEOUT.</li>
</ul>
<h2><a class="anchor" id="autotoc_md413"></a>
For socket layer driver (AT-driven, external IP stack):</h2>
<p>All <a class="el" href="classSocket.html">Socket</a>, <a class="el" href="classUDPSocket.html">UDPSocket</a>, <a class="el" href="classTCPSocket.html">TCPSocket</a> and TLSSocket test cases. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5fdebfbd0a4b5643a5e85bf3c8b1558b.html">mbed-os</a></li><li class="navelem"><a class="el" href="dir_456207283565120b441ff9733579e7b8.html">connectivity</a></li><li class="navelem"><a class="el" href="dir_cb5af92455080ed55b05484cdba3a725.html">netsocket</a></li><li class="navelem"><a class="el" href="dir_8abe74aa74d44b6a1d0b60b5e02914e9.html">tests</a></li><li class="navelem"><a class="el" href="dir_1482edad8fd315ce7acd1a9c633fdb71.html">TESTS</a></li><li class="navelem"><a class="el" href="dir_b01f97f01f75e114367267730950ea9b.html">netsocket</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
