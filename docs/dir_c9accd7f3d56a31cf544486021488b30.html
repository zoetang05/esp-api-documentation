<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: /home/zoe/Mbed Programs/esp_code/mbed-os/events Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_c9accd7f3d56a31cf544486021488b30.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">events Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_bbeacc610e3bf4d9c98eaaec178d0032.html">source</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <code>mbed-events</code> library provides a flexible queue for scheduling events.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">#include &quot;mbed_events.h&quot;</div>
<div class="line">#include &lt;stdio.h&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // creates a queue with the default size</div>
<div class="line">    EventQueue queue;</div>
<div class="line"> </div>
<div class="line">    // events are simple callbacks</div>
<div class="line">    queue.call(printf, &quot;called immediately\n&quot;);</div>
<div class="line">    queue.call_in(2000, printf, &quot;called in 2 seconds\n&quot;);</div>
<div class="line">    queue.call_every(1000, printf, &quot;called every 1 seconds\n&quot;);</div>
<div class="line"> </div>
<div class="line">    // events are executed by the dispatch method</div>
<div class="line">    queue.dispatch();</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can use the <code>mbed-events library</code> as a normal event loop, or you can background it on a single hardware timer or even another event loop. It is both thread and IRQ safe and provides functions for easily composing independent event queues.</p>
<p>The <code>mbed-events</code> library can act as a drop-in scheduler, provide synchronization between multiple threads or act as a mechanism for moving events out of interrupt contexts.</p>
<h2><a class="anchor" id="autotoc_md672"></a>
Usage</h2>
<p>The core of the <code>mbed-events library</code> is the <a href="EventQueue.h">EventQueue</a> class, which represents a single event queue. The <code>EventQueue::dispatch</code> function runs the queue, providing the context for executing events.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">// Creates an event queue enough buffer space for 32 Callbacks. This</div>
<div class="line">// is the default if no argument was provided. Alternatively the size</div>
<div class="line">// can just be specified in bytes.</div>
<div class="line">EventQueue queue(32*EVENTS_EVENT_SIZE);</div>
<div class="line"> </div>
<div class="line">// Events can be posted to the underlying event queue with dynamic</div>
<div class="line">// context allocated from the specified buffer</div>
<div class="line">queue.call(printf, &quot;hello %d %d %d %d\n&quot;, 1, 2, 3, 4);</div>
<div class="line">queue.call(&amp;serial, &amp;Serial::printf, &quot;hi\n&quot;);</div>
<div class="line"> </div>
<div class="line">// The dispatch function provides the context for the running the queue</div>
<div class="line">// and can take a millisecond timeout to run for a fixed time or to just</div>
<div class="line">// dispatch any pending events</div>
<div class="line">queue.dispatch();</div>
</div><!-- fragment --><p>The EventQueue class provides several call functions for posting events to the underlying event queue. The call functions are thread and IRQ safe, don't need the underlying loop to be running and provide a mechanism for moving events out of interrupt contexts.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">// Simple call function registers events to be called as soon as possible</div>
<div class="line">queue.call(doit);</div>
<div class="line">queue.call(printf, &quot;called immediately\n&quot;);</div>
<div class="line"> </div>
<div class="line">// The call_in function registers events to be called after a delay</div>
<div class="line">// specified in milliseconds</div>
<div class="line">queue.call_in(2000, doit_in_two_seconds);</div>
<div class="line">queue.call_in(300, printf, &quot;called in 0.3 seconds\n&quot;);</div>
<div class="line"> </div>
<div class="line">// The call_every function registers events to be called repeatedly</div>
<div class="line">// with a period specified in milliseconds</div>
<div class="line">queue.call_every(2000, doit_every_two_seconds);</div>
<div class="line">queue.call_every(400, printf, &quot;called every 0.4 seconds\n&quot;);</div>
</div><!-- fragment --><p>The call functions return an ID that uniquely represents the event in the the event queue. You can pass this ID to <code>EventQueue::cancel</code> to cancel an in-flight event prior to dispatch.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">// The event id uniquely represents the event in the queue</div>
<div class="line">int id = queue.call_in(100, printf, &quot;will this work?\n&quot;);</div>
<div class="line"> </div>
<div class="line">// If there was not enough memory necessary to allocate the event,</div>
<div class="line">// an id of 0 is returned from the call functions</div>
<div class="line">if (id) {</div>
<div class="line">    error(&quot;oh no!&quot;);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Events can be cancelled as long as they have not been dispatched. If the</div>
<div class="line">// event has already expired, cancel may have negative side-effects.</div>
<div class="line">queue.cancel(id);</div>
</div><!-- fragment --><p>For a more detailed control of event dispatch, you can manually instantiate and configure the <code>Event</code> class. An <code>Event</code> represents an event as a C++ style function object, and you can directly pass it to other APIs that expect a callback.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">// Creates an event bound to the specified event queue</div>
<div class="line">EventQueue queue;</div>
<div class="line">Event&lt;void()&gt; event(&amp;queue, doit);</div>
<div class="line"> </div>
<div class="line">// The event can be manually configured for special timing requirements</div>
<div class="line">// specified in milliseconds</div>
<div class="line">event.delay(10);</div>
<div class="line">event.period(10000);</div>
<div class="line"> </div>
<div class="line">// Posted events are dispatched in the context of the queue&#39;s</div>
<div class="line">// dispatch function</div>
<div class="line">queue.dispatch();</div>
<div class="line"> </div>
<div class="line">// Events can also pass arguments to the underlying callback when both</div>
<div class="line">// initially constructed and posted.</div>
<div class="line">Event&lt;void(int, int)&gt; event(&amp;queue, printf, &quot;received %d and %d\n&quot;);</div>
<div class="line"> </div>
<div class="line">// Events can be posted multiple times and enqueue gracefully until</div>
<div class="line">// the dispatch function is called.</div>
<div class="line">event.post(1, 2);</div>
<div class="line">event.post(3, 4);</div>
<div class="line">event.post(5, 6);</div>
<div class="line"> </div>
<div class="line">queue.dispatch();</div>
</div><!-- fragment --><p>Event queues easily align with module boundaries, where internal state can be implicitly synchronized through event dispatch. Multiple modules can use independent event queues but still be composed through the <code>EventQueue::chain</code> function.</p>
<div class="fragment"><div class="line"> cpp</div>
<div class="line">// Create some event queues with pending events</div>
<div class="line">EventQueue a;</div>
<div class="line">a.call(printf, &quot;hello from a!\n&quot;);</div>
<div class="line"> </div>
<div class="line">EventQueue b;</div>
<div class="line">b.call(printf, &quot;hello from b!\n&quot;);</div>
<div class="line"> </div>
<div class="line">EventQueue c;</div>
<div class="line">c.call(printf, &quot;hello from c!\n&quot;);</div>
<div class="line"> </div>
<div class="line">// Chain c and b onto a&#39;s event queue. Both c and b will be dispatched</div>
<div class="line">// in the context of a&#39;s dispatch function.</div>
<div class="line">c.chain(&amp;a);</div>
<div class="line">b.chain(&amp;a);</div>
<div class="line"> </div>
<div class="line">// Dispatching a will in turn dispatch b and c, printing hello from</div>
<div class="line">// all three queues</div>
<div class="line">a.dispatch();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md673"></a>
Underlying C API</h1>
<p>The <code>mbed-events</code> C++ library is the recommended library for scheduling events. However, for occasions where C++ cannot be used for a project (e.g bare metal), the underlying C API <code>equeue</code> used by <code>mbed-events</code> can be accessed directly.</p>
<p>The <code>equeue</code> library is designed as a simple but powerful library for scheduling events on composable queues.</p>
<div class="fragment"><div class="line"> c</div>
<div class="line">#include &quot;equeue.h&quot;</div>
<div class="line">#include &lt;stdio.h&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // creates a queue with space for 32 basic events</div>
<div class="line">    equeue_t queue;</div>
<div class="line">    equeue_create(&amp;queue, 32*EQUEUE_EVENT_SIZE);</div>
<div class="line"> </div>
<div class="line">    // events can be simple callbacks</div>
<div class="line">    equeue_call(&amp;queue, print, &quot;called immediately&quot;);</div>
<div class="line">    equeue_call_in(&amp;queue, 2000, print, &quot;called in 2 seconds&quot;);</div>
<div class="line">    equeue_call_every(&amp;queue, 1000, print, &quot;called every 1 seconds&quot;);</div>
<div class="line"> </div>
<div class="line">    // events are executed in equeue_dispatch</div>
<div class="line">    equeue_dispatch(&amp;queue, 3000);</div>
<div class="line"> </div>
<div class="line">    print(&quot;called after 3 seconds&quot;);</div>
<div class="line"> </div>
<div class="line">    equeue_destroy(&amp;queue);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The equeue library can be used as a normal event loop, or it can be backgrounded on a single hardware timer or even another event loop. It is both thread and irq safe, and provides functions for easily composing multiple queues.</p>
<p>The equeue library can act as a drop-in scheduler, provide synchronization between multiple threads, or just act as a mechanism for moving events out of interrupt contexts.</p>
<h1><a class="anchor" id="autotoc_md674"></a>
Documentation</h1>
<p>The in-depth documentation on specific functions can be found in <a href="include/events/equeue.h">equeue.h</a>.</p>
<p>The core of the equeue library is the <code>equeue_t</code> type which represents a single event queue, and the <code>equeue_dispatch</code> function which runs the equeue, providing the context for executing events.</p>
<p>On top of this, <code>equeue_call</code>, <code>equeue_call_in</code>, and <code>equeue_call_every</code> provide easy methods for posting events to execute in the context of the <code>equeue_dispatch</code> function.</p>
<div class="fragment"><div class="line"> c</div>
<div class="line">#include &quot;equeue.h&quot;</div>
<div class="line">#include &quot;game.h&quot;</div>
<div class="line"> </div>
<div class="line">equeue_t queue;</div>
<div class="line">struct game game;</div>
<div class="line"> </div>
<div class="line">// button_isr may be in interrupt context</div>
<div class="line">void button_isr(void) {</div>
<div class="line">    equeue_call(&amp;queue, game_button_update, &amp;game);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// a simple user-interface framework</div>
<div class="line">int main() {</div>
<div class="line">    equeue_create(&amp;queue, 4096);</div>
<div class="line">    game_create(&amp;game);</div>
<div class="line"> </div>
<div class="line">    // call game_screen_udpate at 60 Hz</div>
<div class="line">    equeue_call_every(&amp;queue, 1000/60, game_screen_update, &amp;game);</div>
<div class="line"> </div>
<div class="line">    // dispatch forever</div>
<div class="line">    equeue_dispatch(&amp;queue, -1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In addition to simple callbacks, an event can be manually allocated with <code>equeue_alloc</code> and posted with <code>equeue_post</code> to allow passing an arbitrary amount of context to the execution of the event. This memory is allocated out of the equeue's buffer, and dynamic memory can be completely avoided.</p>
<p>The equeue allocator is designed to minimize jitter in interrupt contexts as well as avoid memory fragmentation on small devices. The allocator achieves both constant-runtime and zero-fragmentation for fixed-size events, however grows linearly as the quantity of differently-sized allocations increases.</p>
<div class="fragment"><div class="line"> c</div>
<div class="line">#include &quot;equeue.h&quot;</div>
<div class="line"> </div>
<div class="line">equeue_t queue;</div>
<div class="line"> </div>
<div class="line">// arbitrary data can be moved to a different context</div>
<div class="line">int enet_consume(void *buffer, int size) {</div>
<div class="line">    if (size &gt; 512) {</div>
<div class="line">        size = 512;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    void *data = equeue_alloc(&amp;queue, 512);</div>
<div class="line">    memcpy(data, buffer, size);</div>
<div class="line">    equeue_post(&amp;queue, handle_data_elsewhere, data);</div>
<div class="line"> </div>
<div class="line">    return size;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Additionally, in-flight events can be cancelled with <code>equeue_cancel</code>. Events are given unique ids on post, allowing safe cancellation until dispatch.</p>
<div class="fragment"><div class="line"> c</div>
<div class="line">#include &quot;equeue.h&quot;</div>
<div class="line"> </div>
<div class="line">equeue_t queue;</div>
<div class="line">int sonar_value;</div>
<div class="line">int sonar_timeout_id;</div>
<div class="line"> </div>
<div class="line">void sonar_isr(int value) {</div>
<div class="line">    equeue_cancel(&amp;queue, sonar_timeout_id);</div>
<div class="line">    sonar_value = value;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void sonar_timeout(void *) {</div>
<div class="line">    sonar_value = -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void sonar_read(void) {</div>
<div class="line">    sonar_timeout_id = equeue_call_in(&amp;queue, 300, sonar_timeout, 0);</div>
<div class="line">    sonar_start();</div>
<div class="line">}</div>
</div><!-- fragment --><p>From an architectural standpoint, event queues easily align with module boundaries, where internal state can be implicitly synchronized through event dispatch.</p>
<p>On platforms where multiple threads are unavailable, multiple modules can use independent event queues and still be composed through the <code>equeue_chain</code> function.</p>
<div class="fragment"><div class="line"> c</div>
<div class="line">#include &quot;equeue.h&quot;</div>
<div class="line"> </div>
<div class="line">// run a simultaneous localization and mapping loop in one queue</div>
<div class="line">struct slam {</div>
<div class="line">    equeue_t queue;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void slam_create(struct slam *s, equeue_t *target) {</div>
<div class="line">    equeue_create(&amp;s-&gt;queue, 4096);</div>
<div class="line">    equeue_chain(&amp;s-&gt;queue, target);</div>
<div class="line">    equeue_call_every(&amp;s-&gt;queue, 100, slam_filter);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// run a sonar with it&#39;s own queue</div>
<div class="line">struct sonar {</div>
<div class="line">    equeue_t equeue;</div>
<div class="line">    struct slam *slam;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void sonar_create(struct sonar *s, equeue_t *target) {</div>
<div class="line">    equeue_create(&amp;s-&gt;queue, 64);</div>
<div class="line">    equeue_chain(&amp;s-&gt;queue, target);</div>
<div class="line">    equeue_call_in(&amp;s-&gt;queue, 5, sonar_update, s);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// all of the above queues can be combined into a single thread of execution</div>
<div class="line">int main() {</div>
<div class="line">    equeue_t queue;</div>
<div class="line">    equeue_create(&amp;queue, 1024);</div>
<div class="line"> </div>
<div class="line">    struct sonar s1, s2, s3;</div>
<div class="line">    sonar_create(&amp;s1, &amp;queue);</div>
<div class="line">    sonar_create(&amp;s2, &amp;queue);</div>
<div class="line">    sonar_create(&amp;s3, &amp;queue);</div>
<div class="line"> </div>
<div class="line">    struct slam slam;</div>
<div class="line">    slam_create(&amp;slam, &amp;queue);</div>
<div class="line"> </div>
<div class="line">    // dispatches events from all of the modules</div>
<div class="line">    equeue_dispatch(&amp;queue, -1);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md675"></a>
Platform</h1>
<p>The equeue library has a minimal porting layer that is flexible depending on the requirements of the underlying platform. Platform specific declarations and more information can be found in <a href="equeue_platform.h">equeue_platform.h</a>.</p>
<h1><a class="anchor" id="autotoc_md676"></a>
Tests</h1>
<p>The equeue library uses a set of local tests based on the posix implementation.</p>
<p>Runtime tests are located in <a href="tests/tests.c">tests.c</a>:</p>
<div class="fragment"><div class="line"> bash</div>
<div class="line">make test</div>
</div><!-- fragment --><p>Profiling tests based on rdtsc are located in <a href="tests/prof.c">prof.c</a>:</p>
<div class="fragment"><div class="line"> bash</div>
<div class="line">make prof</div>
</div><!-- fragment --><p>To make profiling results more tangible, the profiler also supports percentage comparison with previous runs: </p><div class="fragment"><div class="line"> bash</div>
<div class="line">make prof | tee results.txt</div>
<div class="line">cat results.txt | make prof</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5fdebfbd0a4b5643a5e85bf3c8b1558b.html">mbed-os</a></li><li class="navelem"><a class="el" href="dir_c9accd7f3d56a31cf544486021488b30.html">events</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
