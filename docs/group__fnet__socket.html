<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: Fnet_socket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__fnet__socket.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Fnet_socket</div></div>
</div><!--header-->
<div class="contents">

<p>CPU-specific library API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionfnet__ip6__addr__t.html">fnet_ip6_addr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">128-bit IPv6 address type.  <a href="unionfnet__ip6__addr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structin__addr.html">in_addr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket address(net format)  <a href="structin__addr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsockaddr__in.html">sockaddr_in</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket address_in struct  <a href="structsockaddr__in.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structin6__addr.html">in6_addr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket address(IPV6 net format)  <a href="structin6__addr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsockaddr__in6.html">sockaddr_in6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket address_in6 struct  <a href="structsockaddr__in6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsockaddr.html">sockaddr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket address struct  <a href="structsockaddr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structip__mreq.html">ip_mreq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPv4 multicast group information.  <a href="structip__mreq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipv6__mreq.html">ipv6_mreq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPv6 multicast group information.  <a href="structipv6__mreq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlinger.html">linger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used for the <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a6856768825eabef55d9d4175020da464">SO_LINGER</a> option.  <a href="structlinger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae5835961024ae0f8af527125e89fab8d" id="r_gae5835961024ae0f8af527125e89fab8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae5835961024ae0f8af527125e89fab8d">FNET_HTONS</a>(short_var)</td></tr>
<tr class="separator:gae5835961024ae0f8af527125e89fab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3df51a882734254b18c8b3705bc2b94a" id="r_ga3df51a882734254b18c8b3705bc2b94a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3df51a882734254b18c8b3705bc2b94a">FNET_NTOHS</a>(short_var)</td></tr>
<tr class="separator:ga3df51a882734254b18c8b3705bc2b94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbab4078ea6d069ffbd954dd41b9a8f0" id="r_gacbab4078ea6d069ffbd954dd41b9a8f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacbab4078ea6d069ffbd954dd41b9a8f0">FNET_HTONL</a>(long_var)</td></tr>
<tr class="separator:gacbab4078ea6d069ffbd954dd41b9a8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga777f60f62d40d3896f6d948709e763ee" id="r_ga777f60f62d40d3896f6d948709e763ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga777f60f62d40d3896f6d948709e763ee">FNET_NTOHL</a>(long_var)</td></tr>
<tr class="separator:ga777f60f62d40d3896f6d948709e763ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6907eec60ba522bbc2bb68f2eee6d660" id="r_ga6907eec60ba522bbc2bb68f2eee6d660"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6907eec60ba522bbc2bb68f2eee6d660">fnet_htons</a>(short_var)</td></tr>
<tr class="separator:ga6907eec60ba522bbc2bb68f2eee6d660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3fb42991ecd8b089dea905232ea3a4f" id="r_gad3fb42991ecd8b089dea905232ea3a4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad3fb42991ecd8b089dea905232ea3a4f">fnet_ntohs</a>(short_var)</td></tr>
<tr class="separator:gad3fb42991ecd8b089dea905232ea3a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d24f9f1954e5a63654329747309893" id="r_ga23d24f9f1954e5a63654329747309893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga23d24f9f1954e5a63654329747309893">fnet_htonl</a>(long_var)</td></tr>
<tr class="separator:ga23d24f9f1954e5a63654329747309893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd59b4daf04d283968471bfa5c75e2c5" id="r_gafd59b4daf04d283968471bfa5c75e2c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafd59b4daf04d283968471bfa5c75e2c5">fnet_ntohl</a>(long_var)</td></tr>
<tr class="separator:gafd59b4daf04d283968471bfa5c75e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3a99598e791317b7aa8ed69970c5b8" id="r_gaeb3a99598e791317b7aa8ed69970c5b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb3a99598e791317b7aa8ed69970c5b8">FNET_IP4_ADDR_INIT</a>(a,  b,  c,  d)</td></tr>
<tr class="memdesc:gaeb3a99598e791317b7aa8ed69970c5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the standard dotted-decimal notation <code>a.b.c.d</code> to an integer value, suitable for use as an Internet address (in network byte order).  <br /></td></tr>
<tr class="separator:gaeb3a99598e791317b7aa8ed69970c5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0c16fd6678d2a3f7fbb732ca86edc9" id="r_gafe0c16fd6678d2a3f7fbb732ca86edc9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe0c16fd6678d2a3f7fbb732ca86edc9">FNET_IP4_ADDR_STR_SIZE</a>&#160;&#160;&#160;sizeof(&quot;255.255.255.255&quot;)</td></tr>
<tr class="memdesc:gafe0c16fd6678d2a3f7fbb732ca86edc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the string buffer that will contain null-terminated ASCII string of an IPv4 address in standard "." notation.  <br /></td></tr>
<tr class="separator:gafe0c16fd6678d2a3f7fbb732ca86edc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b8084e04c0379d8516f41438cfd59b" id="r_gaa6b8084e04c0379d8516f41438cfd59b"><td class="memItemLeft" align="right" valign="top"><a id="gaa6b8084e04c0379d8516f41438cfd59b" name="gaa6b8084e04c0379d8516f41438cfd59b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FNET_IP4_ADDR_LINK_LOCAL_PREFIX</b>&#160;&#160;&#160;<a class="el" href="#gaeb3a99598e791317b7aa8ed69970c5b8">FNET_IP4_ADDR_INIT</a>(169,254,0,0)</td></tr>
<tr class="separator:gaa6b8084e04c0379d8516f41438cfd59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca17b6df8c8fc3d2e31a0b07410e9ca" id="r_ga4ca17b6df8c8fc3d2e31a0b07410e9ca"><td class="memItemLeft" align="right" valign="top"><a id="ga4ca17b6df8c8fc3d2e31a0b07410e9ca" name="ga4ca17b6df8c8fc3d2e31a0b07410e9ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FNET_IP4_ADDR_LINK_LOCAL_BROADCAST</b>&#160;&#160;&#160;<a class="el" href="#gaeb3a99598e791317b7aa8ed69970c5b8">FNET_IP4_ADDR_INIT</a>(169,254,255,255)</td></tr>
<tr class="separator:ga4ca17b6df8c8fc3d2e31a0b07410e9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d48bbeab659f390e264b58551df26f3" id="r_ga1d48bbeab659f390e264b58551df26f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1d48bbeab659f390e264b58551df26f3">IPOPT_COPIED</a>(t)</td></tr>
<tr class="separator:ga1d48bbeab659f390e264b58551df26f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220042fe215b2e03d0e3865ece7c763b" id="r_ga220042fe215b2e03d0e3865ece7c763b"><td class="memItemLeft" align="right" valign="top"><a id="ga220042fe215b2e03d0e3865ece7c763b" name="ga220042fe215b2e03d0e3865ece7c763b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_CLASS</b>&#160;&#160;&#160;(t)   ((t)&amp;0x60U)    /* 2-bit class field */</td></tr>
<tr class="separator:ga220042fe215b2e03d0e3865ece7c763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a2f9aa4c11b7391b64290448a0f3df" id="r_gae2a2f9aa4c11b7391b64290448a0f3df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae2a2f9aa4c11b7391b64290448a0f3df">IPOPT_NUMBER</a>(t)</td></tr>
<tr class="separator:gae2a2f9aa4c11b7391b64290448a0f3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3948f2989d22110df00b0301c0737e7" id="r_gaa3948f2989d22110df00b0301c0737e7"><td class="memItemLeft" align="right" valign="top"><a id="gaa3948f2989d22110df00b0301c0737e7" name="gaa3948f2989d22110df00b0301c0737e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_CONTROL</b>&#160;&#160;&#160;(0x00U)        /* control */</td></tr>
<tr class="separator:gaa3948f2989d22110df00b0301c0737e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91bdc607d6324d5e68e4ef7d61bbd2d1" id="r_ga91bdc607d6324d5e68e4ef7d61bbd2d1"><td class="memItemLeft" align="right" valign="top"><a id="ga91bdc607d6324d5e68e4ef7d61bbd2d1" name="ga91bdc607d6324d5e68e4ef7d61bbd2d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_RESERVED1</b>&#160;&#160;&#160;(0x20U)        /* reserved */</td></tr>
<tr class="separator:ga91bdc607d6324d5e68e4ef7d61bbd2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2354b40fe6732b1f1ae473f7e6f7323d" id="r_ga2354b40fe6732b1f1ae473f7e6f7323d"><td class="memItemLeft" align="right" valign="top"><a id="ga2354b40fe6732b1f1ae473f7e6f7323d" name="ga2354b40fe6732b1f1ae473f7e6f7323d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_DEBMEAS</b>&#160;&#160;&#160;(0x40U)        /* debugging and measurement */</td></tr>
<tr class="separator:ga2354b40fe6732b1f1ae473f7e6f7323d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b475a0720d067692ee62f40aa8f419b" id="r_ga0b475a0720d067692ee62f40aa8f419b"><td class="memItemLeft" align="right" valign="top"><a id="ga0b475a0720d067692ee62f40aa8f419b" name="ga0b475a0720d067692ee62f40aa8f419b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_RESERVED2</b>&#160;&#160;&#160;(0x60U)        /* reserved */</td></tr>
<tr class="separator:ga0b475a0720d067692ee62f40aa8f419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2869192c4bfaa89e4bdd6ab2c98ae10" id="r_gac2869192c4bfaa89e4bdd6ab2c98ae10"><td class="memItemLeft" align="right" valign="top"><a id="gac2869192c4bfaa89e4bdd6ab2c98ae10" name="gac2869192c4bfaa89e4bdd6ab2c98ae10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_EOL</b>&#160;&#160;&#160;(0U)           /* end of option <a class="el" href="structlist.html">list</a> */</td></tr>
<tr class="separator:gac2869192c4bfaa89e4bdd6ab2c98ae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4aedfe163639f80c2468f1a8dd6788" id="r_ga5e4aedfe163639f80c2468f1a8dd6788"><td class="memItemLeft" align="right" valign="top"><a id="ga5e4aedfe163639f80c2468f1a8dd6788" name="ga5e4aedfe163639f80c2468f1a8dd6788"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_NOP</b>&#160;&#160;&#160;(1U)           /* no operation */</td></tr>
<tr class="separator:ga5e4aedfe163639f80c2468f1a8dd6788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f851f42f39dbe9ff8703b595a644e7b" id="r_ga9f851f42f39dbe9ff8703b595a644e7b"><td class="memItemLeft" align="right" valign="top"><a id="ga9f851f42f39dbe9ff8703b595a644e7b" name="ga9f851f42f39dbe9ff8703b595a644e7b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_RR</b>&#160;&#160;&#160;(7U)           /* record  route */</td></tr>
<tr class="separator:ga9f851f42f39dbe9ff8703b595a644e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec6d37aacfaeaf5593d85596a8669249" id="r_gaec6d37aacfaeaf5593d85596a8669249"><td class="memItemLeft" align="right" valign="top"><a id="gaec6d37aacfaeaf5593d85596a8669249" name="gaec6d37aacfaeaf5593d85596a8669249"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_TS</b>&#160;&#160;&#160;(68U)          /* timestamp */</td></tr>
<tr class="separator:gaec6d37aacfaeaf5593d85596a8669249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e54d98b4cfd49a65cfc74e03ab44d6c" id="r_ga8e54d98b4cfd49a65cfc74e03ab44d6c"><td class="memItemLeft" align="right" valign="top"><a id="ga8e54d98b4cfd49a65cfc74e03ab44d6c" name="ga8e54d98b4cfd49a65cfc74e03ab44d6c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_SECURITY</b>&#160;&#160;&#160;(130U)         /* basic security */</td></tr>
<tr class="separator:ga8e54d98b4cfd49a65cfc74e03ab44d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4d2331a3afd78eec093954b690cba8" id="r_gadc4d2331a3afd78eec093954b690cba8"><td class="memItemLeft" align="right" valign="top"><a id="gadc4d2331a3afd78eec093954b690cba8" name="gadc4d2331a3afd78eec093954b690cba8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_LSRR</b>&#160;&#160;&#160;(131U)         /* loose source and record route */</td></tr>
<tr class="separator:gadc4d2331a3afd78eec093954b690cba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga516eecde3b5f0838f7abfe48a9c92df3" id="r_ga516eecde3b5f0838f7abfe48a9c92df3"><td class="memItemLeft" align="right" valign="top"><a id="ga516eecde3b5f0838f7abfe48a9c92df3" name="ga516eecde3b5f0838f7abfe48a9c92df3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_SATID</b>&#160;&#160;&#160;(136U)         /* stream id */</td></tr>
<tr class="separator:ga516eecde3b5f0838f7abfe48a9c92df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d24c291d3c7b0cdca26d4cb976d3c1" id="r_gae0d24c291d3c7b0cdca26d4cb976d3c1"><td class="memItemLeft" align="right" valign="top"><a id="gae0d24c291d3c7b0cdca26d4cb976d3c1" name="gae0d24c291d3c7b0cdca26d4cb976d3c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_SSRR</b>&#160;&#160;&#160;(137U)         /* strict source and record route */</td></tr>
<tr class="separator:gae0d24c291d3c7b0cdca26d4cb976d3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cbf9144c6d83facee271231ef2a5c0e" id="r_ga8cbf9144c6d83facee271231ef2a5c0e"><td class="memItemLeft" align="right" valign="top"><a id="ga8cbf9144c6d83facee271231ef2a5c0e" name="ga8cbf9144c6d83facee271231ef2a5c0e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_TYPE</b>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:ga8cbf9144c6d83facee271231ef2a5c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64dafcd4ab124102dc14a50096accf7" id="r_gaa64dafcd4ab124102dc14a50096accf7"><td class="memItemLeft" align="right" valign="top"><a id="gaa64dafcd4ab124102dc14a50096accf7" name="gaa64dafcd4ab124102dc14a50096accf7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_LENGTH</b>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:gaa64dafcd4ab124102dc14a50096accf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f27c48643e3b3994dbd572b7bfacf39" id="r_ga7f27c48643e3b3994dbd572b7bfacf39"><td class="memItemLeft" align="right" valign="top"><a id="ga7f27c48643e3b3994dbd572b7bfacf39" name="ga7f27c48643e3b3994dbd572b7bfacf39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_OFFSET</b>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:ga7f27c48643e3b3994dbd572b7bfacf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36619325072fbd682e544dc8456a775c" id="r_ga36619325072fbd682e544dc8456a775c"><td class="memItemLeft" align="right" valign="top"><a id="ga36619325072fbd682e544dc8456a775c" name="ga36619325072fbd682e544dc8456a775c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_OFFSET_MIN</b>&#160;&#160;&#160;(4U)           /* minimum value of 'offset'*/</td></tr>
<tr class="separator:ga36619325072fbd682e544dc8456a775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e47e6f6552ee5009dd7485a65b6e3d" id="r_ga44e47e6f6552ee5009dd7485a65b6e3d"><td class="memItemLeft" align="right" valign="top"><a id="ga44e47e6f6552ee5009dd7485a65b6e3d" name="ga44e47e6f6552ee5009dd7485a65b6e3d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IP_TOS_NORMAL</b>&#160;&#160;&#160;(0x0U)</td></tr>
<tr class="separator:ga44e47e6f6552ee5009dd7485a65b6e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea48b691396f4a6e9df6c7b1050a4e3" id="r_gadea48b691396f4a6e9df6c7b1050a4e3"><td class="memItemLeft" align="right" valign="top"><a id="gadea48b691396f4a6e9df6c7b1050a4e3" name="gadea48b691396f4a6e9df6c7b1050a4e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IP_TOS_LOWDELAY</b>&#160;&#160;&#160;(0x10U)</td></tr>
<tr class="separator:gadea48b691396f4a6e9df6c7b1050a4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4df134ae2a890e6b6c588712aa48bb6" id="r_gaa4df134ae2a890e6b6c588712aa48bb6"><td class="memItemLeft" align="right" valign="top"><a id="gaa4df134ae2a890e6b6c588712aa48bb6" name="gaa4df134ae2a890e6b6c588712aa48bb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IP_TOS_THROUGHPUT</b>&#160;&#160;&#160;(0x08U)</td></tr>
<tr class="separator:gaa4df134ae2a890e6b6c588712aa48bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb7cb655ede58a553ad1c299160dd76" id="r_ga5fb7cb655ede58a553ad1c299160dd76"><td class="memItemLeft" align="right" valign="top"><a id="ga5fb7cb655ede58a553ad1c299160dd76" name="ga5fb7cb655ede58a553ad1c299160dd76"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IP_TOS_RELIABILITY</b>&#160;&#160;&#160;(0x04U)</td></tr>
<tr class="separator:ga5fb7cb655ede58a553ad1c299160dd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8d4c5a0aa0b4a8beeef8475f5e0f2e" id="r_ga2d8d4c5a0aa0b4a8beeef8475f5e0f2e"><td class="memItemLeft" align="right" valign="top"><a id="ga2d8d4c5a0aa0b4a8beeef8475f5e0f2e" name="ga2d8d4c5a0aa0b4a8beeef8475f5e0f2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_TS_FLAG_TSONLY</b>&#160;&#160;&#160;(0U)    /* Record timestamps.*/</td></tr>
<tr class="separator:ga2d8d4c5a0aa0b4a8beeef8475f5e0f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21af1570f68bdccb7a55f4bd6b33812" id="r_gad21af1570f68bdccb7a55f4bd6b33812"><td class="memItemLeft" align="right" valign="top"><a id="gad21af1570f68bdccb7a55f4bd6b33812" name="gad21af1570f68bdccb7a55f4bd6b33812"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_TS_FLAG_TSANDADDR</b>&#160;&#160;&#160;(1U)    /* Record addresses and timestamps.*/</td></tr>
<tr class="separator:gad21af1570f68bdccb7a55f4bd6b33812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab3e6d0ff7b6cd55852ebde6378de09" id="r_ga2ab3e6d0ff7b6cd55852ebde6378de09"><td class="memItemLeft" align="right" valign="top"><a id="ga2ab3e6d0ff7b6cd55852ebde6378de09" name="ga2ab3e6d0ff7b6cd55852ebde6378de09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IPOPT_TS_FLAG_TSPRESPEC</b>&#160;&#160;&#160;(3U)    /* Record timestamps only at the prespecified systems.*/</td></tr>
<tr class="separator:ga2ab3e6d0ff7b6cd55852ebde6378de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6eea6691f13980a9d96024037ca088e" id="r_gae6eea6691f13980a9d96024037ca088e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae6eea6691f13980a9d96024037ca088e">FNET_IP4_CLASS_A</a>(i)</td></tr>
<tr class="separator:gae6eea6691f13980a9d96024037ca088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fce11a7f6432a6a86151aa121e5564" id="r_ga93fce11a7f6432a6a86151aa121e5564"><td class="memItemLeft" align="right" valign="top"><a id="ga93fce11a7f6432a6a86151aa121e5564" name="ga93fce11a7f6432a6a86151aa121e5564"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FNET_IP4_CLASS_A_NET</b>&#160;&#160;&#160;FNET_HTONL(0xff000000U)</td></tr>
<tr class="separator:ga93fce11a7f6432a6a86151aa121e5564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cbb7e1888f21a58105bf162b6d02bb7" id="r_ga9cbb7e1888f21a58105bf162b6d02bb7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9cbb7e1888f21a58105bf162b6d02bb7">FNET_IP4_CLASS_B</a>(i)</td></tr>
<tr class="separator:ga9cbb7e1888f21a58105bf162b6d02bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441b5854bd3eb11b8dea7efac0823c34" id="r_ga441b5854bd3eb11b8dea7efac0823c34"><td class="memItemLeft" align="right" valign="top"><a id="ga441b5854bd3eb11b8dea7efac0823c34" name="ga441b5854bd3eb11b8dea7efac0823c34"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FNET_IP4_CLASS_B_NET</b>&#160;&#160;&#160;FNET_HTONL(0xffff0000U)</td></tr>
<tr class="separator:ga441b5854bd3eb11b8dea7efac0823c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28cd8c1da1f70c779f20d0fdd09badac" id="r_ga28cd8c1da1f70c779f20d0fdd09badac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga28cd8c1da1f70c779f20d0fdd09badac">FNET_IP4_CLASS_C</a>(i)</td></tr>
<tr class="separator:ga28cd8c1da1f70c779f20d0fdd09badac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b050442471cbbcfb846ca61c75932e6" id="r_ga4b050442471cbbcfb846ca61c75932e6"><td class="memItemLeft" align="right" valign="top"><a id="ga4b050442471cbbcfb846ca61c75932e6" name="ga4b050442471cbbcfb846ca61c75932e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FNET_IP4_CLASS_C_NET</b>&#160;&#160;&#160;FNET_HTONL(0xffffff00U)</td></tr>
<tr class="separator:ga4b050442471cbbcfb846ca61c75932e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949f98ddd69b399d813ba4092c3a0fed" id="r_ga949f98ddd69b399d813ba4092c3a0fed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga949f98ddd69b399d813ba4092c3a0fed">FNET_IP4_CLASS_D</a>(i)</td></tr>
<tr class="separator:ga949f98ddd69b399d813ba4092c3a0fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab5b4a9a58f08394575cc9d34dac6ae" id="r_ga1ab5b4a9a58f08394575cc9d34dac6ae"><td class="memItemLeft" align="right" valign="top"><a id="ga1ab5b4a9a58f08394575cc9d34dac6ae" name="ga1ab5b4a9a58f08394575cc9d34dac6ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FNET_IP4_CLASS_D_NET</b>&#160;&#160;&#160;FNET_HTONL(0xf0000000U)</td></tr>
<tr class="separator:ga1ab5b4a9a58f08394575cc9d34dac6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4430368ece2aabefeabadf5004244011" id="r_ga4430368ece2aabefeabadf5004244011"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4430368ece2aabefeabadf5004244011">FNET_IP4_ADDR_IS_MULTICAST</a>(addr)</td></tr>
<tr class="separator:ga4430368ece2aabefeabadf5004244011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9dbd70dfa180057f43a0f90adc91592" id="r_gad9dbd70dfa180057f43a0f90adc91592"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad9dbd70dfa180057f43a0f90adc91592">FNET_IP4_ADDR_IS_UNSPECIFIED</a>(addr)</td></tr>
<tr class="separator:gad9dbd70dfa180057f43a0f90adc91592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3205d1bcf4ce9ad67ec1c6983ec1d52" id="r_gac3205d1bcf4ce9ad67ec1c6983ec1d52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3205d1bcf4ce9ad67ec1c6983ec1d52">FNET_IP4_CLASS_E</a>(i)</td></tr>
<tr class="separator:gac3205d1bcf4ce9ad67ec1c6983ec1d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6eb6f47bf0f98c121b8e1b43dff180" id="r_ga8f6eb6f47bf0f98c121b8e1b43dff180"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8f6eb6f47bf0f98c121b8e1b43dff180">FNET_IP4_EXPERIMENTAL</a>(i)</td></tr>
<tr class="separator:ga8f6eb6f47bf0f98c121b8e1b43dff180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99d101b4ae917a2b053f310f0b5b7a56" id="r_ga99d101b4ae917a2b053f310f0b5b7a56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga99d101b4ae917a2b053f310f0b5b7a56">FNET_IP4_BADCLASS</a>(i)</td></tr>
<tr class="separator:ga99d101b4ae917a2b053f310f0b5b7a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3955fe50337bce478a59591f7fb689fc" id="r_ga3955fe50337bce478a59591f7fb689fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3955fe50337bce478a59591f7fb689fc">FNET_IP4_ADDR1</a>(ipaddr)</td></tr>
<tr class="separator:ga3955fe50337bce478a59591f7fb689fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62aabd97bbc2f9b63ee2dbf4cba09255" id="r_ga62aabd97bbc2f9b63ee2dbf4cba09255"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga62aabd97bbc2f9b63ee2dbf4cba09255">FNET_IP4_ADDR2</a>(ipaddr)</td></tr>
<tr class="separator:ga62aabd97bbc2f9b63ee2dbf4cba09255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeaa04ea9ec4ef45e3d263d28df22fb1" id="r_gafeaa04ea9ec4ef45e3d263d28df22fb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafeaa04ea9ec4ef45e3d263d28df22fb1">FNET_IP4_ADDR3</a>(ipaddr)</td></tr>
<tr class="separator:gafeaa04ea9ec4ef45e3d263d28df22fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876c64413c0fde7fbe8254079ab61d5f" id="r_ga876c64413c0fde7fbe8254079ab61d5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga876c64413c0fde7fbe8254079ab61d5f">FNET_IP4_ADDR4</a>(ipaddr)</td></tr>
<tr class="separator:ga876c64413c0fde7fbe8254079ab61d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8a8b5c8ac879f744b3884e32bc2efd" id="r_ga8d8a8b5c8ac879f744b3884e32bc2efd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8d8a8b5c8ac879f744b3884e32bc2efd">FNET_IP6_ADDR_STR_SIZE</a>&#160;&#160;&#160;sizeof(&quot;abcd:abcd:abcd:abcd:abcd:abcd:abcd:abcd&quot;)</td></tr>
<tr class="memdesc:ga8d8a8b5c8ac879f744b3884e32bc2efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the string buffer that will contain null-terminated ASCII string of an IPv6 address in standard ":" notation.  <br /></td></tr>
<tr class="separator:ga8d8a8b5c8ac879f744b3884e32bc2efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1940045dc2e7de552f3d4ff13a74ab" id="r_ga5d1940045dc2e7de552f3d4ff13a74ab"><td class="memItemLeft" align="right" valign="top"><a id="ga5d1940045dc2e7de552f3d4ff13a74ab" name="ga5d1940045dc2e7de552f3d4ff13a74ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INADDR_ANY</b>&#160;&#160;&#160;(<a class="el" href="#gaec5b5f5986cbfcceb9cbebce69fcb939">fnet_ip4_addr_t</a>)(0x00000000U)</td></tr>
<tr class="memdesc:ga5d1940045dc2e7de552f3d4ff13a74ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">It means to use any network interface. <br /></td></tr>
<tr class="separator:ga5d1940045dc2e7de552f3d4ff13a74ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a725f61ded23ce8a7dff8e82ed51986" id="r_ga4a725f61ded23ce8a7dff8e82ed51986"><td class="memItemLeft" align="right" valign="top"><a id="ga4a725f61ded23ce8a7dff8e82ed51986" name="ga4a725f61ded23ce8a7dff8e82ed51986"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INADDR_BROADCAST</b>&#160;&#160;&#160;(<a class="el" href="#gaec5b5f5986cbfcceb9cbebce69fcb939">fnet_ip4_addr_t</a>)(0xffffffffU)</td></tr>
<tr class="memdesc:ga4a725f61ded23ce8a7dff8e82ed51986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast address. <br  />
It can be used to send the broadcast UDP datagrams over an IP network. <br /></td></tr>
<tr class="separator:ga4a725f61ded23ce8a7dff8e82ed51986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77ae24b14b7b7f294f3e04121173f12" id="r_gae77ae24b14b7b7f294f3e04121173f12"><td class="memItemLeft" align="right" valign="top"><a id="gae77ae24b14b7b7f294f3e04121173f12" name="gae77ae24b14b7b7f294f3e04121173f12"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AF_UNSPEC</b>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gae77ae24b14b7b7f294f3e04121173f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unspecified address family. <br /></td></tr>
<tr class="separator:gae77ae24b14b7b7f294f3e04121173f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9930604d0e32588eae76f43ca38e7826" id="r_ga9930604d0e32588eae76f43ca38e7826"><td class="memItemLeft" align="right" valign="top"><a id="ga9930604d0e32588eae76f43ca38e7826" name="ga9930604d0e32588eae76f43ca38e7826"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AF_INET</b>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga9930604d0e32588eae76f43ca38e7826"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPv4 address family. <br /></td></tr>
<tr class="separator:ga9930604d0e32588eae76f43ca38e7826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03706b2738b9a58d4985dfbe99e1bac" id="r_gaa03706b2738b9a58d4985dfbe99e1bac"><td class="memItemLeft" align="right" valign="top"><a id="gaa03706b2738b9a58d4985dfbe99e1bac" name="gaa03706b2738b9a58d4985dfbe99e1bac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AF_INET6</b>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:gaa03706b2738b9a58d4985dfbe99e1bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPv6 address family. <br /></td></tr>
<tr class="separator:gaa03706b2738b9a58d4985dfbe99e1bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcf68f46ca343a4af7b65972b5a02c0" id="r_ga5dcf68f46ca343a4af7b65972b5a02c0"><td class="memItemLeft" align="right" valign="top"><a id="ga5dcf68f46ca343a4af7b65972b5a02c0" name="ga5dcf68f46ca343a4af7b65972b5a02c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AF_SUPPORTED</b>&#160;&#160;&#160;((<a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a>)((<a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a>)(AF_INET6*(<a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a>)<a class="el" href="group__fnet__platform__stack__ip6__config.html#ga0e84d5e6bb5c9f0296c7eedcac2205b0">FNET_CFG_IP6</a>) | (<a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a>)(AF_INET*(<a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a>)<a class="el" href="group__fnet__platform__stack__ip4__config.html#ga3367ed695c7d771c3ccaaacc735c42f7">FNET_CFG_IP4</a>)))</td></tr>
<tr class="memdesc:ga5dcf68f46ca343a4af7b65972b5a02c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmask of supported address families. <br /></td></tr>
<tr class="separator:ga5dcf68f46ca343a4af7b65972b5a02c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5930085f892eb99aaa7c7ed80cdd571a" id="r_ga5930085f892eb99aaa7c7ed80cdd571a"><td class="memItemLeft" align="right" valign="top"><a id="ga5930085f892eb99aaa7c7ed80cdd571a" name="ga5930085f892eb99aaa7c7ed80cdd571a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FNET_SA_DATA_SIZE</b>&#160;&#160;&#160;(sizeof(struct <a class="el" href="structin__addr.html">in_addr</a>))</td></tr>
<tr class="memdesc:ga5930085f892eb99aaa7c7ed80cdd571a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of sa_data[] field of <a class="el" href="structsockaddr.html">sockaddr</a> structure. <br  />
It used to cover <a class="el" href="structsockaddr__in.html" title="socket address_in struct">sockaddr_in</a> and <a class="el" href="structsockaddr__in6.html" title="socket address_in6 struct">sockaddr_in6</a>. <br /></td></tr>
<tr class="separator:ga5930085f892eb99aaa7c7ed80cdd571a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425d2abe65e9b5553b5a34cd8728f285" id="r_ga425d2abe65e9b5553b5a34cd8728f285"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga425d2abe65e9b5553b5a34cd8728f285">FNET_IP_ADDR_STR_SIZE</a>&#160;&#160;&#160;<a class="el" href="#gafe0c16fd6678d2a3f7fbb732ca86edc9">FNET_IP4_ADDR_STR_SIZE</a></td></tr>
<tr class="memdesc:ga425d2abe65e9b5553b5a34cd8728f285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the string buffer that will contain null-terminated ASCII string of an IP address. It depends on if disabled or enabled IPv6.  <br /></td></tr>
<tr class="separator:ga425d2abe65e9b5553b5a34cd8728f285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9aba1af77d1f6a1500a51b41c5639f4" id="r_gae9aba1af77d1f6a1500a51b41c5639f4"><td class="memItemLeft" align="right" valign="top"><a id="gae9aba1af77d1f6a1500a51b41c5639f4" name="gae9aba1af77d1f6a1500a51b41c5639f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FNET_IP_ADDR_STR_SIZE_MAX</b>&#160;&#160;&#160;<a class="el" href="#ga8d8a8b5c8ac879f744b3884e32bc2efd">FNET_IP6_ADDR_STR_SIZE</a></td></tr>
<tr class="separator:gae9aba1af77d1f6a1500a51b41c5639f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaec5b5f5986cbfcceb9cbebce69fcb939" id="r_gaec5b5f5986cbfcceb9cbebce69fcb939"><td class="memItemLeft" align="right" valign="top"><a id="gaec5b5f5986cbfcceb9cbebce69fcb939" name="gaec5b5f5986cbfcceb9cbebce69fcb939"></a>
typedef fnet_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>fnet_ip4_addr_t</b></td></tr>
<tr class="memdesc:gaec5b5f5986cbfcceb9cbebce69fcb939"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit IPv4 address type. <br /></td></tr>
<tr class="separator:gaec5b5f5986cbfcceb9cbebce69fcb939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2297bb08ea37b8793a25b085ee5e5275" id="r_ga2297bb08ea37b8793a25b085ee5e5275"><td class="memItemLeft" align="right" valign="top">typedef fnet_uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a></td></tr>
<tr class="memdesc:ga2297bb08ea37b8793a25b085ee5e5275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address family type.  <br /></td></tr>
<tr class="separator:ga2297bb08ea37b8793a25b085ee5e5275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea4623bc4de22dd1840016bd6495b4a" id="r_ga5ea4623bc4de22dd1840016bd6495b4a"><td class="memItemLeft" align="right" valign="top"><a id="ga5ea4623bc4de22dd1840016bd6495b4a" name="ga5ea4623bc4de22dd1840016bd6495b4a"></a>
typedef fnet_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>fnet_scope_id_t</b></td></tr>
<tr class="memdesc:ga5ea4623bc4de22dd1840016bd6495b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">cope zone index type, defining network interface. <br /></td></tr>
<tr class="separator:ga5ea4623bc4de22dd1840016bd6495b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90750288ac5aea86a2913857d17f8c11" id="r_ga90750288ac5aea86a2913857d17f8c11"><td class="memItemLeft" align="right" valign="top"><a id="ga90750288ac5aea86a2913857d17f8c11" name="ga90750288ac5aea86a2913857d17f8c11"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>fnet_socket_t</b></td></tr>
<tr class="memdesc:ga90750288ac5aea86a2913857d17f8c11"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSocket.html">Socket</a> descriptor. <br /></td></tr>
<tr class="separator:ga90750288ac5aea86a2913857d17f8c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9f1b6a1b9f22d86025b8d9d5b473ec06" id="r_ga9f1b6a1b9f22d86025b8d9d5b473ec06"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9f1b6a1b9f22d86025b8d9d5b473ec06">fnet_socket_type_t</a> { <a class="el" href="#gga9f1b6a1b9f22d86025b8d9d5b473ec06a9dc707447a82adf9a8eb5febe8c707ac">SOCK_UNSPEC</a> = (0U)
, <a class="el" href="#gga9f1b6a1b9f22d86025b8d9d5b473ec06ae3b7fb9487113a31d403b23aaeaad424">SOCK_STREAM</a> = (1U)
, <a class="el" href="#gga9f1b6a1b9f22d86025b8d9d5b473ec06a006b373a518eeeb717573f91e70d7fcc">SOCK_DGRAM</a> = (2U)
, <a class="el" href="#gga9f1b6a1b9f22d86025b8d9d5b473ec06ad78d54561daf9c4a7cda0ce115e3f231">SOCK_RAW</a> = (3U)
 }</td></tr>
<tr class="memdesc:ga9f1b6a1b9f22d86025b8d9d5b473ec06"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSocket.html">Socket</a> types.  <a href="#ga9f1b6a1b9f22d86025b8d9d5b473ec06">More...</a><br /></td></tr>
<tr class="separator:ga9f1b6a1b9f22d86025b8d9d5b473ec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b410682d2a08c9eda8d9337731e5f9f" id="r_ga3b410682d2a08c9eda8d9337731e5f9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b410682d2a08c9eda8d9337731e5f9f">fnet_socket_state_t</a> { <a class="el" href="#gga3b410682d2a08c9eda8d9337731e5f9fa3b2500a7ffff9084fdca145c1a37b722">SS_UNCONNECTED</a> = (0)
, <a class="el" href="#gga3b410682d2a08c9eda8d9337731e5f9fa8407056ba960ba5990d4faf1a5df30a9">SS_CONNECTING</a> = (1)
, <a class="el" href="#gga3b410682d2a08c9eda8d9337731e5f9fa097f95adc87c47e70cd008b417fbac57">SS_CONNECTED</a> = (2)
, <a class="el" href="#gga3b410682d2a08c9eda8d9337731e5f9fa91ff6bb9bbcae669b6944ffc3d884f29">SS_LISTENING</a> = (3)
 }</td></tr>
<tr class="memdesc:ga3b410682d2a08c9eda8d9337731e5f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSocket.html">Socket</a> state.  <a href="#ga3b410682d2a08c9eda8d9337731e5f9f">More...</a><br /></td></tr>
<tr class="separator:ga3b410682d2a08c9eda8d9337731e5f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf5dba7175dbc74b729bbab381a009a" id="r_gaedf5dba7175dbc74b729bbab381a009a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaedf5dba7175dbc74b729bbab381a009a">fnet_protocol_t</a> { <br />
&#160;&#160;<a class="el" href="#ggaedf5dba7175dbc74b729bbab381a009aa334b0a4a5a3e331e7c7864471e9eab08">IPPROTO_IP</a> = (0)
, <a class="el" href="#ggaedf5dba7175dbc74b729bbab381a009aa7ccd735b73f6955ae2f4abf3e7ca6bb4">IPPROTO_ICMP</a> = (1)
, <a class="el" href="#ggaedf5dba7175dbc74b729bbab381a009aa4cbcb48be0cd8eb6fb5b5741f1c7b639">IPPROTO_IGMP</a> = (2)
, <a class="el" href="#ggaedf5dba7175dbc74b729bbab381a009aa4a3c433d15859f62bacc06312791a45e">IPPROTO_TCP</a> = (6)
, <br />
&#160;&#160;<a class="el" href="#ggaedf5dba7175dbc74b729bbab381a009aabd7dfb22e255a4eed332f41de12d7321">IPPROTO_UDP</a> = (17)
, <a class="el" href="#ggaedf5dba7175dbc74b729bbab381a009aa892549243e60ed1e04e88a14b44d8185">IPPROTO_IPV6</a> = (41)
, <a class="el" href="#ggaedf5dba7175dbc74b729bbab381a009aaeeff57e3cf726718a92b2138e5842926">IPPROTO_ICMPV6</a> = (58)
, <a class="el" href="#ggaedf5dba7175dbc74b729bbab381a009aa1d3add04b81641b0740db2a8f4ef207c">SOL_SOCKET</a> = (255255)
<br />
 }</td></tr>
<tr class="memdesc:gaedf5dba7175dbc74b729bbab381a009a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol numbers and Level numbers for the <a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt()</a> and the <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a>.  <a href="#gaedf5dba7175dbc74b729bbab381a009a">More...</a><br /></td></tr>
<tr class="separator:gaedf5dba7175dbc74b729bbab381a009a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga989481a2cee0291e70f9076a091eddf1" id="r_ga989481a2cee0291e70f9076a091eddf1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga989481a2cee0291e70f9076a091eddf1">fnet_socket_options_t</a> { <br />
&#160;&#160;<a class="el" href="#gga989481a2cee0291e70f9076a091eddf1aa985052d483e1e379df8fe24e5ae9323">SO_ACCEPTCONN</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a4540c38a6d26cae663b162aa08b2cd1b">SO_KEEPALIVE</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a934ec9d2fb58639026a17bb71d907c88">SO_DONTROUTE</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a6856768825eabef55d9d4175020da464">SO_LINGER</a>
, <br />
&#160;&#160;<a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a68027692aae2685592434c77096d14c3">SO_OOBINLINE</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a1df7a92f3c90d78f7be79280937cc48f">SO_SNDBUF</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a2b21411458e656e4dae50ed07bc49fe9">SO_RCVBUF</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a43b410a56c993383c754b4c8a6d55063">SO_STATE</a>
, <br />
&#160;&#160;<a class="el" href="#gga989481a2cee0291e70f9076a091eddf1ac9c377737c401ee3826e199d5ec2c6c7">SO_ERROR</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a518fcdee784798ddf4db7a593e794340">SO_TYPE</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1abf4f6c73b2615827c8ab17526d6ecc67">SO_RCVNUM</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1aea89904cbe143cf731f0eb03ea2ee9b9">SO_SNDNUM</a>
, <br />
&#160;&#160;<a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a964897880427803d0ef2ed8ed6a2942a">TCP_MSS</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a7cfe46d0d1bb6edbfda3b40e1e4e9a6f">TCP_BSD</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a54ab75c4bde1187c7f624e6bab97699c">TCP_NODELAY</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a6c1da222c2434c4627e761e5ea15d21f">TCP_FINRCVD</a>
, <br />
&#160;&#160;<a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a692d762f523124219c7519baf6c6e8fa">TCP_URGRCVD</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a42e07e3648f9ee2234d826624d3b0f01">TCP_KEEPIDLE</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a463c5a82fcf2d4ce8f7bddb179107cc2">TCP_KEEPINTVL</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a5523ba3ac6c76dd6ec90703b26de7fc8">TCP_KEEPCNT</a>
, <br />
&#160;&#160;<a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a13abe4ff93f7ce743a78404d5ca0af8c">IP_TOS</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a96d904e00582f92a7ac3bcc9b2f132b7">IP_TTL</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a86b4a9f6c127f6dbbe3034730b7632ad">IP_MULTICAST_TTL</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1aca99f4e845aa1795a85d704f5472a511">IP_ADD_MEMBERSHIP</a>
, <br />
&#160;&#160;<a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a489c5cfbb00b3cee4fe9288fa40f4a01">IP_DROP_MEMBERSHIP</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a5aec4eba3484f8c48a8461a5152ba068">IPV6_UNICAST_HOPS</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a1d35209096975f6463e69f084d22fd3e">IPV6_MULTICAST_HOPS</a>
, <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1afda4e055e7c3f064791042e536118639">IPV6_JOIN_GROUP</a>
, <br />
&#160;&#160;<a class="el" href="#gga989481a2cee0291e70f9076a091eddf1ac8aaa87d8025716cc314424809ef71b4">IPV6_LEAVE_GROUP</a>
<br />
 }</td></tr>
<tr class="memdesc:ga989481a2cee0291e70f9076a091eddf1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSocket.html">Socket</a> options for the <a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt()</a> and the <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a>.  <a href="#ga989481a2cee0291e70f9076a091eddf1">More...</a><br /></td></tr>
<tr class="separator:ga989481a2cee0291e70f9076a091eddf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23dfda01e1334a4bfe9c86036169529" id="r_gac23dfda01e1334a4bfe9c86036169529"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac23dfda01e1334a4bfe9c86036169529">fnet_msg_flags_t</a> { <a class="el" href="#ggac23dfda01e1334a4bfe9c86036169529a890be29a00a90e15eb7e50a1cbba95ab">MSG_OOB</a> = (0x1U)
, <a class="el" href="#ggac23dfda01e1334a4bfe9c86036169529a41ac2d38ac3e36d430b72abfb78273e5">MSG_PEEK</a> = (0x2U)
, <a class="el" href="#ggac23dfda01e1334a4bfe9c86036169529a8ec01a7477627843f34cfab30bfe4c84">MSG_DONTROUTE</a> = (0x4U)
 }</td></tr>
<tr class="memdesc:gac23dfda01e1334a4bfe9c86036169529"><td class="mdescLeft">&#160;</td><td class="mdescRight">The flags parameters for receiving and sending functions <a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv()</a>, <a class="el" href="#ga30cdb74342d222bb10b53a3571b72398">fnet_socket_recvfrom()</a>, <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send()</a>, and <a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto()</a>.  <a href="#gac23dfda01e1334a4bfe9c86036169529">More...</a><br /></td></tr>
<tr class="separator:gac23dfda01e1334a4bfe9c86036169529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaccafa9b8a75cd59ae89842feb37e48" id="r_gadaccafa9b8a75cd59ae89842feb37e48"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadaccafa9b8a75cd59ae89842feb37e48">fnet_sd_flags_t</a> { <a class="el" href="#ggadaccafa9b8a75cd59ae89842feb37e48afa088e64138dfb8f58de1432d77577ac">SD_READ</a> = (0x1U)
, <a class="el" href="#ggadaccafa9b8a75cd59ae89842feb37e48ac9c468da07fb6d142eb5817545c2c94b">SD_WRITE</a> = (0x2U)
, <a class="el" href="#ggadaccafa9b8a75cd59ae89842feb37e48a545eaee6b6155691ef979c90f6123aee">SD_BOTH</a> = (SD_READ | SD_WRITE)
 }</td></tr>
<tr class="memdesc:gadaccafa9b8a75cd59ae89842feb37e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The flags used by <a class="el" href="#ga03aa9c1387d19cbb241e4e058a86e39a">fnet_socket_shutdown()</a>.  <a href="#gadaccafa9b8a75cd59ae89842feb37e48">More...</a><br /></td></tr>
<tr class="separator:gadaccafa9b8a75cd59ae89842feb37e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5526f421218aba24311e9abee1033690" id="r_ga5526f421218aba24311e9abee1033690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5526f421218aba24311e9abee1033690">fnet_inet_ntoa</a> (struct <a class="el" href="structin__addr.html">in_addr</a> addr, <a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *res_str)</td></tr>
<tr class="memdesc:ga5526f421218aba24311e9abee1033690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an IPv4 address into a string in Internet standard dotted-decimal format.  <br /></td></tr>
<tr class="separator:ga5526f421218aba24311e9abee1033690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a5f9262fe47d5373f446f4fe127f23" id="r_ga63a5f9262fe47d5373f446f4fe127f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga63a5f9262fe47d5373f446f4fe127f23">fnet_inet_aton</a> (<a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *cp, struct <a class="el" href="structin__addr.html">in_addr</a> *addr)</td></tr>
<tr class="memdesc:ga63a5f9262fe47d5373f446f4fe127f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string in the standard dotted-decimal notation to an integer value, suitable for use as an IPv4 address.  <br /></td></tr>
<tr class="separator:ga63a5f9262fe47d5373f446f4fe127f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77933fd49752e533874747932ebac998" id="r_ga77933fd49752e533874747932ebac998"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga77933fd49752e533874747932ebac998">fnet_inet_ntop</a> (<a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a> family, const void *addr, <a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *str, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> str_len)</td></tr>
<tr class="memdesc:ga77933fd49752e533874747932ebac998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts IPv4 or IPv6 address from binary to text form.  <br /></td></tr>
<tr class="separator:ga77933fd49752e533874747932ebac998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28a8e2f31a32550faf05d8ba72f0a4f6" id="r_ga28a8e2f31a32550faf05d8ba72f0a4f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga28a8e2f31a32550faf05d8ba72f0a4f6">fnet_inet_pton</a> (<a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a> family, const <a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *str, void *addr, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> addr_len)</td></tr>
<tr class="memdesc:ga28a8e2f31a32550faf05d8ba72f0a4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts IPv4 and IPv6 addresses from text to binary form.  <br /></td></tr>
<tr class="separator:ga28a8e2f31a32550faf05d8ba72f0a4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c97a7ec6eedf63ba5dbf80e17c01aae" id="r_ga8c97a7ec6eedf63ba5dbf80e17c01aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c97a7ec6eedf63ba5dbf80e17c01aae">fnet_inet_ptos</a> (const <a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *str, struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr)</td></tr>
<tr class="memdesc:ga8c97a7ec6eedf63ba5dbf80e17c01aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts IPv4 and IPv6 addresses from text to socket-address structure.  <br /></td></tr>
<tr class="separator:ga8c97a7ec6eedf63ba5dbf80e17c01aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8be83bf32f2944d9aed2db185b0d5c6" id="r_gac8be83bf32f2944d9aed2db185b0d5c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac8be83bf32f2944d9aed2db185b0d5c6">fnet_socket</a> (<a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a> family, <a class="el" href="#ga9f1b6a1b9f22d86025b8d9d5b473ec06">fnet_socket_type_t</a> type, fnet_uint32_t protocol)</td></tr>
<tr class="memdesc:gac8be83bf32f2944d9aed2db185b0d5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a socket.  <br /></td></tr>
<tr class="separator:gac8be83bf32f2944d9aed2db185b0d5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga214c5b0a449ce278f72285b37a33bcae" id="r_ga214c5b0a449ce278f72285b37a33bcae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga214c5b0a449ce278f72285b37a33bcae">fnet_socket_bind</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, const struct <a class="el" href="structsockaddr.html">sockaddr</a> *name, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> namelen)</td></tr>
<tr class="memdesc:ga214c5b0a449ce278f72285b37a33bcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a local address to a socket.  <br /></td></tr>
<tr class="separator:ga214c5b0a449ce278f72285b37a33bcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf861cac2394db1fe94fce1a55a25900e" id="r_gaf861cac2394db1fe94fce1a55a25900e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf861cac2394db1fe94fce1a55a25900e">fnet_socket_listen</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> backlog)</td></tr>
<tr class="memdesc:gaf861cac2394db1fe94fce1a55a25900e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the socket into a state, where it is listening for an incoming connection.  <br /></td></tr>
<tr class="separator:gaf861cac2394db1fe94fce1a55a25900e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8269391b0495ae2785309c09c969ecf" id="r_gaa8269391b0495ae2785309c09c969ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8269391b0495ae2785309c09c969ecf">fnet_socket_accept</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *addrlen)</td></tr>
<tr class="memdesc:gaa8269391b0495ae2785309c09c969ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a connection on the specified socket.  <br /></td></tr>
<tr class="separator:gaa8269391b0495ae2785309c09c969ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786a6f122a594cfde09501a0e5643c5d" id="r_ga786a6f122a594cfde09501a0e5643c5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, struct <a class="el" href="structsockaddr.html">sockaddr</a> *name, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> namelen)</td></tr>
<tr class="memdesc:ga786a6f122a594cfde09501a0e5643c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a connection with the specified socket.  <br /></td></tr>
<tr class="separator:ga786a6f122a594cfde09501a0e5643c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81904520913d1e69bf998e6585f27652" id="r_ga81904520913d1e69bf998e6585f27652"><td class="memItemLeft" align="right" valign="top">fnet_int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, fnet_uint8_t *<a class="el" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> len, <a class="el" href="group__fnet__stdlib.html#ga7c185c75d7122a77920e039b28309ec1">fnet_flag_t</a> flags)</td></tr>
<tr class="memdesc:ga81904520913d1e69bf998e6585f27652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the data from a connected socket.  <br /></td></tr>
<tr class="separator:ga81904520913d1e69bf998e6585f27652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30cdb74342d222bb10b53a3571b72398" id="r_ga30cdb74342d222bb10b53a3571b72398"><td class="memItemLeft" align="right" valign="top">fnet_int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30cdb74342d222bb10b53a3571b72398">fnet_socket_recvfrom</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, fnet_uint8_t *<a class="el" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> len, <a class="el" href="group__fnet__stdlib.html#ga7c185c75d7122a77920e039b28309ec1">fnet_flag_t</a> flags, struct <a class="el" href="structsockaddr.html">sockaddr</a> *from, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *fromlen)</td></tr>
<tr class="memdesc:ga30cdb74342d222bb10b53a3571b72398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the data and captures the address, from which the data was sent.  <br /></td></tr>
<tr class="separator:ga30cdb74342d222bb10b53a3571b72398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22fad04f9149f9d04ac61d563b81fdc4" id="r_ga22fad04f9149f9d04ac61d563b81fdc4"><td class="memItemLeft" align="right" valign="top">fnet_int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, fnet_uint8_t *<a class="el" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> len, <a class="el" href="group__fnet__stdlib.html#ga7c185c75d7122a77920e039b28309ec1">fnet_flag_t</a> flags)</td></tr>
<tr class="memdesc:ga22fad04f9149f9d04ac61d563b81fdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the data on a connected socket.  <br /></td></tr>
<tr class="separator:ga22fad04f9149f9d04ac61d563b81fdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5874eb12bf5f23296cdc787319d5ce5c" id="r_ga5874eb12bf5f23296cdc787319d5ce5c"><td class="memItemLeft" align="right" valign="top">fnet_int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, fnet_uint8_t *<a class="el" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> len, <a class="el" href="group__fnet__stdlib.html#ga7c185c75d7122a77920e039b28309ec1">fnet_flag_t</a> flags, const struct <a class="el" href="structsockaddr.html">sockaddr</a> *to, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> tolen)</td></tr>
<tr class="memdesc:ga5874eb12bf5f23296cdc787319d5ce5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the data to a specific destination.  <br /></td></tr>
<tr class="separator:ga5874eb12bf5f23296cdc787319d5ce5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03aa9c1387d19cbb241e4e058a86e39a" id="r_ga03aa9c1387d19cbb241e4e058a86e39a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga03aa9c1387d19cbb241e4e058a86e39a">fnet_socket_shutdown</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, <a class="el" href="#gadaccafa9b8a75cd59ae89842feb37e48">fnet_sd_flags_t</a> how)</td></tr>
<tr class="memdesc:ga03aa9c1387d19cbb241e4e058a86e39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the connection in one or both directions.  <br /></td></tr>
<tr class="separator:ga03aa9c1387d19cbb241e4e058a86e39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb4c12c0fba44e02a019dc877fef373" id="r_ga6cb4c12c0fba44e02a019dc877fef373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373">fnet_socket_close</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s)</td></tr>
<tr class="memdesc:ga6cb4c12c0fba44e02a019dc877fef373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an existing socket.  <br /></td></tr>
<tr class="separator:ga6cb4c12c0fba44e02a019dc877fef373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1bf147e6a6a6f361084c0e829c3d000" id="r_gad1bf147e6a6a6f361084c0e829c3d000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, <a class="el" href="#gaedf5dba7175dbc74b729bbab381a009a">fnet_protocol_t</a> level, <a class="el" href="#ga989481a2cee0291e70f9076a091eddf1">fnet_socket_options_t</a> optname, const void *optval, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> optvallen)</td></tr>
<tr class="memdesc:gad1bf147e6a6a6f361084c0e829c3d000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a socket option.  <br /></td></tr>
<tr class="separator:gad1bf147e6a6a6f361084c0e829c3d000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70de533218cdeb51a5cbce0c5f7fa607" id="r_ga70de533218cdeb51a5cbce0c5f7fa607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, <a class="el" href="#gaedf5dba7175dbc74b729bbab381a009a">fnet_protocol_t</a> level, <a class="el" href="#ga989481a2cee0291e70f9076a091eddf1">fnet_socket_options_t</a> optname, void *optval, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *optvallen)</td></tr>
<tr class="memdesc:ga70de533218cdeb51a5cbce0c5f7fa607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a socket option.  <br /></td></tr>
<tr class="separator:ga70de533218cdeb51a5cbce0c5f7fa607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988be7f23f5413df6600c1759495e5f4" id="r_ga988be7f23f5413df6600c1759495e5f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga988be7f23f5413df6600c1759495e5f4">fnet_socket_getpeername</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, struct <a class="el" href="structsockaddr.html">sockaddr</a> *name, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *namelen)</td></tr>
<tr class="memdesc:ga988be7f23f5413df6600c1759495e5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name of a peer connected to a socket.  <br /></td></tr>
<tr class="separator:ga988be7f23f5413df6600c1759495e5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7c15f910622ec6826d5eb7bc696edf" id="r_ga8e7c15f910622ec6826d5eb7bc696edf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e7c15f910622ec6826d5eb7bc696edf">fnet_socket_getname</a> (<a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> s, struct <a class="el" href="structsockaddr.html">sockaddr</a> *name, <a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *namelen)</td></tr>
<tr class="memdesc:ga8e7c15f910622ec6826d5eb7bc696edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current name for the specified socket.  <br /></td></tr>
<tr class="separator:ga8e7c15f910622ec6826d5eb7bc696edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529326afa1f8d0d661faf8b147443d9e" id="r_ga529326afa1f8d0d661faf8b147443d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#gae066ef031201bb2ccac8febf4707fd0e">fnet_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga529326afa1f8d0d661faf8b147443d9e">fnet_socket_addr_are_equal</a> (const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr1, const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr2)</td></tr>
<tr class="memdesc:ga529326afa1f8d0d661faf8b147443d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares socket addresses.  <br /></td></tr>
<tr class="separator:ga529326afa1f8d0d661faf8b147443d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1122c8e1cd985dfc4a8b3e02ce319ab4" id="r_ga1122c8e1cd985dfc4a8b3e02ce319ab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#gae066ef031201bb2ccac8febf4707fd0e">fnet_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1122c8e1cd985dfc4a8b3e02ce319ab4">fnet_socket_addr_is_unspecified</a> (const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr)</td></tr>
<tr class="memdesc:ga1122c8e1cd985dfc4a8b3e02ce319ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines, if socket address is unspecified.  <br /></td></tr>
<tr class="separator:ga1122c8e1cd985dfc4a8b3e02ce319ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0bd605a1f5f63a06abaefd597462f80" id="r_gaf0bd605a1f5f63a06abaefd597462f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fnet__stdlib.html#gae066ef031201bb2ccac8febf4707fd0e">fnet_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0bd605a1f5f63a06abaefd597462f80">fnet_socket_addr_is_multicast</a> (const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr)</td></tr>
<tr class="memdesc:gaf0bd605a1f5f63a06abaefd597462f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines, if socket address is multicast.  <br /></td></tr>
<tr class="separator:gaf0bd605a1f5f63a06abaefd597462f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>CPU-specific library API. </p>
<p><a class="el" href="classSocket.html">Socket</a> API.</p>
<p>IPv6 protocol API.</p>
<p>IP protocol API.</p>
<p>Address-conversion functions API.</p>
<p>The <a class="el" href="classSocket.html">Socket</a> Application Program Interface (API) defines the way, in which the application program interacts with the TCP/IP stack. It has the BSD-like, non-blocking socket interface that makes porting of existing network applications to the FNET more convenient.<br  />
<br  />
The following table summarizes the supported socket API functions: </p><table class="doxtable">
<caption><a class="el" href="classSocket.html">Socket</a> functions</caption>
<tr class="fnet_td_grey">
<th align="center">Category</th><th align="center">FNET Routine</th><th align="center">BSD Routine</th><th align="center">Meaning</th><th align="center">Server </th><th align="center">Client</th><th align="center">SOCK_STREAM </th><th align="center">SOCK_DGRAM  </th></tr>
<tr>
<td>setup</td><td><a class="el" href="#gac8be83bf32f2944d9aed2db185b0d5c6">fnet_socket()</a></td><td><a class="el" href="structsocket.html">socket()</a></td><td>Creates a new unnamed socket within a specified communication domain family.</td><td>X</td><td>X</td><td>X </td><td>X  </td></tr>
<tr>
<td>setup</td><td><a class="el" href="#ga214c5b0a449ce278f72285b37a33bcae">fnet_socket_bind()</a></td><td>bind()</td><td>Assigns a local address to a socket.</td><td>X</td><td>X</td><td>X</td><td>X  </td></tr>
<tr>
<td>server</td><td><a class="el" href="#gaf861cac2394db1fe94fce1a55a25900e">fnet_socket_listen()</a></td><td>listen()</td><td>Prepares a socket to accept the incoming connections.</td><td>X</td><td><br  />
</td><td>X</td><td><br  />
  </td></tr>
<tr>
<td>server</td><td><a class="el" href="#gaa8269391b0495ae2785309c09c969ecf">fnet_socket_accept()</a></td><td>accept()</td><td>Accepts the connections. </td><td>X</td><td><br  />
</td><td>X</td><td><br  />
  </td></tr>
<tr>
<td>client</td><td><a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect()</a></td><td>connect()</td><td>Establishes a connection to a foreign socket.</td><td><br  />
</td><td>X</td><td>X</td><td>X  </td></tr>
<tr>
<td>input</td><td><a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv()</a></td><td>recv()</td><td>Receives the data.</td><td>X </td><td>X</td><td>X</td><td>X  </td></tr>
<tr>
<td>input</td><td><a class="el" href="#ga30cdb74342d222bb10b53a3571b72398">fnet_socket_recvfrom()</a></td><td>recvfrom()</td><td>Receives the data and address of the sender.</td><td>X</td><td>X</td><td><br  />
</td><td>X  </td></tr>
<tr>
<td>output</td><td><a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send()</a></td><td>send()</td><td>Sends the data.</td><td>X </td><td>X</td><td>X</td><td>X  </td></tr>
<tr>
<td>output</td><td><a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto()</a></td><td>sendto()</td><td>Sends the data to a specified address.</td><td>X</td><td>X</td><td><br  />
</td><td>X  </td></tr>
<tr>
<td>termination</td><td><a class="el" href="#ga03aa9c1387d19cbb241e4e058a86e39a">fnet_socket_shutdown()</a></td><td>shutdown()</td><td>Terminates a connection in one or both directions.</td><td>X</td><td>X</td><td>X</td><td>X  </td></tr>
<tr>
<td>termination</td><td><a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373">fnet_socket_close()</a></td><td>closesocket()</td><td>Terminates a connection and releases the socket.</td><td>X</td><td>X</td><td>X</td><td>X  </td></tr>
<tr>
<td>administration</td><td><a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt()</a></td><td><a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000" title="Sets a socket option.">fnet_socket_setopt()</a></td><td>Sets socket or protocol options.</td><td>X</td><td>X</td><td>X</td><td>X  </td></tr>
<tr>
<td>administration</td><td><a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a></td><td>getsockopt()</td><td>Gets socket or protocol options.</td><td>X</td><td>X</td><td>X</td><td>X  </td></tr>
<tr>
<td>administration</td><td><a class="el" href="#ga8e7c15f910622ec6826d5eb7bc696edf">fnet_socket_getname()</a></td><td>getsockname()</td><td>Gets a local address assigned to a socket.</td><td>X</td><td>X</td><td>X</td><td>X  </td></tr>
<tr>
<td>administration</td><td><a class="el" href="#ga988be7f23f5413df6600c1759495e5f4">fnet_socket_getpeername()</a></td><td>getpeername()</td><td>Gets a foreign address assigned to a socket.</td><td>X</td><td>X</td><td>X</td><td>X  </td></tr>
</table>
<p>Configuration parameters:</p><ul>
<li><a class="el" href="group__fnet__stack__config.html#ga19d909e31e7cb22016e19947bca83f7a">FNET_CFG_SOCKET_MAX</a></li>
<li><a class="el" href="group__fnet__stack__config.html#ga550b6ca6fb7a78cfe7e5d062b17e77bb">FNET_CFG_SOCKET_TCP_TX_BUF_SIZE</a></li>
<li><a class="el" href="group__fnet__stack__config.html#ga441698ce8bbf7b7f97b670ca034a05a1">FNET_CFG_SOCKET_TCP_RX_BUF_SIZE</a></li>
<li><a class="el" href="group__fnet__stack__config.html#ga7e05e995ebd8a2d6b654270aaefe074f">FNET_CFG_SOCKET_UDP_TX_BUF_SIZE</a></li>
<li><a class="el" href="group__fnet__stack__config.html#gaa68c0f4165b03e295585bfea6e39b6fb">FNET_CFG_SOCKET_UDP_RX_BUF_SIZE</a></li>
<li><a class="el" href="group__fnet__stack__config.html#gadcf09da5eeaf977645a98592858b6acd">FNET_CFG_SOCKET_TCP_MSS</a></li>
<li><a class="el" href="group__fnet__stack__config.html#gae48b6a76dedf0d3790e012d03f407c2d">FNET_CFG_RAW</a></li>
<li><a class="el" href="group__fnet__stack__config.html#ga4f21e8386fea84053305023a546ace78">FNET_CFG_SOCKET_BSD_NAMES</a></li>
<li><a class="el" href="group__fnet__stack__config.html#ga9a208b570fa859a8ab4a62dba5c6b4e0">FNET_CFG_SOCKET_CALLBACK_ON_RX</a> </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacbab4078ea6d069ffbd954dd41b9a8f0" name="gacbab4078ea6d069ffbd954dd41b9a8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbab4078ea6d069ffbd954dd41b9a8f0">&#9670;&#160;</a></span>FNET_HTONL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_HTONL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>long_var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(long_var)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga23d24f9f1954e5a63654329747309893" name="ga23d24f9f1954e5a63654329747309893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23d24f9f1954e5a63654329747309893">&#9670;&#160;</a></span>fnet_htonl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fnet_htonl</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>long_var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(long_var)  <span class="comment">/* Convert 32 bit integer from host- to network byte order.*/</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="gae5835961024ae0f8af527125e89fab8d" name="gae5835961024ae0f8af527125e89fab8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5835961024ae0f8af527125e89fab8d">&#9670;&#160;</a></span>FNET_HTONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_HTONS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>short_var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(short_var)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6907eec60ba522bbc2bb68f2eee6d660" name="ga6907eec60ba522bbc2bb68f2eee6d660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6907eec60ba522bbc2bb68f2eee6d660">&#9670;&#160;</a></span>fnet_htons</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fnet_htons</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>short_var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(short_var) <span class="comment">/* Convert 16 bit integer from host- to network byte order.*/</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3955fe50337bce478a59591f7fb689fc" name="ga3955fe50337bce478a59591f7fb689fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3955fe50337bce478a59591f7fb689fc">&#9670;&#160;</a></span>FNET_IP4_ADDR1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_ADDR1</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ipaddr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((fnet_uint8_t)(fnet_ntohl(ipaddr) &gt;&gt; 24U) &amp; 0xffU)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga62aabd97bbc2f9b63ee2dbf4cba09255" name="ga62aabd97bbc2f9b63ee2dbf4cba09255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62aabd97bbc2f9b63ee2dbf4cba09255">&#9670;&#160;</a></span>FNET_IP4_ADDR2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_ADDR2</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ipaddr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((fnet_uint8_t)(fnet_ntohl(ipaddr) &gt;&gt; 16U) &amp; 0xffU)</div>
</div><!-- fragment -->
</div>
</div>
<a id="gafeaa04ea9ec4ef45e3d263d28df22fb1" name="gafeaa04ea9ec4ef45e3d263d28df22fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeaa04ea9ec4ef45e3d263d28df22fb1">&#9670;&#160;</a></span>FNET_IP4_ADDR3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_ADDR3</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ipaddr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((fnet_uint8_t)(fnet_ntohl(ipaddr) &gt;&gt; 8U) &amp; 0xffU)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga876c64413c0fde7fbe8254079ab61d5f" name="ga876c64413c0fde7fbe8254079ab61d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga876c64413c0fde7fbe8254079ab61d5f">&#9670;&#160;</a></span>FNET_IP4_ADDR4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_ADDR4</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ipaddr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((fnet_uint8_t)(fnet_ntohl(ipaddr)) &amp; 0xffU)</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaeb3a99598e791317b7aa8ed69970c5b8" name="gaeb3a99598e791317b7aa8ed69970c5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb3a99598e791317b7aa8ed69970c5b8">&#9670;&#160;</a></span>FNET_IP4_ADDR_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_ADDR_INIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the standard dotted-decimal notation <code>a.b.c.d</code> to an integer value, suitable for use as an Internet address (in network byte order). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First octet of an IP address. </td></tr>
    <tr><td class="paramname">b</td><td>Second octet of an IP address. </td></tr>
    <tr><td class="paramname">c</td><td>Third octet of an IP address. </td></tr>
    <tr><td class="paramname">d</td><td>Fourth octet of an IP address.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4430368ece2aabefeabadf5004244011" name="ga4430368ece2aabefeabadf5004244011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4430368ece2aabefeabadf5004244011">&#9670;&#160;</a></span>FNET_IP4_ADDR_IS_MULTICAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_ADDR_IS_MULTICAST</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(FNET_IP4_CLASS_D(addr)?<a class="code hl_enumvalue" href="group__fnet__stdlib.html#ggae066ef031201bb2ccac8febf4707fd0ea45d0eaf77f5f90921937ef5d2858e71b">FNET_TRUE</a>:<a class="code hl_enumvalue" href="group__fnet__stdlib.html#ggae066ef031201bb2ccac8febf4707fd0eaeb71405719049525566ed60973c0da7c">FNET_FALSE</a>)</div>
<div class="ttc" id="agroup__fnet__stdlib_html_ggae066ef031201bb2ccac8febf4707fd0ea45d0eaf77f5f90921937ef5d2858e71b"><div class="ttname"><a href="group__fnet__stdlib.html#ggae066ef031201bb2ccac8febf4707fd0ea45d0eaf77f5f90921937ef5d2858e71b">FNET_TRUE</a></div><div class="ttdeci">@ FNET_TRUE</div><div class="ttdoc">TRUE Boolean value.</div><div class="ttdef"><b>Definition</b> fnet_stdlib.h:82</div></div>
<div class="ttc" id="agroup__fnet__stdlib_html_ggae066ef031201bb2ccac8febf4707fd0eaeb71405719049525566ed60973c0da7c"><div class="ttname"><a href="group__fnet__stdlib.html#ggae066ef031201bb2ccac8febf4707fd0eaeb71405719049525566ed60973c0da7c">FNET_FALSE</a></div><div class="ttdeci">@ FNET_FALSE</div><div class="ttdoc">FALSE Boolean value.</div><div class="ttdef"><b>Definition</b> fnet_stdlib.h:81</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad9dbd70dfa180057f43a0f90adc91592" name="gad9dbd70dfa180057f43a0f90adc91592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9dbd70dfa180057f43a0f90adc91592">&#9670;&#160;</a></span>FNET_IP4_ADDR_IS_UNSPECIFIED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_ADDR_IS_UNSPECIFIED</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((addr) == <a class="code hl_define" href="lwip_2inet_8h.html#a5d1940045dc2e7de552f3d4ff13a74ab">INADDR_ANY</a>)?<a class="code hl_enumvalue" href="group__fnet__stdlib.html#ggae066ef031201bb2ccac8febf4707fd0ea45d0eaf77f5f90921937ef5d2858e71b">FNET_TRUE</a>:<a class="code hl_enumvalue" href="group__fnet__stdlib.html#ggae066ef031201bb2ccac8febf4707fd0eaeb71405719049525566ed60973c0da7c">FNET_FALSE</a>)</div>
<div class="ttc" id="alwip_2inet_8h_html_a5d1940045dc2e7de552f3d4ff13a74ab"><div class="ttname"><a href="lwip_2inet_8h.html#a5d1940045dc2e7de552f3d4ff13a74ab">INADDR_ANY</a></div><div class="ttdeci">#define INADDR_ANY</div><div class="ttdef"><b>Definition</b> inet.h:75</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gafe0c16fd6678d2a3f7fbb732ca86edc9" name="gafe0c16fd6678d2a3f7fbb732ca86edc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe0c16fd6678d2a3f7fbb732ca86edc9">&#9670;&#160;</a></span>FNET_IP4_ADDR_STR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_ADDR_STR_SIZE&#160;&#160;&#160;sizeof(&quot;255.255.255.255&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the string buffer that will contain null-terminated ASCII string of an IPv4 address in standard "." notation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga5526f421218aba24311e9abee1033690" title="Converts an IPv4 address into a string in Internet standard dotted-decimal format.">fnet_inet_ntoa</a>, <a class="el" href="#ga77933fd49752e533874747932ebac998" title="Converts IPv4 or IPv6 address from binary to text form.">fnet_inet_ntop</a> </dd></dl>

</div>
</div>
<a id="ga99d101b4ae917a2b053f310f0b5b7a56" name="ga99d101b4ae917a2b053f310f0b5b7a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99d101b4ae917a2b053f310f0b5b7a56">&#9670;&#160;</a></span>FNET_IP4_BADCLASS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_BADCLASS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">FNET_IP4_CLASS_E(i)</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae6eea6691f13980a9d96024037ca088e" name="gae6eea6691f13980a9d96024037ca088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6eea6691f13980a9d96024037ca088e">&#9670;&#160;</a></span>FNET_IP4_CLASS_A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_CLASS_A</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((<a class="code hl_typedef" href="#gaec5b5f5986cbfcceb9cbebce69fcb939">fnet_ip4_addr_t</a>)(i) &amp; FNET_HTONL(0x80000000U)) == 0U)</div>
<div class="ttc" id="agroup__fnet__socket_html_gaec5b5f5986cbfcceb9cbebce69fcb939"><div class="ttname"><a href="#gaec5b5f5986cbfcceb9cbebce69fcb939">fnet_ip4_addr_t</a></div><div class="ttdeci">fnet_uint32_t fnet_ip4_addr_t</div><div class="ttdoc">32-bit IPv4 address type.</div><div class="ttdef"><b>Definition</b> fnet_ip.h:36</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9cbb7e1888f21a58105bf162b6d02bb7" name="ga9cbb7e1888f21a58105bf162b6d02bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cbb7e1888f21a58105bf162b6d02bb7">&#9670;&#160;</a></span>FNET_IP4_CLASS_B</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_CLASS_B</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((<a class="code hl_typedef" href="#gaec5b5f5986cbfcceb9cbebce69fcb939">fnet_ip4_addr_t</a>)(i) &amp; FNET_HTONL(0xc0000000U)) == FNET_HTONL(0x80000000U))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga28cd8c1da1f70c779f20d0fdd09badac" name="ga28cd8c1da1f70c779f20d0fdd09badac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28cd8c1da1f70c779f20d0fdd09badac">&#9670;&#160;</a></span>FNET_IP4_CLASS_C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_CLASS_C</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((<a class="code hl_typedef" href="#gaec5b5f5986cbfcceb9cbebce69fcb939">fnet_ip4_addr_t</a>)(i) &amp; FNET_HTONL(0xe0000000U)) == FNET_HTONL(0xc0000000U))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga949f98ddd69b399d813ba4092c3a0fed" name="ga949f98ddd69b399d813ba4092c3a0fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga949f98ddd69b399d813ba4092c3a0fed">&#9670;&#160;</a></span>FNET_IP4_CLASS_D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_CLASS_D</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((<a class="code hl_typedef" href="#gaec5b5f5986cbfcceb9cbebce69fcb939">fnet_ip4_addr_t</a>)(i) &amp; FNET_HTONL(0xf0000000U)) == FNET_HTONL(0xe0000000U))</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac3205d1bcf4ce9ad67ec1c6983ec1d52" name="gac3205d1bcf4ce9ad67ec1c6983ec1d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3205d1bcf4ce9ad67ec1c6983ec1d52">&#9670;&#160;</a></span>FNET_IP4_CLASS_E</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_CLASS_E</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((<a class="code hl_typedef" href="#gaec5b5f5986cbfcceb9cbebce69fcb939">fnet_ip4_addr_t</a>)(i) &amp; FNET_HTONL(0xf0000000U)) == FNET_HTONL(0xf0000000U))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8f6eb6f47bf0f98c121b8e1b43dff180" name="ga8f6eb6f47bf0f98c121b8e1b43dff180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f6eb6f47bf0f98c121b8e1b43dff180">&#9670;&#160;</a></span>FNET_IP4_EXPERIMENTAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP4_EXPERIMENTAL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">FNET_IP4_CLASS_E(i)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8d8a8b5c8ac879f744b3884e32bc2efd" name="ga8d8a8b5c8ac879f744b3884e32bc2efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8a8b5c8ac879f744b3884e32bc2efd">&#9670;&#160;</a></span>FNET_IP6_ADDR_STR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP6_ADDR_STR_SIZE&#160;&#160;&#160;sizeof(&quot;abcd:abcd:abcd:abcd:abcd:abcd:abcd:abcd&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the string buffer that will contain null-terminated ASCII string of an IPv6 address in standard ":" notation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga77933fd49752e533874747932ebac998" title="Converts IPv4 or IPv6 address from binary to text form.">fnet_inet_ntop</a> </dd></dl>

</div>
</div>
<a id="ga425d2abe65e9b5553b5a34cd8728f285" name="ga425d2abe65e9b5553b5a34cd8728f285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga425d2abe65e9b5553b5a34cd8728f285">&#9670;&#160;</a></span>FNET_IP_ADDR_STR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_IP_ADDR_STR_SIZE&#160;&#160;&#160;<a class="el" href="#gafe0c16fd6678d2a3f7fbb732ca86edc9">FNET_IP4_ADDR_STR_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the string buffer that will contain null-terminated ASCII string of an IP address. It depends on if disabled or enabled IPv6. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga5526f421218aba24311e9abee1033690" title="Converts an IPv4 address into a string in Internet standard dotted-decimal format.">fnet_inet_ntoa</a>, <a class="el" href="#ga77933fd49752e533874747932ebac998" title="Converts IPv4 or IPv6 address from binary to text form.">fnet_inet_ntop</a> </dd></dl>

</div>
</div>
<a id="ga777f60f62d40d3896f6d948709e763ee" name="ga777f60f62d40d3896f6d948709e763ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga777f60f62d40d3896f6d948709e763ee">&#9670;&#160;</a></span>FNET_NTOHL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_NTOHL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>long_var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(long_var)</div>
</div><!-- fragment -->
</div>
</div>
<a id="gafd59b4daf04d283968471bfa5c75e2c5" name="gafd59b4daf04d283968471bfa5c75e2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd59b4daf04d283968471bfa5c75e2c5">&#9670;&#160;</a></span>fnet_ntohl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fnet_ntohl</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>long_var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(long_var)  <span class="comment">/* Convert 32 bit integer from network - to host byte order.*/</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3df51a882734254b18c8b3705bc2b94a" name="ga3df51a882734254b18c8b3705bc2b94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3df51a882734254b18c8b3705bc2b94a">&#9670;&#160;</a></span>FNET_NTOHS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FNET_NTOHS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>short_var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(short_var)</div>
</div><!-- fragment -->
</div>
</div>
<a id="gad3fb42991ecd8b089dea905232ea3a4f" name="gad3fb42991ecd8b089dea905232ea3a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3fb42991ecd8b089dea905232ea3a4f">&#9670;&#160;</a></span>fnet_ntohs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fnet_ntohs</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>short_var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(short_var) <span class="comment">/* Convert 16 bit integer from network - to host byte order.*/</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1d48bbeab659f390e264b58551df26f3" name="ga1d48bbeab659f390e264b58551df26f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d48bbeab659f390e264b58551df26f3">&#9670;&#160;</a></span>IPOPT_COPIED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPOPT_COPIED</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((t)&amp;0x80U)    <span class="comment">/* 1-bit copied flag */</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="gae2a2f9aa4c11b7391b64290448a0f3df" name="gae2a2f9aa4c11b7391b64290448a0f3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a2f9aa4c11b7391b64290448a0f3df">&#9670;&#160;</a></span>IPOPT_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPOPT_NUMBER</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((t)&amp;0x1fU)    <span class="comment">/* 5-bit number field */</span></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2297bb08ea37b8793a25b085ee5e5275" name="ga2297bb08ea37b8793a25b085ee5e5275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2297bb08ea37b8793a25b085ee5e5275">&#9670;&#160;</a></span>fnet_address_family_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef fnet_uint16_t <a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Address family type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae77ae24b14b7b7f294f3e04121173f12" title="Unspecified address family.">AF_UNSPEC</a>, <a class="el" href="#ga9930604d0e32588eae76f43ca38e7826" title="IPv4 address family.">AF_INET</a>, <a class="el" href="#gaa03706b2738b9a58d4985dfbe99e1bac" title="IPv6 address family.">AF_INET6</a>, <a class="el" href="#ga5dcf68f46ca343a4af7b65972b5a02c0" title="Bitmask of supported address families.">AF_SUPPORTED</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac23dfda01e1334a4bfe9c86036169529" name="gac23dfda01e1334a4bfe9c86036169529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac23dfda01e1334a4bfe9c86036169529">&#9670;&#160;</a></span>fnet_msg_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gac23dfda01e1334a4bfe9c86036169529">fnet_msg_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The flags parameters for receiving and sending functions <a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv()</a>, <a class="el" href="#ga30cdb74342d222bb10b53a3571b72398">fnet_socket_recvfrom()</a>, <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send()</a>, and <a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto()</a>. </p>
<p>The optional flag specifies the way, in which the call is made. It can be constructed by using the bitwise OR. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac23dfda01e1334a4bfe9c86036169529a890be29a00a90e15eb7e50a1cbba95ab" name="ggac23dfda01e1334a4bfe9c86036169529a890be29a00a90e15eb7e50a1cbba95ab"></a>MSG_OOB&#160;</td><td class="fielddoc"><p>Process out-of-band data instead of regular data. <br  />
 This option is avalable only if <a class="el" href="group__fnet__stack__config.html#ga179713f740096f6f9681d62857b15d81">FNET_CFG_TCP_URGENT</a> is set to <code>1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac23dfda01e1334a4bfe9c86036169529a41ac2d38ac3e36d430b72abfb78273e5" name="ggac23dfda01e1334a4bfe9c86036169529a41ac2d38ac3e36d430b72abfb78273e5"></a>MSG_PEEK&#160;</td><td class="fielddoc"><p>Receive a copy of the data without consuming it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac23dfda01e1334a4bfe9c86036169529a8ec01a7477627843f34cfab30bfe4c84" name="ggac23dfda01e1334a4bfe9c86036169529a8ec01a7477627843f34cfab30bfe4c84"></a>MSG_DONTROUTE&#160;</td><td class="fielddoc"><p>Send without using routing tables. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaedf5dba7175dbc74b729bbab381a009a" name="gaedf5dba7175dbc74b729bbab381a009a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf5dba7175dbc74b729bbab381a009a">&#9670;&#160;</a></span>fnet_protocol_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaedf5dba7175dbc74b729bbab381a009a">fnet_protocol_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protocol numbers and Level numbers for the <a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt()</a> and the <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaedf5dba7175dbc74b729bbab381a009aa334b0a4a5a3e331e7c7864471e9eab08" name="ggaedf5dba7175dbc74b729bbab381a009aa334b0a4a5a3e331e7c7864471e9eab08"></a>IPPROTO_IP&#160;</td><td class="fielddoc"><p>IPv4 options level number for <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a> and <a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaedf5dba7175dbc74b729bbab381a009aa7ccd735b73f6955ae2f4abf3e7ca6bb4" name="ggaedf5dba7175dbc74b729bbab381a009aa7ccd735b73f6955ae2f4abf3e7ca6bb4"></a>IPPROTO_ICMP&#160;</td><td class="fielddoc"><p>ICMPv4 protocol number. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaedf5dba7175dbc74b729bbab381a009aa4cbcb48be0cd8eb6fb5b5741f1c7b639" name="ggaedf5dba7175dbc74b729bbab381a009aa4cbcb48be0cd8eb6fb5b5741f1c7b639"></a>IPPROTO_IGMP&#160;</td><td class="fielddoc"><p>IGMP protocol number. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaedf5dba7175dbc74b729bbab381a009aa4a3c433d15859f62bacc06312791a45e" name="ggaedf5dba7175dbc74b729bbab381a009aa4a3c433d15859f62bacc06312791a45e"></a>IPPROTO_TCP&#160;</td><td class="fielddoc"><p>TCP protocol number; TCP options level number for <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a> and <a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaedf5dba7175dbc74b729bbab381a009aabd7dfb22e255a4eed332f41de12d7321" name="ggaedf5dba7175dbc74b729bbab381a009aabd7dfb22e255a4eed332f41de12d7321"></a>IPPROTO_UDP&#160;</td><td class="fielddoc"><p>UDP protocol number. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaedf5dba7175dbc74b729bbab381a009aa892549243e60ed1e04e88a14b44d8185" name="ggaedf5dba7175dbc74b729bbab381a009aa892549243e60ed1e04e88a14b44d8185"></a>IPPROTO_IPV6&#160;</td><td class="fielddoc"><p>IPv6 options level number for <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a> and <a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaedf5dba7175dbc74b729bbab381a009aaeeff57e3cf726718a92b2138e5842926" name="ggaedf5dba7175dbc74b729bbab381a009aaeeff57e3cf726718a92b2138e5842926"></a>IPPROTO_ICMPV6&#160;</td><td class="fielddoc"><p>ICMPv6 protocol number. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaedf5dba7175dbc74b729bbab381a009aa1d3add04b81641b0740db2a8f4ef207c" name="ggaedf5dba7175dbc74b729bbab381a009aa1d3add04b81641b0740db2a8f4ef207c"></a>SOL_SOCKET&#160;</td><td class="fielddoc"><p><a class="el" href="classSocket.html">Socket</a> options level number for <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a> and <a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt()</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadaccafa9b8a75cd59ae89842feb37e48" name="gadaccafa9b8a75cd59ae89842feb37e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaccafa9b8a75cd59ae89842feb37e48">&#9670;&#160;</a></span>fnet_sd_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gadaccafa9b8a75cd59ae89842feb37e48">fnet_sd_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The flags used by <a class="el" href="#ga03aa9c1387d19cbb241e4e058a86e39a">fnet_socket_shutdown()</a>. </p>
<p>They describe what types of socket operation will no longer be allowed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadaccafa9b8a75cd59ae89842feb37e48afa088e64138dfb8f58de1432d77577ac" name="ggadaccafa9b8a75cd59ae89842feb37e48afa088e64138dfb8f58de1432d77577ac"></a>SD_READ&#160;</td><td class="fielddoc"><p>Data receiving is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadaccafa9b8a75cd59ae89842feb37e48ac9c468da07fb6d142eb5817545c2c94b" name="ggadaccafa9b8a75cd59ae89842feb37e48ac9c468da07fb6d142eb5817545c2c94b"></a>SD_WRITE&#160;</td><td class="fielddoc"><p>Data sending is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadaccafa9b8a75cd59ae89842feb37e48a545eaee6b6155691ef979c90f6123aee" name="ggadaccafa9b8a75cd59ae89842feb37e48a545eaee6b6155691ef979c90f6123aee"></a>SD_BOTH&#160;</td><td class="fielddoc"><p>Both receiving and sending are disabled. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga989481a2cee0291e70f9076a091eddf1" name="ga989481a2cee0291e70f9076a091eddf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga989481a2cee0291e70f9076a091eddf1">&#9670;&#160;</a></span>fnet_socket_options_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga989481a2cee0291e70f9076a091eddf1">fnet_socket_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSocket.html">Socket</a> options for the <a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000">fnet_socket_setopt()</a> and the <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a>. </p>
<table class="doxtable">
<caption><a class="el" href="classSocket.html">Socket</a> SOL_SOCKET, IPPROTO_TCP, IPPROTO_IP and IPPROTO_IPV6 level options</caption>
<tr class="fnet_td_grey">
<th align="center">Option</th><th align="center">Option Type</th><th align="center">Default Value</th><th align="center">Read/Write  </th></tr>
<tr>
<td><a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39aa985052d483e1e379df8fe24e5ae9323">SO_ACCEPTCONN</a></td><td>fnet_uint32_t</td><td>0</td><td>R  </td></tr>
<tr>
<td><a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a4540c38a6d26cae663b162aa08b2cd1b">SO_KEEPALIVE</a></td><td>fnet_uint32_t</td><td>1</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a934ec9d2fb58639026a17bb71d907c88">SO_DONTROUTE</a></td><td>fnet_uint32_t</td><td>0</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a6856768825eabef55d9d4175020da464">SO_LINGER</a></td><td>struct <a class="el" href="structlinger.html">linger</a></td><td>{0,0}</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a68027692aae2685592434c77096d14c3">SO_OOBINLINE</a></td><td>fnet_uint32_t</td><td>0</td><td>RW  </td></tr>
<tr>
<td>SO_SNDBUF</td><td>fnet_uint32_t </td><td><a class="el" href="group__fnet__stack__config.html#ga7e05e995ebd8a2d6b654270aaefe074f">FNET_CFG_SOCKET_UDP_TX_BUF_SIZE</a> for UDP <br  />
 <a class="el" href="group__fnet__stack__config.html#ga550b6ca6fb7a78cfe7e5d062b17e77bb">FNET_CFG_SOCKET_TCP_TX_BUF_SIZE</a> for TCP</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a2b21411458e656e4dae50ed07bc49fe9">SO_RCVBUF</a></td><td>fnet_uint32_t </td><td><a class="el" href="group__fnet__stack__config.html#gaa68c0f4165b03e295585bfea6e39b6fb">FNET_CFG_SOCKET_UDP_RX_BUF_SIZE</a> for UDP <br  />
 <a class="el" href="group__fnet__stack__config.html#ga441698ce8bbf7b7f97b670ca034a05a1">FNET_CFG_SOCKET_TCP_RX_BUF_SIZE</a> for TCP</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a43b410a56c993383c754b4c8a6d55063">SO_STATE</a></td><td><a class="el" href="#ga3b410682d2a08c9eda8d9337731e5f9f">fnet_socket_state_t</a></td><td><a class="el" href="#gga3b410682d2a08c9eda8d9337731e5f9fa3b2500a7ffff9084fdca145c1a37b722">SS_UNCONNECTED</a></td><td>R  </td></tr>
<tr>
<td><a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39ac9c377737c401ee3826e199d5ec2c6c7">SO_ERROR</a></td><td><a class="el" href="group__fnet__error.html#gad088b58e95c4eee45363286fe99807ec">fnet_error_t</a></td><td><a class="el" href="group__fnet__error.html#ggad088b58e95c4eee45363286fe99807eca2276d9e865f4eb496cf886b0c08c24d8">FNET_ERR_OK</a></td><td>R  </td></tr>
<tr>
<td><a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a518fcdee784798ddf4db7a593e794340">SO_TYPE</a></td><td><a class="el" href="#ga9f1b6a1b9f22d86025b8d9d5b473ec06">fnet_socket_type_t</a></td><td>SOCK_DGRAM for UDP <br  />
 SOCK_STREAM for TCP</td><td>R  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1abf4f6c73b2615827c8ab17526d6ecc67">SO_RCVNUM</a></td><td>fnet_uint32_t</td><td>0</td><td>R  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1aea89904cbe143cf731f0eb03ea2ee9b9">SO_SNDNUM</a></td><td>fnet_uint32_t</td><td>0</td><td>R  </td></tr>
<tr>
<td>TCP_MSS</td><td>fnet_uint32_t</td><td>536</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a7cfe46d0d1bb6edbfda3b40e1e4e9a6f">TCP_BSD</a></td><td>fnet_uint32_t</td><td>1</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a54ab75c4bde1187c7f624e6bab97699c">TCP_NODELAY</a></td><td>fnet_uint32_t</td><td>1</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a6c1da222c2434c4627e761e5ea15d21f">TCP_FINRCVD</a></td><td>fnet_uint32_t</td><td>0</td><td>R  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a692d762f523124219c7519baf6c6e8fa">TCP_URGRCVD</a></td><td>fnet_uint32_t</td><td>0</td><td>R  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a42e07e3648f9ee2234d826624d3b0f01">TCP_KEEPIDLE</a></td><td>fnet_uint32_t</td><td>7200</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a463c5a82fcf2d4ce8f7bddb179107cc2">TCP_KEEPINTVL</a></td><td>fnet_uint32_t</td><td>75</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a5523ba3ac6c76dd6ec90703b26de7fc8">TCP_KEEPCNT</a></td><td>fnet_uint32_t</td><td>8</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a13abe4ff93f7ce743a78404d5ca0af8c">IP_TOS</a></td><td>fnet_uint32_t</td><td>0</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a96d904e00582f92a7ac3bcc9b2f132b7">IP_TTL</a></td><td>fnet_uint32_t</td><td>64</td><td>RW  </td></tr>
<tr>
<td>IP_MULTICAST_TTL</td><td>fnet_uint32_t</td><td>1</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="group__WIFI__SOCKET.html#gga43415b7d29ce7f799c0c2a74b3ea6fe4aca99f4e845aa1795a85d704f5472a511">IP_ADD_MEMBERSHIP</a></td><td><a class="el" href="structip__mreq.html">ip_mreq</a></td><td>N/A</td><td>W  </td></tr>
<tr>
<td><a class="el" href="group__WIFI__SOCKET.html#gga43415b7d29ce7f799c0c2a74b3ea6fe4a489c5cfbb00b3cee4fe9288fa40f4a01">IP_DROP_MEMBERSHIP</a></td><td><a class="el" href="structip__mreq.html">ip_mreq</a></td><td>N/A</td><td>W  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a5aec4eba3484f8c48a8461a5152ba068">IPV6_UNICAST_HOPS</a></td><td>fnet_uint32_t</td><td>0 (64)</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a1d35209096975f6463e69f084d22fd3e">IPV6_MULTICAST_HOPS</a></td><td>fnet_uint32_t</td><td>1</td><td>RW  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1afda4e055e7c3f064791042e536118639">IPV6_JOIN_GROUP</a></td><td><a class="el" href="structipv6__mreq.html">ipv6_mreq</a></td><td>N/A</td><td>W  </td></tr>
<tr>
<td><a class="el" href="#gga989481a2cee0291e70f9076a091eddf1ac8aaa87d8025716cc314424809ef71b4">IPV6_LEAVE_GROUP</a></td><td><a class="el" href="structipv6__mreq.html">ipv6_mreq</a></td><td>N/A</td><td>W  </td></tr>
</table>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1aa985052d483e1e379df8fe24e5ae9323" name="gga989481a2cee0291e70f9076a091eddf1aa985052d483e1e379df8fe24e5ae9323"></a>SO_ACCEPTCONN&#160;</td><td class="fielddoc"><p>Returns <code>1</code> if a socket is in listening mode and returns <code>0</code> when vice versa. This is the read-only option and it is valid only for connection-oriented protocols (TCP). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a4540c38a6d26cae663b162aa08b2cd1b" name="gga989481a2cee0291e70f9076a091eddf1a4540c38a6d26cae663b162aa08b2cd1b"></a>SO_KEEPALIVE&#160;</td><td class="fielddoc"><p>This option enables keep-alive probes for a socket connection. These probes are used to maintain a TCP connection and regularly test the connection to ensure that it's still available. It is only valid for connection-oriented protocols (TCP). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a934ec9d2fb58639026a17bb71d907c88" name="gga989481a2cee0291e70f9076a091eddf1a934ec9d2fb58639026a17bb71d907c88"></a>SO_DONTROUTE&#160;</td><td class="fielddoc"><p>This option enables bypassing of a routing algorithm. It means that the network interface tries to send a datagram without a gateway. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a6856768825eabef55d9d4175020da464" name="gga989481a2cee0291e70f9076a091eddf1a6856768825eabef55d9d4175020da464"></a>SO_LINGER&#160;</td><td class="fielddoc"><p>This option controls the action taken when unsent data is present, and <a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373">fnet_socket_close()</a> is called. This option is defined by the <a class="el" href="structlinger.html">linger</a> structure. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a68027692aae2685592434c77096d14c3" name="gga989481a2cee0291e70f9076a091eddf1a68027692aae2685592434c77096d14c3"></a>SO_OOBINLINE&#160;</td><td class="fielddoc"><p>This option specifies that out-of-band (OOB) data will be received in line with regular data. It is valid only for the TCP protocol. <br  />
 This option is avalable only if <a class="el" href="group__fnet__stack__config.html#ga179713f740096f6f9681d62857b15d81">FNET_CFG_TCP_URGENT</a> is set to <code>1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a1df7a92f3c90d78f7be79280937cc48f" name="gga989481a2cee0291e70f9076a091eddf1a1df7a92f3c90d78f7be79280937cc48f"></a>SO_SNDBUF&#160;</td><td class="fielddoc"><p>This option defines the maximum per-socket buffer size for output data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a2b21411458e656e4dae50ed07bc49fe9" name="gga989481a2cee0291e70f9076a091eddf1a2b21411458e656e4dae50ed07bc49fe9"></a>SO_RCVBUF&#160;</td><td class="fielddoc"><p>This option defines the maximum per-socket buffer size for input data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a43b410a56c993383c754b4c8a6d55063" name="gga989481a2cee0291e70f9076a091eddf1a43b410a56c993383c754b4c8a6d55063"></a>SO_STATE&#160;</td><td class="fielddoc"><p>This option defines the current state of the socket.<br  />
 This is the read-only option and it is defined by the <a class="el" href="#ga3b410682d2a08c9eda8d9337731e5f9f">fnet_socket_state_t</a> type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1ac9c377737c401ee3826e199d5ec2c6c7" name="gga989481a2cee0291e70f9076a091eddf1ac9c377737c401ee3826e199d5ec2c6c7"></a>SO_ERROR&#160;</td><td class="fielddoc"><p>This option returns a per-socket-based error code.<br  />
 The error code is defined by the <a class="el" href="group__fnet__error.html#gad088b58e95c4eee45363286fe99807ec">fnet_error_t</a> type.<br  />
 After the error value has been read in the <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt</a> function, it is cleared. But a successful call using the socket routines does not clear the socket-based error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a518fcdee784798ddf4db7a593e794340" name="gga989481a2cee0291e70f9076a091eddf1a518fcdee784798ddf4db7a593e794340"></a>SO_TYPE&#160;</td><td class="fielddoc"><p>This option defines the type of the socket. This is a read-only option and it is defined by the <a class="el" href="#ga9f1b6a1b9f22d86025b8d9d5b473ec06">fnet_socket_type_t</a> type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1abf4f6c73b2615827c8ab17526d6ecc67" name="gga989481a2cee0291e70f9076a091eddf1abf4f6c73b2615827c8ab17526d6ecc67"></a>SO_RCVNUM&#160;</td><td class="fielddoc"><p>This option is used to determine the amount of data pending in the socket-input buffer.<br  />
 This is a read-only option. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1aea89904cbe143cf731f0eb03ea2ee9b9" name="gga989481a2cee0291e70f9076a091eddf1aea89904cbe143cf731f0eb03ea2ee9b9"></a>SO_SNDNUM&#160;</td><td class="fielddoc"><p>This option is used to determine the amount of data in the socket output buffer. <br  />
 This is a read-only option. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a964897880427803d0ef2ed8ed6a2942a" name="gga989481a2cee0291e70f9076a091eddf1a964897880427803d0ef2ed8ed6a2942a"></a>TCP_MSS&#160;</td><td class="fielddoc"><p>This option defines the maximum size of the input segments (MSS). <br  />
 The TCP Maximum Segment Size (MSS) defines the maximum amount of data that a host is willing to accept in a single TCP segment.<br  />
 This Maximum Segment Size (MSS) announcement is sent from the data receiver to the data sender and says "I can accept TCP segments
                      up to size X". The size (X) may be larger or smaller than the default.<br  />
 The MSS counts only data octets in the segment, it does not count the TCP header or the IP header.<br  />
 The default value is defined by the <a class="el" href="group__fnet__stack__config.html#gadcf09da5eeaf977645a98592858b6acd">FNET_CFG_SOCKET_TCP_MSS</a> user-configuration option. <br  />
 This option can be set to: </p>
<ul>
<li><code>0</code> = The selection of the MSS is automatic and is based on the MTU of the outgoing interface minus 40 (does not include the 20 byte IP header and the 20 byte TCP header).<br  />
 It is done to assist in avoiding of IP fragmentation at the endpoints of the TCP connection.</li>
<li>Non-zero value (up to 64K) = The TCP segment could be as large as 64K (the maximum IP datagram size), but it could be fragmented at the IP layer in order to be transmitted across the network to the receiving host. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a7cfe46d0d1bb6edbfda3b40e1e4e9a6f" name="gga989481a2cee0291e70f9076a091eddf1a7cfe46d0d1bb6edbfda3b40e1e4e9a6f"></a>TCP_BSD&#160;</td><td class="fielddoc"><p>If this option is set to <code>1</code>, the BSD interpretation of the urgent pointer is used. In this case the urgent pointer of the TCP segment points to the next byte following after the urgent byte. Most of the TCP implementations use this interpretation by default.<br  />
 If this option is set to <code>0</code>, the interpretation of the TCP specification is used. In this case the urgent pointer of the TCP segment points to the urgent byte. <br  />
 This option is avalable only if <a class="el" href="group__fnet__stack__config.html#ga179713f740096f6f9681d62857b15d81">FNET_CFG_TCP_URGENT</a> is set to <code>1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a54ab75c4bde1187c7f624e6bab97699c" name="gga989481a2cee0291e70f9076a091eddf1a54ab75c4bde1187c7f624e6bab97699c"></a>TCP_NODELAY&#160;</td><td class="fielddoc"><p>If this option is set to <code>1</code>, the Nagle algorithm is disabled (and vice versa). <br  />
 The Nagle algorithm is effective in reducing the number of small packets sent by the host by essentially buffering send data, if there is unacknowledged data already "in flight", or until a full-size packet can be sent.<br  />
 But for some applications this algorithm can impede performance, especially for a bulky data transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a6c1da222c2434c4627e761e5ea15d21f" name="gga989481a2cee0291e70f9076a091eddf1a6c1da222c2434c4627e761e5ea15d21f"></a>TCP_FINRCVD&#160;</td><td class="fielddoc"><p>This option is set when the final (FIN) segment arrives. <br  />
 This option indicates that another side will not send any data in the current connection.<br  />
 This is the read-only option. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a692d762f523124219c7519baf6c6e8fa" name="gga989481a2cee0291e70f9076a091eddf1a692d762f523124219c7519baf6c6e8fa"></a>TCP_URGRCVD&#160;</td><td class="fielddoc"><p>This option is set when the urgent byte arrives, and reset when this byte is read.<br  />
 This option can be set only if the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a68027692aae2685592434c77096d14c3">SO_OOBINLINE</a> option is set to <code>0</code>.<br  />
 This is the read-only option. <br  />
 This option is avalable only if <a class="el" href="group__fnet__stack__config.html#ga179713f740096f6f9681d62857b15d81">FNET_CFG_TCP_URGENT</a> is set to <code>1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a42e07e3648f9ee2234d826624d3b0f01" name="gga989481a2cee0291e70f9076a091eddf1a42e07e3648f9ee2234d826624d3b0f01"></a>TCP_KEEPIDLE&#160;</td><td class="fielddoc"><p>When the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a4540c38a6d26cae663b162aa08b2cd1b">SO_KEEPALIVE</a> option is enabled, TCP probes a connection that has been idle for some amount of time. The default value for this idle period is <code>7200</code> seconds (2 hours). The <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a42e07e3648f9ee2234d826624d3b0f01">TCP_KEEPIDLE</a> option can be used to affect this value for a given socket, and specifies the number of seconds of idle time between keepalive probes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a463c5a82fcf2d4ce8f7bddb179107cc2" name="gga989481a2cee0291e70f9076a091eddf1a463c5a82fcf2d4ce8f7bddb179107cc2"></a>TCP_KEEPINTVL&#160;</td><td class="fielddoc"><p>When the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a4540c38a6d26cae663b162aa08b2cd1b">SO_KEEPALIVE</a> option is enabled, TCP probes a connection that has been idle for some amount of time. If the remote system does not respond to a keepalive probe, TCP retransmits the probe after some amount of time. The default value for this retransmit interval is <code>75</code> seconds. The <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a463c5a82fcf2d4ce8f7bddb179107cc2">TCP_KEEPINTVL</a> option can be used to affect this value for a given socket, and specifies the number of seconds to wait before retransmitting a keepalive probe. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a5523ba3ac6c76dd6ec90703b26de7fc8" name="gga989481a2cee0291e70f9076a091eddf1a5523ba3ac6c76dd6ec90703b26de7fc8"></a>TCP_KEEPCNT&#160;</td><td class="fielddoc"><p>When the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a4540c38a6d26cae663b162aa08b2cd1b">SO_KEEPALIVE</a> option is enabled, TCP probes a connection that has been idle for some amount of time. If the remote system does not respond to a keepalive probe, TCP retransmits the probe a certain number of times before a connection is considered to be broken. The default value for this keepalive probe retransmit limit is <code>8</code>. The <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a5523ba3ac6c76dd6ec90703b26de7fc8">TCP_KEEPCNT</a> option can be used to affect this value for a given socket, and specifies the maximum number of keepalive probes to be sent. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a13abe4ff93f7ce743a78404d5ca0af8c" name="gga989481a2cee0291e70f9076a091eddf1a13abe4ff93f7ce743a78404d5ca0af8c"></a>IP_TOS&#160;</td><td class="fielddoc"><p>This option defines the IPv4 TOS (type-of-service) field for outgoing datagrams. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a96d904e00582f92a7ac3bcc9b2f132b7" name="gga989481a2cee0291e70f9076a091eddf1a96d904e00582f92a7ac3bcc9b2f132b7"></a>IP_TTL&#160;</td><td class="fielddoc"><p>This option defines the IPv4 TTL (time-to-live) vlaue for outgoing datagrams. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a86b4a9f6c127f6dbbe3034730b7632ad" name="gga989481a2cee0291e70f9076a091eddf1a86b4a9f6c127f6dbbe3034730b7632ad"></a>IP_MULTICAST_TTL&#160;</td><td class="fielddoc"><p>This option allows to change IPv4 "time to live" (TTL) value for outgoing multicast datagrams. Otherwise, multicast datagrams are sent with a default value of 1, to prevent them to be forwarded beyond the local network.<br  />
 This option is available only if <a class="el" href="group__fnet__stack__config.html#ga2f82db486f2abb903e955433c2968de5">FNET_CFG_MULTICAST</a> is set to <code>1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1aca99f4e845aa1795a85d704f5472a511" name="gga989481a2cee0291e70f9076a091eddf1aca99f4e845aa1795a85d704f5472a511"></a>IP_ADD_MEMBERSHIP&#160;</td><td class="fielddoc"><p>Join the socket to the IPv4 multicast group on the specified interface. It tells the system to receive packets on the network whose destination is the group address (but not its own). It is valid only for the SOCK_DGRAM (UDP) sockets.<br  />
 This option is available only if <a class="el" href="group__fnet__stack__config.html#ga2f82db486f2abb903e955433c2968de5">FNET_CFG_MULTICAST</a> is set to <code>1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a489c5cfbb00b3cee4fe9288fa40f4a01" name="gga989481a2cee0291e70f9076a091eddf1a489c5cfbb00b3cee4fe9288fa40f4a01"></a>IP_DROP_MEMBERSHIP&#160;</td><td class="fielddoc"><p>Drops membership to a IPv4 multicast group and interface.<br  />
 This option is available only if <a class="el" href="group__fnet__stack__config.html#ga2f82db486f2abb903e955433c2968de5">FNET_CFG_MULTICAST</a> is set to <code>1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a5aec4eba3484f8c48a8461a5152ba068" name="gga989481a2cee0291e70f9076a091eddf1a5aec4eba3484f8c48a8461a5152ba068"></a>IPV6_UNICAST_HOPS&#160;</td><td class="fielddoc"><p>This option defines hop limit used for outgoing unicast IPv6 packets. <br  />
 Its value can be from 0 till 255.<br  />
 By default the option is set to 0. It means that the hop limit is defined by local IPv6 router, otherwise it equals to 64. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1a1d35209096975f6463e69f084d22fd3e" name="gga989481a2cee0291e70f9076a091eddf1a1d35209096975f6463e69f084d22fd3e"></a>IPV6_MULTICAST_HOPS&#160;</td><td class="fielddoc"><p>Set the hop limit to use for outgoing multicast IPv6 packets.<br  />
 If IPV6_MULTICAST_HOPS is not set, the default is 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1afda4e055e7c3f064791042e536118639" name="gga989481a2cee0291e70f9076a091eddf1afda4e055e7c3f064791042e536118639"></a>IPV6_JOIN_GROUP&#160;</td><td class="fielddoc"><p>(RFC3493) Join a multicast group on a specified local interface.<br  />
 It is valid only for the SOCK_DGRAM (UDP) sockets. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga989481a2cee0291e70f9076a091eddf1ac8aaa87d8025716cc314424809ef71b4" name="gga989481a2cee0291e70f9076a091eddf1ac8aaa87d8025716cc314424809ef71b4"></a>IPV6_LEAVE_GROUP&#160;</td><td class="fielddoc"><p>(RFC3493) Leave a multicast group on a specified interface.<br  />
 It is valid only for the SOCK_DGRAM (UDP) sockets. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3b410682d2a08c9eda8d9337731e5f9f" name="ga3b410682d2a08c9eda8d9337731e5f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b410682d2a08c9eda8d9337731e5f9f">&#9670;&#160;</a></span>fnet_socket_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga3b410682d2a08c9eda8d9337731e5f9f">fnet_socket_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSocket.html">Socket</a> state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3b410682d2a08c9eda8d9337731e5f9fa3b2500a7ffff9084fdca145c1a37b722" name="gga3b410682d2a08c9eda8d9337731e5f9fa3b2500a7ffff9084fdca145c1a37b722"></a>SS_UNCONNECTED&#160;</td><td class="fielddoc"><p>Not connected to any socket. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3b410682d2a08c9eda8d9337731e5f9fa8407056ba960ba5990d4faf1a5df30a9" name="gga3b410682d2a08c9eda8d9337731e5f9fa8407056ba960ba5990d4faf1a5df30a9"></a>SS_CONNECTING&#160;</td><td class="fielddoc"><p>In process of connecting. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3b410682d2a08c9eda8d9337731e5f9fa097f95adc87c47e70cd008b417fbac57" name="gga3b410682d2a08c9eda8d9337731e5f9fa097f95adc87c47e70cd008b417fbac57"></a>SS_CONNECTED&#160;</td><td class="fielddoc"><p>Connected to a socket. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3b410682d2a08c9eda8d9337731e5f9fa91ff6bb9bbcae669b6944ffc3d884f29" name="gga3b410682d2a08c9eda8d9337731e5f9fa91ff6bb9bbcae669b6944ffc3d884f29"></a>SS_LISTENING&#160;</td><td class="fielddoc"><p>In listening state. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9f1b6a1b9f22d86025b8d9d5b473ec06" name="ga9f1b6a1b9f22d86025b8d9d5b473ec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f1b6a1b9f22d86025b8d9d5b473ec06">&#9670;&#160;</a></span>fnet_socket_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga9f1b6a1b9f22d86025b8d9d5b473ec06">fnet_socket_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSocket.html">Socket</a> types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9f1b6a1b9f22d86025b8d9d5b473ec06a9dc707447a82adf9a8eb5febe8c707ac" name="gga9f1b6a1b9f22d86025b8d9d5b473ec06a9dc707447a82adf9a8eb5febe8c707ac"></a>SOCK_UNSPEC&#160;</td><td class="fielddoc"><p>Unspecified socket type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f1b6a1b9f22d86025b8d9d5b473ec06ae3b7fb9487113a31d403b23aaeaad424" name="gga9f1b6a1b9f22d86025b8d9d5b473ec06ae3b7fb9487113a31d403b23aaeaad424"></a>SOCK_STREAM&#160;</td><td class="fielddoc"><p>Stream socket.<br  />
 Provides reliable, two-way, connection-based byte stream. It corresponds to the TCP protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f1b6a1b9f22d86025b8d9d5b473ec06a006b373a518eeeb717573f91e70d7fcc" name="gga9f1b6a1b9f22d86025b8d9d5b473ec06a006b373a518eeeb717573f91e70d7fcc"></a>SOCK_DGRAM&#160;</td><td class="fielddoc"><p>Datagram socket.<br  />
 Provides unreliable, connectionless datagrams. It corresponds to the UDP protocol. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f1b6a1b9f22d86025b8d9d5b473ec06ad78d54561daf9c4a7cda0ce115e3f231" name="gga9f1b6a1b9f22d86025b8d9d5b473ec06ad78d54561daf9c4a7cda0ce115e3f231"></a>SOCK_RAW&#160;</td><td class="fielddoc"><p>Raw socket.<br  />
 Raw sockets allow an application to have direct access to lower-level communication protocols. Raw sockets are intended to take advantage of some protocol feature that is not directly accessible through a normal interface, or to build new protocols on top of existing low-level protocols.<br  />
 It can be enabled by the <a class="el" href="group__fnet__stack__config.html#gae48b6a76dedf0d3790e012d03f407c2d">FNET_CFG_RAW</a> option. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga63a5f9262fe47d5373f446f4fe127f23" name="ga63a5f9262fe47d5373f446f4fe127f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63a5f9262fe47d5373f446f4fe127f23">&#9670;&#160;</a></span>fnet_inet_aton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_inet_aton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *</td>          <td class="paramname"><span class="paramname"><em>cp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structin__addr.html">in_addr</a> *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the string in the standard dotted-decimal notation to an integer value, suitable for use as an IPv4 address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>Null-terminated character string representing a number expressed in the Internet standard "." (dotted) notation.</td></tr>
    <tr><td class="paramname">addr</td><td>Pointer to an integer will contain a suitable binary representation of the Internet address <code>cp</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if the string in the <code>cp</code> parameter does not contain a legitimate Internet address.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga63a5f9262fe47d5373f446f4fe127f23" title="Converts the string in the standard dotted-decimal notation to an integer value, suitable for use as ...">fnet_inet_aton()</a>, <a class="el" href="#ga77933fd49752e533874747932ebac998" title="Converts IPv4 or IPv6 address from binary to text form.">fnet_inet_ntop()</a>, <a class="el" href="#ga28a8e2f31a32550faf05d8ba72f0a4f6" title="Converts IPv4 and IPv6 addresses from text to binary form.">fnet_inet_pton()</a></dd></dl>
<p>This function interprets the character string specified by the <code>cp</code> parameter. This string represents a numeric Internet address expressed in the Internet standard "." notation. The value returned, pointed to by the <code>addr</code>, is a number suitable for use as an Internet address.<br  />
</p><dl class="section note"><dt>Note</dt><dd><a class="el" href="#ga28a8e2f31a32550faf05d8ba72f0a4f6" title="Converts IPv4 and IPv6 addresses from text to binary form.">fnet_inet_pton()</a> extends the <a class="el" href="#ga63a5f9262fe47d5373f446f4fe127f23" title="Converts the string in the standard dotted-decimal notation to an integer value, suitable for use as ...">fnet_inet_aton()</a> function to support multiple address families. <br  />
<a class="el" href="#ga63a5f9262fe47d5373f446f4fe127f23" title="Converts the string in the standard dotted-decimal notation to an integer value, suitable for use as ...">fnet_inet_aton()</a> is now considered to be deprecated. </dd></dl>

</div>
</div>
<a id="ga5526f421218aba24311e9abee1033690" name="ga5526f421218aba24311e9abee1033690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5526f421218aba24311e9abee1033690">&#9670;&#160;</a></span>fnet_inet_ntoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> * fnet_inet_ntoa </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structin__addr.html">in_addr</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *</td>          <td class="paramname"><span class="paramname"><em>res_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an IPv4 address into a string in Internet standard dotted-decimal format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Structure that represents an Internet address.</td></tr>
    <tr><td class="paramname">res_str</td><td>Pointer to a character buffer will contain the resulting text address in standard "." notation.<br  />
 The <code>res_str</code> buffer must be at least 16 bytes long (<a class="el" href="#gafe0c16fd6678d2a3f7fbb732ca86edc9">FNET_IP4_ADDR_STR_SIZE</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function always returns the <code>res_str</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga63a5f9262fe47d5373f446f4fe127f23" title="Converts the string in the standard dotted-decimal notation to an integer value, suitable for use as ...">fnet_inet_aton()</a>, <a class="el" href="#ga77933fd49752e533874747932ebac998" title="Converts IPv4 or IPv6 address from binary to text form.">fnet_inet_ntop()</a>, <a class="el" href="#ga28a8e2f31a32550faf05d8ba72f0a4f6" title="Converts IPv4 and IPv6 addresses from text to binary form.">fnet_inet_pton()</a></dd></dl>
<p>This function takes an Internet address structure, specified by the <code>addr</code> parameter, and returns a null-terminated ASCII string, representing the address in "." (dot) notation as in "a.b.c.d" into buffer pointed to by the <code>res_str</code>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="#ga77933fd49752e533874747932ebac998" title="Converts IPv4 or IPv6 address from binary to text form.">fnet_inet_ntop()</a> extends the <a class="el" href="#ga5526f421218aba24311e9abee1033690" title="Converts an IPv4 address into a string in Internet standard dotted-decimal format.">fnet_inet_ntoa()</a> function to support multiple address families. <br  />
<a class="el" href="#ga5526f421218aba24311e9abee1033690" title="Converts an IPv4 address into a string in Internet standard dotted-decimal format.">fnet_inet_ntoa()</a> is now considered to be deprecated. </dd></dl>

</div>
</div>
<a id="ga77933fd49752e533874747932ebac998" name="ga77933fd49752e533874747932ebac998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77933fd49752e533874747932ebac998">&#9670;&#160;</a></span>fnet_inet_ntop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> * fnet_inet_ntop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a></td>          <td class="paramname"><span class="paramname"><em>family</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>str_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts IPv4 or IPv6 address from binary to text form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">family</td><td>The address family (AF_INET or AF_INET6).</td></tr>
    <tr><td class="paramname">addr</td><td>Pointer to the IP address in network-byte order.</td></tr>
    <tr><td class="paramname">str</td><td>Pointer to a buffer in which to store the NULL-terminated string representation of the IP address.<br  />
 For an IPv4 address, the <code>str</code> buffer must be at least 16 bytes long (<a class="el" href="#gafe0c16fd6678d2a3f7fbb732ca86edc9">FNET_IP4_ADDR_STR_SIZE</a>).<br  />
 For an IPv6 address, the <code>str</code> buffer must be at least 46 bytes long (<a class="el" href="#ga8d8a8b5c8ac879f744b3884e32bc2efd">FNET_IP6_ADDR_STR_SIZE</a>).<br  />
 </td></tr>
    <tr><td class="paramname">str_len</td><td>Length of the <code>str</code> buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li>pointer to a buffer containing the string representation of IP address (the <code>str</code>), if no error occurs,</li>
<li><a class="el" href="group__fnet__stdlib.html#ga95a0a7685559d14de2c490ced0da5699">FNET_NULL</a> if an error occurs.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga28a8e2f31a32550faf05d8ba72f0a4f6" title="Converts IPv4 and IPv6 addresses from text to binary form.">fnet_inet_pton()</a></dd></dl>
<p>This function converts the network address structure, specified by the <code>addr</code> parameter, in the <code>addr_family</code> address family into a character string. The resulting string is copied to the buffer pointed to by <code>str</code>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="#ga77933fd49752e533874747932ebac998" title="Converts IPv4 or IPv6 address from binary to text form.">fnet_inet_ntop()</a> extends the <a class="el" href="#ga5526f421218aba24311e9abee1033690" title="Converts an IPv4 address into a string in Internet standard dotted-decimal format.">fnet_inet_ntoa()</a> function to support multiple address families. <br  />
<a class="el" href="#ga5526f421218aba24311e9abee1033690" title="Converts an IPv4 address into a string in Internet standard dotted-decimal format.">fnet_inet_ntoa()</a> is now considered to be deprecated. </dd></dl>

</div>
</div>
<a id="ga28a8e2f31a32550faf05d8ba72f0a4f6" name="ga28a8e2f31a32550faf05d8ba72f0a4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28a8e2f31a32550faf05d8ba72f0a4f6">&#9670;&#160;</a></span>fnet_inet_pton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_inet_pton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a></td>          <td class="paramname"><span class="paramname"><em>family</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>addr_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts IPv4 and IPv6 addresses from text to binary form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">family</td><td>The address family (AF_INET or AF_INET6).</td></tr>
    <tr><td class="paramname">str</td><td>Null-terminated character string that contains the text representation of the IP address to convert to numeric binary form.</td></tr>
    <tr><td class="paramname">addr</td><td>Pointer to a buffer in which to store the numeric binary representation of the IP address <code>str</code>.</td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of the <code>addr</code> buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if the string in the <code>str</code> parameter does not contain a legitimate Internet address.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga77933fd49752e533874747932ebac998" title="Converts IPv4 or IPv6 address from binary to text form.">fnet_inet_ntop()</a></dd></dl>
<p>This function converts the character string <code>src</code> into a network address structure in the <code>addr_family</code> address family, then copies the network address structure to the <code>addr</code> buffer.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="#ga28a8e2f31a32550faf05d8ba72f0a4f6" title="Converts IPv4 and IPv6 addresses from text to binary form.">fnet_inet_pton()</a> extends the <a class="el" href="#ga63a5f9262fe47d5373f446f4fe127f23" title="Converts the string in the standard dotted-decimal notation to an integer value, suitable for use as ...">fnet_inet_aton()</a> function to support multiple address families. <br  />
<a class="el" href="#ga63a5f9262fe47d5373f446f4fe127f23" title="Converts the string in the standard dotted-decimal notation to an integer value, suitable for use as ...">fnet_inet_aton()</a> is now considered to be deprecated. </dd></dl>

</div>
</div>
<a id="ga8c97a7ec6eedf63ba5dbf80e17c01aae" name="ga8c97a7ec6eedf63ba5dbf80e17c01aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c97a7ec6eedf63ba5dbf80e17c01aae">&#9670;&#160;</a></span>fnet_inet_ptos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_inet_ptos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__fnet__stdlib.html#ga4a2efda1971b830a87eb076b7152c01f">fnet_char_t</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts IPv4 and IPv6 addresses from text to socket-address structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Null-terminated character string that contains the text representation of the IP address to convert to socket-address structure.</td></tr>
    <tr><td class="paramname">addr</td><td>Pointer to a socket-address structure to be filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if the string in the <code>str</code> parameter does not contain a legitimate Internet address.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga28a8e2f31a32550faf05d8ba72f0a4f6" title="Converts IPv4 and IPv6 addresses from text to binary form.">fnet_inet_pton()</a></dd></dl>
<p>This function converts the character string <code>src</code> into a socket-address structure. </p>

</div>
</div>
<a id="gac8be83bf32f2944d9aed2db185b0d5c6" name="gac8be83bf32f2944d9aed2db185b0d5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8be83bf32f2944d9aed2db185b0d5c6">&#9670;&#160;</a></span>fnet_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> fnet_socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a></td>          <td class="paramname"><span class="paramname"><em>family</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9f1b6a1b9f22d86025b8d9d5b473ec06">fnet_socket_type_t</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fnet_uint32_t</td>          <td class="paramname"><span class="paramname"><em>protocol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">family</td><td>Address family that the socket will use, defined by the <a class="el" href="#ga2297bb08ea37b8793a25b085ee5e5275">fnet_address_family_t</a>.</td></tr>
    <tr><td class="paramname">type</td><td>Type specification for the new socket, defined by <a class="el" href="#ga9f1b6a1b9f22d86025b8d9d5b473ec06">fnet_socket_type_t</a>. It can be SOCK_STREAM (TCP) or SOCK_DGRAM (UDP).</td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol to be used with the socket that is specific to the indicated address family. This stack supports IPPROTO_TCP and IPPROTO_UDP.<br  />
 This parameter is optional, and can be set to zero, as the <code>type</code> already defines the proper protocol.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="classSocket.html">Socket</a> descriptor referencing the new socket, if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#ga95a0a7685559d14de2c490ced0da5699">FNET_NULL</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373" title="Closes an existing socket.">fnet_socket_close()</a></dd></dl>
<p>This function creates a socket and returns its descriptor.<br  />
The <a class="el" href="#gac8be83bf32f2944d9aed2db185b0d5c6">fnet_socket()</a> function causes a socket descriptor and any related resources to be allocated and bound to a specific transport-service provider that supports the requested combination of address family, socket type, and protocol parameters.<br  />
<br  />
After a socket is created:</p><ul>
<li>Connection-oriented sockets, such as the SOCK_STREAM, provide full-duplex connections. Before any data can be sent or received, it must be in a connected state . A connection to another socket is established with the <a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect()</a> call. Once connected, the data can be transferred using the <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send()</a> and the <a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv()</a> calls. When a session has been completed, the <a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373">fnet_socket_close()</a> must be performed.</li>
<li>Connectionless, message-oriented sockets, such as the SOCK_DGRAM, allow sending and receiving of datagrams to and from arbitrary peers using the <a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto()</a> and the <a class="el" href="#ga30cdb74342d222bb10b53a3571b72398">fnet_socket_recvfrom()</a>. If such a socket is connected to a specific peer, datagrams can be sent to that peer using the <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send()</a>, and can be received only from this peer using the <a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv()</a>. </li>
</ul>

</div>
</div>
<a id="gaa8269391b0495ae2785309c09c969ecf" name="gaa8269391b0495ae2785309c09c969ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8269391b0495ae2785309c09c969ecf">&#9670;&#160;</a></span>fnet_socket_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a> fnet_socket_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>addrlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accepts a connection on the specified socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor, identifying an unconnected socket.</td></tr>
    <tr><td class="paramname">addr</td><td>Optional pointer to a buffer that receives the address of the remote host at the other end of the connection.</td></tr>
    <tr><td class="paramname">addrlen</td><td>Optional pointer to an integer that contains the length of the <code>addr</code> parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="classSocket.html">Socket</a> descriptor referencing the new socket, if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#ga95a0a7685559d14de2c490ced0da5699">FNET_NULL</a> if an error occurs. <br  />
 The specific error code can be retrieved using <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac8be83bf32f2944d9aed2db185b0d5c6" title="Creates a socket.">fnet_socket()</a>, <a class="el" href="#ga214c5b0a449ce278f72285b37a33bcae" title="Assigns a local address to a socket.">fnet_socket_bind()</a></dd></dl>
<p>The function extracts the first connection in the queue of pending connections on the listening socket <code>s</code>, and returns the new socket descriptor.<br  />
The newly-created socket is the socket that will handle the actual connection and has the same properties as the socket <code>s</code>. The original socket remains open and listens for new connection requests. If no pending connections are present in the queue of the socket, the <a class="el" href="#gaa8269391b0495ae2785309c09c969ecf">fnet_socket_accept()</a> returns FNET_NULL and the specific error code is set to FNET_ERR_AGAIN.<br  />
 The parameter <code>addr</code> is a result parameter that is filled in with the address of the remote host. The <code>addrlen</code> should initially contain the amount of space pointed to by the <code>addr</code>; on return it will contain the actual length of the address returned (in bytes).<br  />
The <a class="el" href="#gaa8269391b0495ae2785309c09c969ecf">fnet_socket_accept()</a> function is used only with connection-oriented socket types (SOCK_STREAM).<br  />
If <code>addr</code> and/or <code>addrlen</code> are equal to <code>0</code>, then no information about the remote address of the accepted socket is returned. </p>

</div>
</div>
<a id="ga529326afa1f8d0d661faf8b147443d9e" name="ga529326afa1f8d0d661faf8b147443d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga529326afa1f8d0d661faf8b147443d9e">&#9670;&#160;</a></span>fnet_socket_addr_are_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#gae066ef031201bb2ccac8febf4707fd0e">fnet_bool_t</a> fnet_socket_addr_are_equal </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>addr1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>addr2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares socket addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr1</td><td>First socket address to be compared.</td></tr>
    <tr><td class="paramname">addr2</td><td>Second socket address to be compared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#ggae066ef031201bb2ccac8febf4707fd0ea45d0eaf77f5f90921937ef5d2858e71b">FNET_TRUE</a> if addresses are equal.</li>
<li><a class="el" href="group__fnet__stdlib.html#ggae066ef031201bb2ccac8febf4707fd0eaeb71405719049525566ed60973c0da7c">FNET_FALSE</a> if addresses are not equal.</li>
</ul>
</dd></dl>
<p>This function compares specified socket addresses, depending on address family. <br  />
<a class="el" href="classPort.html">Port</a> number and Scope Id do not take part in process of comparison. </p>

</div>
</div>
<a id="gaf0bd605a1f5f63a06abaefd597462f80" name="gaf0bd605a1f5f63a06abaefd597462f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0bd605a1f5f63a06abaefd597462f80">&#9670;&#160;</a></span>fnet_socket_addr_is_multicast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#gae066ef031201bb2ccac8febf4707fd0e">fnet_bool_t</a> fnet_socket_addr_is_multicast </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines, if socket address is multicast. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td><a class="el" href="classSocket.html">Socket</a> address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><code>FNET_TRUE</code> if the address is multicast.</li>
<li><code>FNET_FALSE</code> if the address is not multicast.</li>
</ul>
</dd></dl>
<p>This function determines if the socket address is multicast or not. </p>

</div>
</div>
<a id="ga1122c8e1cd985dfc4a8b3e02ce319ab4" name="ga1122c8e1cd985dfc4a8b3e02ce319ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1122c8e1cd985dfc4a8b3e02ce319ab4">&#9670;&#160;</a></span>fnet_socket_addr_is_unspecified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#gae066ef031201bb2ccac8febf4707fd0e">fnet_bool_t</a> fnet_socket_addr_is_unspecified </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines, if socket address is unspecified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td><a class="el" href="classSocket.html">Socket</a> address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><code>FNET_TRUE</code> if the address is unspecified.</li>
<li><code>FNET_FALSE</code> if the address is specified.</li>
</ul>
</dd></dl>
<p>This function determines if the socket address is unspecified (IP address is set to all zeros) or not. </p>

</div>
</div>
<a id="ga214c5b0a449ce278f72285b37a33bcae" name="ga214c5b0a449ce278f72285b37a33bcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga214c5b0a449ce278f72285b37a33bcae">&#9670;&#160;</a></span>fnet_socket_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_socket_bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>namelen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a local address to a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor, identifying a socket to bind.</td></tr>
    <tr><td class="paramname">name</td><td>The address to be assigned to the socket, from the <a class="el" href="structsockaddr.html">sockaddr</a> structure.</td></tr>
    <tr><td class="paramname">namelen</td><td>The length of the <code>name</code> parameter. Normally <code>namelen</code> is set to <code>sizeof(name)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac8be83bf32f2944d9aed2db185b0d5c6" title="Creates a socket.">fnet_socket()</a></dd></dl>
<p>This function associates a local address with the socket.<br  />
The <a class="el" href="#ga214c5b0a449ce278f72285b37a33bcae">fnet_socket_bind()</a> function is used on an unconnected socket before subsequent calls to the <a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect()</a> or the <a class="el" href="#gaf861cac2394db1fe94fce1a55a25900e">fnet_socket_listen()</a> functions. It is used to bind to either connection-oriented (stream) or connectionless (datagram) sockets.<br  />
Within the <a class="el" href="structsockaddr.html">sockaddr</a> structure, the address may be the address assigned to a network interface on the host or the <a class="el" href="lwip_2inet_8h.html#a5d1940045dc2e7de552f3d4ff13a74ab">INADDR_ANY</a>. Using the <a class="el" href="lwip_2inet_8h.html#a5d1940045dc2e7de552f3d4ff13a74ab">INADDR_ANY</a> causes the stack to use the default network interface address. Using a port number of 0 causes the service provider to assign a unique port to the socket with a value between 1024 and 5000. </p>

</div>
</div>
<a id="ga6cb4c12c0fba44e02a019dc877fef373" name="ga6cb4c12c0fba44e02a019dc877fef373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cb4c12c0fba44e02a019dc877fef373">&#9670;&#160;</a></span>fnet_socket_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_socket_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an existing socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor, identifying a socket to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac8be83bf32f2944d9aed2db185b0d5c6" title="Creates a socket.">fnet_socket()</a></dd></dl>
<p>This function releases the socket descriptor <code>s</code>, so that further references to <code>s</code> fail with the error FNET_ERR_BAD_DESC.<br  />
 An application should always have a matching call to the <a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373">fnet_socket_close()</a> for each successful call to the <a class="el" href="#gac8be83bf32f2944d9aed2db185b0d5c6">fnet_socket()</a> to return any socket resources to the system.<br  />
<br  />
For the SOCK_STREAM sockets, the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a6856768825eabef55d9d4175020da464">SO_LINGER</a> option controls the action of the closing, when unsent data is present on the socket and the <a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373">fnet_socket_close()</a> function is performed. This option has effect on TCP sockets only. To enable or disable the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a6856768825eabef55d9d4175020da464">SO_LINGER</a> option, the application should use the <a class="el" href="structlinger.html">linger</a> structure. This structure includes the <code>l_onoff</code> and the <code>l_linger</code> fields. If the <code>l_onoff</code> has a non-zero value, then the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a6856768825eabef55d9d4175020da464">SO_LINGER</a> is enabled. Otherwise, the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a6856768825eabef55d9d4175020da464">SO_LINGER</a> option is disabled. The <code>l_linger</code> field includes the timeout in seconds. If the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a6856768825eabef55d9d4175020da464">SO_LINGER</a> option is not used , the remaining data of the output buffer can be sent after the execution of the <a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373">fnet_socket_close()</a> in the background.<br  />
If a timeout expires and unsent data is present, the hard reset occurs and unsent data will be deleted.<br  />
If the <a class="el" href="group__WIFI__SOCKET.html#gga4962e8f52d0e73e062963db9d09b7c39a6856768825eabef55d9d4175020da464">SO_LINGER</a> option is used with a zero timeout interval, the hard reset occurs immediately and unsent data will be deleted. </p>

</div>
</div>
<a id="ga786a6f122a594cfde09501a0e5643c5d" name="ga786a6f122a594cfde09501a0e5643c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga786a6f122a594cfde09501a0e5643c5d">&#9670;&#160;</a></span>fnet_socket_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_socket_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>namelen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a connection with the specified socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor identifying an unconnected socket.</td></tr>
    <tr><td class="paramname">name</td><td>Address (name) of the socket, with which the connection should be established.</td></tr>
    <tr><td class="paramname">namelen</td><td>Length of the <code>name</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac8be83bf32f2944d9aed2db185b0d5c6" title="Creates a socket.">fnet_socket()</a>, <a class="el" href="#ga214c5b0a449ce278f72285b37a33bcae" title="Assigns a local address to a socket.">fnet_socket_bind()</a></dd></dl>
<p>For connection-oriented sockets (SOCK_STREAM), this function activates an active connection with the foreign host.</p>
<p>When the socket call completes successfully, the socket is ready to send and receive data. Any attempt to reconnect the active connection will fail with the error code <a class="el" href="group__fnet__error.html#ggad088b58e95c4eee45363286fe99807ecad55c48036d93d7bf04bfa8d6ff39ed51">FNET_ERR_ISCONN</a>. For connection-oriented sockets, it is often not possible to complete the connection immediately. Until the connection attempt completes on a socket, all subsequent calls to <a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect()</a> on the same socket will fail with the error code <a class="el" href="group__fnet__error.html#ggad088b58e95c4eee45363286fe99807eca15d48083f37e229aac8e34ff077f0189">FNET_ERR_INPROGRESS</a>, or succeed with <a class="el" href="group__fnet__error.html#ggad088b58e95c4eee45363286fe99807ecad55c48036d93d7bf04bfa8d6ff39ed51">FNET_ERR_ISCONN</a> when the connection completes successfully. Use the <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a> function to determine the completion of the connection request by checking the <a class="el" href="#gga989481a2cee0291e70f9076a091eddf1a43b410a56c993383c754b4c8a6d55063">SO_STATE</a> to see if the socket is connected (<a class="el" href="#gga3b410682d2a08c9eda8d9337731e5f9fa097f95adc87c47e70cd008b417fbac57">SS_CONNECTED</a>), is still connecting (<a class="el" href="#gga3b410682d2a08c9eda8d9337731e5f9fa8407056ba960ba5990d4faf1a5df30a9">SS_CONNECTING</a>) or the connection has failed (<a class="el" href="#gga3b410682d2a08c9eda8d9337731e5f9fa3b2500a7ffff9084fdca145c1a37b722">SS_UNCONNECTED</a>). <br  />
<br  />
For a connectionless socket (SOCK_DGRAM), the operation performed by <a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect()</a> is merely to establish a default destination address that can be used on subsequent <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send()</a> and <a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv()</a> calls. Any datagrams received from an address other than the destination address specified will be discarded. The default destination can be changed by simply calling the <a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect()</a> again, even if the socket is connected already. Any datagrams queued for receipt are discarded from the previous <a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect()</a>. For connectionless sockets, the <code>name</code> can indicate any valid address, including a broadcast address.<br  />
<br  />
If the socket <code>s</code> is unbound, unique values are assigned to the local association by the stack, and the socket is marked as bound. </p>

</div>
</div>
<a id="ga8e7c15f910622ec6826d5eb7bc696edf" name="ga8e7c15f910622ec6826d5eb7bc696edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e7c15f910622ec6826d5eb7bc696edf">&#9670;&#160;</a></span>fnet_socket_getname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_socket_getname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>namelen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current name for the specified socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor identifying a socket.</td></tr>
    <tr><td class="paramname">name</td><td>Structure that receives the name (address) of the socket <code>s</code>.</td></tr>
    <tr><td class="paramname">namelen</td><td>Pointer to the size of the <code>name</code> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga988be7f23f5413df6600c1759495e5f4" title="Retrieves the name of a peer connected to a socket.">fnet_socket_getpeername()</a></dd></dl>
<p>This function retrieves the current name for the specified socket <code>s</code> and stores it in the <code>name</code>.<br  />
It is used on a bound or connected socket. </p>

</div>
</div>
<a id="ga70de533218cdeb51a5cbce0c5f7fa607" name="ga70de533218cdeb51a5cbce0c5f7fa607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70de533218cdeb51a5cbce0c5f7fa607">&#9670;&#160;</a></span>fnet_socket_getopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_socket_getopt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaedf5dba7175dbc74b729bbab381a009a">fnet_protocol_t</a></td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga989481a2cee0291e70f9076a091eddf1">fnet_socket_options_t</a></td>          <td class="paramname"><span class="paramname"><em>optname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>optval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>optvallen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a socket option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor identifying a socket.</td></tr>
    <tr><td class="paramname">level</td><td>Level, at which the option is defined. The supported levels are the SOL_SOCKET, IPPROTO_IP, IPPROTO_IPV6 or IPPROTO_TCP.</td></tr>
    <tr><td class="paramname">optname</td><td><a class="el" href="classSocket.html">Socket</a> option, for which the value is to be retrievied.</td></tr>
    <tr><td class="paramname">optval</td><td>Pointer to a buffer in which the value for the requested option has to be returned.</td></tr>
    <tr><td class="paramname">optvallen</td><td>Pointer to the size of the <code>optval</code> buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad1bf147e6a6a6f361084c0e829c3d000" title="Sets a socket option.">fnet_socket_setopt()</a></dd></dl>
<p>This function retrieves the current value for a socket option associated with the socket <code>s</code>, and stores the result in the <code>optval</code>.<br  />
The various socket options are described by the <a class="el" href="#ga989481a2cee0291e70f9076a091eddf1">fnet_socket_options_t</a>. </p>

</div>
</div>
<a id="ga988be7f23f5413df6600c1759495e5f4" name="ga988be7f23f5413df6600c1759495e5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga988be7f23f5413df6600c1759495e5f4">&#9670;&#160;</a></span>fnet_socket_getpeername()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_socket_getpeername </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>namelen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the name of a peer connected to a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor identifying a connected socket.</td></tr>
    <tr><td class="paramname">name</td><td>Structure that receives the name (address) of the peer.</td></tr>
    <tr><td class="paramname">namelen</td><td>Pointer to the size of the <code>name</code> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8e7c15f910622ec6826d5eb7bc696edf" title="Retrieves the current name for the specified socket.">fnet_socket_getname()</a></dd></dl>
<p>This function retrieves the name of the peer connected to the socket <code>s</code> and stores it in the <a class="el" href="structsockaddr.html">sockaddr</a> structure identified by <code>name</code>.<br  />
The <a class="el" href="#ga988be7f23f5413df6600c1759495e5f4">fnet_socket_getpeername()</a> function can be used only with a connected socket. For datagram sockets, only the name of a peer specified in a previous <a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect()</a> call will be returned - any name specified by a previous <a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto()</a> call will not be returned by the <a class="el" href="#ga988be7f23f5413df6600c1759495e5f4">fnet_socket_getpeername()</a>. </p>

</div>
</div>
<a id="gaf861cac2394db1fe94fce1a55a25900e" name="gaf861cac2394db1fe94fce1a55a25900e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf861cac2394db1fe94fce1a55a25900e">&#9670;&#160;</a></span>fnet_socket_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_socket_listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>backlog</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places the socket into a state, where it is listening for an incoming connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor identifying a socket that will be used for listening.</td></tr>
    <tr><td class="paramname">backlog</td><td>Maximum length of the queue of pending connections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac8be83bf32f2944d9aed2db185b0d5c6" title="Creates a socket.">fnet_socket()</a>, <a class="el" href="#ga214c5b0a449ce278f72285b37a33bcae" title="Assigns a local address to a socket.">fnet_socket_bind()</a>, <a class="el" href="#gaa8269391b0495ae2785309c09c969ecf" title="Accepts a connection on the specified socket.">fnet_socket_accept()</a></dd></dl>
<p>Only connection-oriented sockets (SOCK_STREAM) are used with the <a class="el" href="#gaf861cac2394db1fe94fce1a55a25900e">.@n</a> The socket is put into passive mode, where the incoming connection requests are acknowledged and queued pending acceptance by the listening socket. The <a class="el" href="#gaf861cac2394db1fe94fce1a55a25900e">fnet_socket_listen()</a> function is typically used by servers that can have more than one connection request at a time. <br  />
An application can call <a class="el" href="#gaf861cac2394db1fe94fce1a55a25900e">fnet_socket_listen()</a> more than once on the same socket. If there are more pending connections than the new backlog value, the excess pending connections will be reset and dropped. </p>

</div>
</div>
<a id="ga81904520913d1e69bf998e6585f27652" name="ga81904520913d1e69bf998e6585f27652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81904520913d1e69bf998e6585f27652">&#9670;&#160;</a></span>fnet_socket_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fnet_int32_t fnet_socket_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fnet_uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga7c185c75d7122a77920e039b28309ec1">fnet_flag_t</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives the data from a connected socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor identifying a connected socket.</td></tr>
    <tr><td class="paramname">buf</td><td><a class="el" href="classBuffer.html">Buffer</a> for the incoming data.</td></tr>
    <tr><td class="paramname">len</td><td>Length of the <code>buf</code>.</td></tr>
    <tr><td class="paramname">flags</td><td>Optional flag specifying the way, in which the call is made. It can be constructed by using the bitwise OR operator with any of the values defined by the <a class="el" href="#gac23dfda01e1334a4bfe9c86036169529">fnet_msg_flags_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li>The number of bytes received, if no error occurs. The return value is set to zero, if there is no input data.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d" title="Establishes a connection with the specified socket.">fnet_socket_connect()</a>, <a class="el" href="#ga30cdb74342d222bb10b53a3571b72398" title="Receives the data and captures the address, from which the data was sent.">fnet_socket_recvfrom()</a></dd></dl>
<p>For connection-oriented sockets (SOCK_STREAM), calling the <a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv()</a> will return as much information as is currently available up to the size of the buffer supplied.<br  />
<br  />
For connectionless sockets (SOCK_DGRAM), the data is extracted from the first enqueued datagram (message), whose destination address is specified by the <a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d">fnet_socket_connect()</a> function. If the datagram is larger than the supplied buffer, the buffer is filled with the first part of the datagram, and the <a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv()</a> generates the error <a class="el" href="group__fnet__error.html#ggad088b58e95c4eee45363286fe99807eca451d827443946e347b020170b2b828c9">FNET_ERR_MSGSIZE</a> and the excess data is lost.<br  />
<br  />
The <code>flags</code> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. </p>

</div>
</div>
<a id="ga30cdb74342d222bb10b53a3571b72398" name="ga30cdb74342d222bb10b53a3571b72398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30cdb74342d222bb10b53a3571b72398">&#9670;&#160;</a></span>fnet_socket_recvfrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fnet_int32_t fnet_socket_recvfrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fnet_uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga7c185c75d7122a77920e039b28309ec1">fnet_flag_t</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>fromlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives the data and captures the address, from which the data was sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor, identifying a bound socket.</td></tr>
    <tr><td class="paramname">buf</td><td><a class="el" href="classBuffer.html">Buffer</a> for the incoming data.</td></tr>
    <tr><td class="paramname">len</td><td>Length of the <code>buf</code>.</td></tr>
    <tr><td class="paramname">flags</td><td>Optional flag specifying the way in which the call is made. It can be constructed by using the bitwise OR operator with any of the values defined by the <a class="el" href="#gac23dfda01e1334a4bfe9c86036169529">fnet_msg_flags_t</a>.</td></tr>
    <tr><td class="paramname">from</td><td>Optional pointer to a buffer that will hold the source address upon return.</td></tr>
    <tr><td class="paramname">fromlen</td><td>Optional pointer to the size of the <code>from</code> buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li>The number of bytes received, if no error occurs. The return value is set to zero, if the socket is nonblocking and there is no input data.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga214c5b0a449ce278f72285b37a33bcae" title="Assigns a local address to a socket.">fnet_socket_bind()</a>, <a class="el" href="#ga81904520913d1e69bf998e6585f27652" title="Receives the data from a connected socket.">fnet_socket_recv()</a></dd></dl>
<p>For connection-oriented sockets (SOCK_STREAM), calling the <a class="el" href="#ga30cdb74342d222bb10b53a3571b72398">fnet_socket_recvfrom()</a> will return as much information as is currently available up to the size of the buffer supplied. The <a class="el" href="#ga30cdb74342d222bb10b53a3571b72398">fnet_socket_recvfrom()</a> call is rarely used for stream sockets, because the routine provides the peer-socket information, and stream sockets are tied to a specific peer.<br  />
<br  />
For connectionless sockets (SOCK_DGRAM), the data is extracted from the first enqueued datagram. If the datagram is larger than the buffer supplied, the buffer is filled with the first part of the datagram, and the <a class="el" href="#ga30cdb74342d222bb10b53a3571b72398">fnet_socket_recvfrom()</a> generates the error <a class="el" href="group__fnet__error.html#ggad088b58e95c4eee45363286fe99807eca451d827443946e347b020170b2b828c9">FNET_ERR_MSGSIZE</a> and the excess data is lost.<br  />
<br  />
If the <code>from</code> parameter is non-zero, the network address of the peer that sent the data is copied to the corresponding <a class="el" href="structsockaddr.html">sockaddr</a> structure. The value pointed to by <code>fromlen</code> is initialized to the size of this structure and is modified on return, to indicate the actual size of the address stored in the <a class="el" href="structsockaddr.html">sockaddr</a> structure.<br  />
<br  />
The flags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. </p>

</div>
</div>
<a id="ga22fad04f9149f9d04ac61d563b81fdc4" name="ga22fad04f9149f9d04ac61d563b81fdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22fad04f9149f9d04ac61d563b81fdc4">&#9670;&#160;</a></span>fnet_socket_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fnet_int32_t fnet_socket_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fnet_uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga7c185c75d7122a77920e039b28309ec1">fnet_flag_t</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the data on a connected socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor, identifying a connected socket.</td></tr>
    <tr><td class="paramname">buf</td><td><a class="el" href="classBuffer.html">Buffer</a> containing the data to be transmitted.</td></tr>
    <tr><td class="paramname">len</td><td>Length of the data in <code>buf</code>.</td></tr>
    <tr><td class="paramname">flags</td><td>Optional flag specifying the way in which the call is made. It can be constructed by using the bitwise OR operator with any of the values defined by the <a class="el" href="#gac23dfda01e1334a4bfe9c86036169529">fnet_msg_flags_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li>The total number of bytes sent, if no error occurs. It can be less than the number indicated by <code>len</code>.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d" title="Establishes a connection with the specified socket.">fnet_socket_connect()</a>, <a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c" title="Sends the data to a specific destination.">fnet_socket_sendto()</a></dd></dl>
<p>For stream-oriented sockets (SOCK_STREAM), the number of actually sent bytes can be between <code>0</code> and the requested length, depending on buffer availability on both client and server machines.<br  />
<br  />
For message-oriented sockets (SOCK_DGRAM), care must be taken not to exceed the maximum datagram size, which can be obtained by using the <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a> to retrieve the value of the socket option SO_SNDBUF. If the data is too long to pass atomically through the underlying datagram protocol, the error <a class="el" href="group__fnet__error.html#ggad088b58e95c4eee45363286fe99807eca451d827443946e347b020170b2b828c9">FNET_ERR_MSGSIZE</a> is returned and no data is transmitted.<br  />
Calling the <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send()</a> with a zero <code>len</code> parameter is permissible. In such cases, the <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send()</a> will return zero as a valid value, and for message-oriented sockets (SOCK_DGRAM) a zero-length transport datagram is sent.<br  />
<br  />
The <code>flags</code> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. </p>

</div>
</div>
<a id="ga5874eb12bf5f23296cdc787319d5ce5c" name="ga5874eb12bf5f23296cdc787319d5ce5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5874eb12bf5f23296cdc787319d5ce5c">&#9670;&#160;</a></span>fnet_socket_sendto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fnet_int32_t fnet_socket_sendto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fnet_uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga7c185c75d7122a77920e039b28309ec1">fnet_flag_t</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsockaddr.html">sockaddr</a> *</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>tolen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the data to a specific destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor, identifying a socket.</td></tr>
    <tr><td class="paramname">buf</td><td><a class="el" href="classBuffer.html">Buffer</a> containing the data to be transmitted.</td></tr>
    <tr><td class="paramname">len</td><td>Length of the data in <code>buf</code>.</td></tr>
    <tr><td class="paramname">flags</td><td>Optional flag specifying the way, in which the call is made. It can be constructed by using the bitwise OR operator with any of the values defined by the <a class="el" href="#gac23dfda01e1334a4bfe9c86036169529">fnet_msg_flags_t</a>.</td></tr>
    <tr><td class="paramname">to</td><td>Pointer to the address of the target socket.</td></tr>
    <tr><td class="paramname">tolen</td><td>Size of the address in <code>to</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li>The total number of bytes sent, if no error occurs. It can be lesser than the number indicated by <code>len</code>.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga786a6f122a594cfde09501a0e5643c5d" title="Establishes a connection with the specified socket.">fnet_socket_connect()</a>, <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4" title="Sends the data on a connected socket.">fnet_socket_send()</a></dd></dl>
<p>For nonb-locking stream-oriented sockets (SOCK_STREAM), the number of actually sent bytes can be between <code>1</code> and the requested length, depending on buffer availability on both client and server machines.<br  />
<br  />
For message-oriented sockets (SOCK_DGRAM), care must be taken not not exceed the maximum datagram size, which can be obtained by using the <a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607">fnet_socket_getopt()</a> to retrieve the value of the socket option SO_SNDBUF. If the data is too long to pass atomically through the underlying datagram protocol, the error <a class="el" href="group__fnet__error.html#ggad088b58e95c4eee45363286fe99807eca451d827443946e347b020170b2b828c9">FNET_ERR_MSGSIZE</a> is returned and no data is transmitted.<br  />
Calling <a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto()</a> with a zero <code>len</code> parameter is permissible. In such cases, the <a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto()</a> will return zero as a valid value, and for message-oriented sockets (SOCK_DGRAM), a zero-length transport datagram is sent.<br  />
<br  />
The <a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto()</a> function is normally used on a connectionless socket (SOCK_DGRAM) to send a datagram to a specific peer socket identified by the <code>to</code> parameter. Even if the connectionless socket has been previously connected to a specific address, the <code>to</code> parameter overrides the destination address for that particular datagram only.<br  />
On a connection-oriented socket (SOCK_STREAM), the <code>to</code> and <code>tolen</code> parameters are ignored, making the <a class="el" href="#ga5874eb12bf5f23296cdc787319d5ce5c">fnet_socket_sendto()</a> equivalent to <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">.@n</a> <br  />
The <code>flags</code> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. </p>

</div>
</div>
<a id="gad1bf147e6a6a6f361084c0e829c3d000" name="gad1bf147e6a6a6f361084c0e829c3d000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1bf147e6a6a6f361084c0e829c3d000">&#9670;&#160;</a></span>fnet_socket_setopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_socket_setopt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaedf5dba7175dbc74b729bbab381a009a">fnet_protocol_t</a></td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga989481a2cee0291e70f9076a091eddf1">fnet_socket_options_t</a></td>          <td class="paramname"><span class="paramname"><em>optname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>optval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fnet__stdlib.html#ga3b51900ad75ebd4ed173e112765b326e">fnet_size_t</a></td>          <td class="paramname"><span class="paramname"><em>optvallen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a socket option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor identifying a socket.</td></tr>
    <tr><td class="paramname">level</td><td>Level, at which the option is defined. The supported levels are SOL_SOCKET, IPPROTO_IP, IPPROTO_IPV6 or IPPROTO_TCP.</td></tr>
    <tr><td class="paramname">optname</td><td><a class="el" href="classSocket.html">Socket</a> option for which the value is to be set.</td></tr>
    <tr><td class="paramname">optval</td><td>Pointer to a buffer, in which the value for the requested option is supplied.</td></tr>
    <tr><td class="paramname">optvallen</td><td>Size of the <code>optval</code> buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga70de533218cdeb51a5cbce0c5f7fa607" title="Gets a socket option.">fnet_socket_getopt()</a></dd></dl>
<p>This function sets the current value for a socket option associated with the specified socket.<br  />
The various socket options are described by the <a class="el" href="#ga989481a2cee0291e70f9076a091eddf1">fnet_socket_options_t</a>. </p>

</div>
</div>
<a id="ga03aa9c1387d19cbb241e4e058a86e39a" name="ga03aa9c1387d19cbb241e4e058a86e39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03aa9c1387d19cbb241e4e058a86e39a">&#9670;&#160;</a></span>fnet_socket_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fnet__stdlib.html#ga3af51043f20674052002fa2bf2d8921c">fnet_return_t</a> fnet_socket_shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga90750288ac5aea86a2913857d17f8c11">fnet_socket_t</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gadaccafa9b8a75cd59ae89842feb37e48">fnet_sd_flags_t</a></td>          <td class="paramname"><span class="paramname"><em>how</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates the connection in one or both directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Descriptor, identifying a socket.</td></tr>
    <tr><td class="paramname">how</td><td>Flag that describes what types of operation will no longer be allowed, it's defined by the <a class="el" href="#gadaccafa9b8a75cd59ae89842feb37e48">fnet_sd_flags_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns:<ul>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921cab0029c95ce874f4337a0c39500116d0a">FNET_OK</a> if no error occurs.</li>
<li><a class="el" href="group__fnet__stdlib.html#gga3af51043f20674052002fa2bf2d8921caff5d90bdc7ad8614419c74fb73ea1993">FNET_ERR</a> if an error occurs. <br  />
 The specific error code can be retrieved using the <a class="el" href="group__fnet__error.html#gaeed6d3aa901e7c92a6e994afbcdca193">fnet_error_get()</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373" title="Closes an existing socket.">fnet_socket_close()</a></dd></dl>
<p>This function is used on all types of sockets to disable reception, transmission, or both.<br  />
If the <code>how</code> parameter is <a class="el" href="#ggadaccafa9b8a75cd59ae89842feb37e48afa088e64138dfb8f58de1432d77577ac">SD_READ</a>, subsequent calls to the <a class="el" href="#ga81904520913d1e69bf998e6585f27652">fnet_socket_recv()</a> function on the socket will be unallowed. If the <code>how</code> parameter is <a class="el" href="#ggadaccafa9b8a75cd59ae89842feb37e48ac9c468da07fb6d142eb5817545c2c94b">SD_WRITE</a>, subsequent calls to the <a class="el" href="#ga22fad04f9149f9d04ac61d563b81fdc4">fnet_socket_send()</a> function are unallowed. Setting the <code>how</code> to the <a class="el" href="#ggadaccafa9b8a75cd59ae89842feb37e48a545eaee6b6155691ef979c90f6123aee">SD_BOTH</a> disables both sends and receives as described above.<br  />
The <a class="el" href="#ga03aa9c1387d19cbb241e4e058a86e39a">fnet_socket_shutdown()</a> function does not close the socket. Any resources attached to the socket will not be freed until the <a class="el" href="#ga6cb4c12c0fba44e02a019dc877fef373">fnet_socket_close()</a> is invoked. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
