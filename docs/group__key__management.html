<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: Key management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__key__management.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Key management</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4a68fb898e28685e608c734ea54281b5" id="r_ga4a68fb898e28685e608c734ea54281b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4a68fb898e28685e608c734ea54281b5">psa_purge_key</a> (mbedtls_svc_key_id_t key)</td></tr>
<tr class="separator:ga4a68fb898e28685e608c734ea54281b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac27a547ca634d439e89b17aacc99943" id="r_gaac27a547ca634d439e89b17aacc99943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac27a547ca634d439e89b17aacc99943">psa_copy_key</a> (mbedtls_svc_key_id_t source_key, const <a class="el" href="group__attributes.html#ga0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *attributes, mbedtls_svc_key_id_t *target_key)</td></tr>
<tr class="separator:gaac27a547ca634d439e89b17aacc99943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f52644312291335682fbc0292c43cd2" id="r_ga5f52644312291335682fbc0292c43cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f52644312291335682fbc0292c43cd2">psa_destroy_key</a> (mbedtls_svc_key_id_t key)</td></tr>
<tr class="memdesc:ga5f52644312291335682fbc0292c43cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a key.  <br /></td></tr>
<tr class="separator:ga5f52644312291335682fbc0292c43cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac161d9a354209b0bdaf1f302bf4619d3" id="r_gac161d9a354209b0bdaf1f302bf4619d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac161d9a354209b0bdaf1f302bf4619d3">psa_open_key</a> (<a class="el" href="group__key__lifetimes.html#ga11e986351c65bd3dc3c0fe2cd9926e4b">psa_key_id_t</a> id, psa_key_handle_t *handle)</td></tr>
<tr class="separator:gac161d9a354209b0bdaf1f302bf4619d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09b720d299dfe6b9f41c36e448078eb" id="r_gaa09b720d299dfe6b9f41c36e448078eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa09b720d299dfe6b9f41c36e448078eb">psa_close_key</a> (psa_key_handle_t handle)</td></tr>
<tr class="separator:gaa09b720d299dfe6b9f41c36e448078eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa09b720d299dfe6b9f41c36e448078eb" name="gaa09b720d299dfe6b9f41c36e448078eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa09b720d299dfe6b9f41c36e448078eb">&#9670;&#160;</a></span>psa_close_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_close_key </td>
          <td>(</td>
          <td class="paramtype">psa_key_handle_t</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a key handle.</p>
<p>If the handle designates a volatile key, this will destroy the key material and free all associated resources, just like <a class="el" href="#ga5f52644312291335682fbc0292c43cd2" title="Destroy a key.">psa_destroy_key()</a>.</p>
<p>If this is the last open handle to a persistent key, then closing the handle will free all resources associated with the key in volatile memory. The key data in persistent storage is not affected and can be opened again later with a call to psa_open_key().</p>
<p>Closing the key handle makes the handle invalid, and the key handle must not be used again by the application.</p>
<dl class="section note"><dt>Note</dt><dd>If the key handle was used to set up an active :ref:`multipart operation &lt;multipart-operations&gt;`, then closing the key handle can cause the multipart operation to fail. Applications should maintain the key handle until after the multipart operation has finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The key handle to close. If this is <code>0</code>, do nothing and return <code>PSA_SUCCESS</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td><code class="param">handle</code> was a valid handle or <code>0</code>. It is now closed. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td><code class="param">handle</code> is not a valid handle nor <code>0</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code.</td></tr>
  </table>
  </dd>
</dl>
<p>Close a key handle.</p>
<p>If the handle designates a volatile key, this will destroy the key material and free all associated resources, just like <a class="el" href="#ga5f52644312291335682fbc0292c43cd2" title="Destroy a key.">psa_destroy_key()</a>.</p>
<p>If this is the last open handle to a persistent key, then closing the handle will free all resources associated with the key in volatile memory. The key data in persistent storage is not affected and can be opened again later with a call to psa_open_key().</p>
<p>Closing the key handle makes the handle invalid, and the key handle must not be used again by the application.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not part of the PSA Cryptography API Release 1.0.0 specification. It was defined in the 1.0 Beta 3 version of the specification but was removed in the 1.0.0 released version. This API is kept for the time being to not break applications relying on it. It is not deprecated yet but will be in the near future.</dd>
<dd>
If the key handle was used to set up an active :ref:`multipart operation &lt;multipart-operations&gt;`, then closing the key handle can cause the multipart operation to fail. Applications should maintain the key handle until after the multipart operation has finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The key handle to close. If this is <code>0</code>, do nothing and return <code>PSA_SUCCESS</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td><code class="param">handle</code> was a valid handle or <code>0</code>. It is now closed. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td><code class="param">handle</code> is not a valid handle nor <code>0</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac27a547ca634d439e89b17aacc99943" name="gaac27a547ca634d439e89b17aacc99943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac27a547ca634d439e89b17aacc99943">&#9670;&#160;</a></span>psa_copy_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_copy_key </td>
          <td>(</td>
          <td class="paramtype">mbedtls_svc_key_id_t</td>          <td class="paramname"><span class="paramname"><em>source_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__attributes.html#ga0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mbedtls_svc_key_id_t *</td>          <td class="paramname"><span class="paramname"><em>target_key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a copy of a key.</p>
<p>Copy key material from one location to another.</p>
<p>This function is primarily useful to copy a key from one location to another, since it populates a key using the material from another key which may have a different lifetime.</p>
<p>This function may be used to share a key with a different party, subject to implementation-defined restrictions on key sharing.</p>
<p>The policy on the source key must have the usage flag <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a> set. This flag is sufficient to permit the copy if the key has the lifetime <a class="el" href="group__key__lifetimes.html#ga8b438870ba69489b685730d346455108">PSA_KEY_LIFETIME_VOLATILE</a> or <a class="el" href="group__key__lifetimes.html#ga3713a01c5fcd5f7eae46ff22ceaf6d02">PSA_KEY_LIFETIME_PERSISTENT</a>. Some secure elements do not provide a way to copy a key without making it extractable from the secure element. If a key is located in such a secure element, then the key must have both usage flags <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a> and <a class="el" href="group__policy.html#ga7dddccdd1303176e87a4d20c87b589ed">PSA_KEY_USAGE_EXPORT</a> in order to make a copy of the key outside the secure element.</p>
<p>The resulting key may only be used in a way that conforms to both the policy of the original key and the policy specified in the <code class="param">attributes</code> parameter:</p><ul>
<li>The usage flags on the resulting key are the bitwise-and of the usage flags on the source policy and the usage flags in <code class="param">attributes</code>.</li>
<li>If both allow the same algorithm or wildcard-based algorithm policy, the resulting key has the same algorithm policy.</li>
<li>If either of the policies allows an algorithm and the other policy allows a wildcard-based algorithm policy that includes this algorithm, the resulting key allows the same algorithm.</li>
<li>If the policies do not allow any algorithm in common, this function fails with the status <a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a>.</li>
</ul>
<p>The effect of this function on implementation-defined attributes is implementation-defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">source_key</td><td>The key to copy. It must allow the usage <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a>. If a private or secret key is being copied outside of a secure element it must also allow <a class="el" href="group__policy.html#ga7dddccdd1303176e87a4d20c87b589ed">PSA_KEY_USAGE_EXPORT</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributes</td><td>The attributes for the new key. They are used as follows:<ul>
<li>The key type and size may be 0. If either is nonzero, it must match the corresponding attribute of the source key.</li>
<li>The key location (the lifetime and, for persistent keys, the key identifier) is used directly.</li>
<li>The policy constraints (usage flags and algorithm policy) are combined from the source key and <code class="param">attributes</code> so that both sets of restrictions apply, as described in the documentation of this function. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target_key</td><td>On success, an identifier for the newly created key. For persistent keys, this is the key identifier defined in <code class="param">attributes</code>. <code>0</code> on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td><code class="param">source_key</code> is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gaf2b34cc87edc72f3ba90071a08210d20">PSA_ERROR_ALREADY_EXISTS</a></td><td>This is an attempt to create a persistent key, and there is already a persistent key with the given identifier. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td>The lifetime or identifier in <code class="param">attributes</code> are invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td>The policy constraints on the source and specified in <code class="param">attributes</code> are incompatible. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td><code class="param">attributes</code> specifies a key type or key size which does not match the attributes of the source key. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The source key does not have the <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a> usage flag. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The source key is not exportable and its lifetime does not allow copying it to the target's lifetime. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga91b2ad8a867517a2651f1b076c5216e5">PSA_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga897a45eb206a6f6b7be7ffbe36f0d766">PSA_ERROR_INSUFFICIENT_STORAGE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga08b10e70fa5ff0b05c631d9f8f6b2c6b">PSA_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code.</td></tr>
  </table>
  </dd>
</dl>
<p>Make a copy of a key.</p>
<p>Copy key material from one location to another.</p>
<p>This function is primarily useful to copy a key from one location to another, since it populates a key using the material from another key which may have a different lifetime.</p>
<p>This function may be used to share a key with a different party, subject to implementation-defined restrictions on key sharing.</p>
<p>The policy on the source key must have the usage flag <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a> set. This flag is sufficient to permit the copy if the key has the lifetime <a class="el" href="group__key__lifetimes.html#ga8b438870ba69489b685730d346455108">PSA_KEY_LIFETIME_VOLATILE</a> or <a class="el" href="group__key__lifetimes.html#ga3713a01c5fcd5f7eae46ff22ceaf6d02">PSA_KEY_LIFETIME_PERSISTENT</a>. Some secure elements do not provide a way to copy a key without making it extractable from the secure element. If a key is located in such a secure element, then the key must have both usage flags <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a> and <a class="el" href="group__policy.html#ga7dddccdd1303176e87a4d20c87b589ed">PSA_KEY_USAGE_EXPORT</a> in order to make a copy of the key outside the secure element.</p>
<p>The resulting key may only be used in a way that conforms to both the policy of the original key and the policy specified in the <code class="param">attributes</code> parameter:</p><ul>
<li>The usage flags on the resulting key are the bitwise-and of the usage flags on the source policy and the usage flags in <code class="param">attributes</code>.</li>
<li>If both allow the same algorithm or wildcard-based algorithm policy, the resulting key has the same algorithm policy.</li>
<li>If either of the policies allows an algorithm and the other policy allows a wildcard-based algorithm policy that includes this algorithm, the resulting key allows the same algorithm.</li>
<li>If the policies do not allow any algorithm in common, this function fails with the status <a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a>.</li>
</ul>
<p>The effect of this function on implementation-defined attributes is implementation-defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">source_key</td><td>The key to copy. It must allow the usage <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a>. If a private or secret key is being copied outside of a secure element it must also allow <a class="el" href="group__policy.html#ga7dddccdd1303176e87a4d20c87b589ed">PSA_KEY_USAGE_EXPORT</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributes</td><td>The attributes for the new key. They are used as follows:<ul>
<li>The key type and size may be 0. If either is nonzero, it must match the corresponding attribute of the source key.</li>
<li>The key location (the lifetime and, for persistent keys, the key identifier) is used directly.</li>
<li>The policy constraints (usage flags and algorithm policy) are combined from the source key and <code class="param">attributes</code> so that both sets of restrictions apply, as described in the documentation of this function. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target_key</td><td>On success, an identifier for the newly created key. For persistent keys, this is the key identifier defined in <code class="param">attributes</code>. <code>0</code> on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td><code class="param">source_key</code> is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gaf2b34cc87edc72f3ba90071a08210d20">PSA_ERROR_ALREADY_EXISTS</a></td><td>This is an attempt to create a persistent key, and there is already a persistent key with the given identifier. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td>The lifetime or identifier in <code class="param">attributes</code> are invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td>The policy constraints on the source and specified in <code class="param">attributes</code> are incompatible. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td><code class="param">attributes</code> specifies a key type or key size which does not match the attributes of the source key. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The source key does not have the <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a> usage flag. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The source key is not exportable and its lifetime does not allow copying it to the target's lifetime. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga91b2ad8a867517a2651f1b076c5216e5">PSA_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga897a45eb206a6f6b7be7ffbe36f0d766">PSA_ERROR_INSUFFICIENT_STORAGE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga08b10e70fa5ff0b05c631d9f8f6b2c6b">PSA_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gacebfbd25a7c2a727694fb57182a66533">PSA_ERROR_DATA_INVALID</a></td><td></td></tr>
    <tr><td class="paramname">PSA_ERROR_DATA_CORRUPT</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code.</td></tr>
  </table>
  </dd>
</dl>
<p>Make a copy of a key.</p>
<p>Copy key material from one location to another.</p>
<p>This function is primarily useful to copy a key from one location to another, since it populates a key using the material from another key which may have a different lifetime.</p>
<p>This function may be used to share a key with a different party, subject to implementation-defined restrictions on key sharing.</p>
<p>The policy on the source key must have the usage flag <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a> set. This flag is sufficient to permit the copy if the key has the lifetime <a class="el" href="group__key__lifetimes.html#ga8b438870ba69489b685730d346455108">PSA_KEY_LIFETIME_VOLATILE</a> or <a class="el" href="group__key__lifetimes.html#ga3713a01c5fcd5f7eae46ff22ceaf6d02">PSA_KEY_LIFETIME_PERSISTENT</a>. Some secure elements do not provide a way to copy a key without making it extractable from the secure element. If a key is located in such a secure element, then the key must have both usage flags <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a> and <a class="el" href="group__policy.html#ga7dddccdd1303176e87a4d20c87b589ed">PSA_KEY_USAGE_EXPORT</a> in order to make a copy of the key outside the secure element.</p>
<p>The resulting key may only be used in a way that conforms to both the policy of the original key and the policy specified in the <code class="param">attributes</code> parameter:</p><ul>
<li>The usage flags on the resulting key are the bitwise-and of the usage flags on the source policy and the usage flags in <code class="param">attributes</code>.</li>
<li>If both allow the same algorithm or wildcard-based algorithm policy, the resulting key has the same algorithm policy.</li>
<li>If either of the policies allows an algorithm and the other policy allows a wildcard-based algorithm policy that includes this algorithm, the resulting key allows the same algorithm.</li>
<li>If the policies do not allow any algorithm in common, this function fails with the status <a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a>.</li>
</ul>
<p>The effect of this function on implementation-defined attributes is implementation-defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">source_handle</td><td>The key to copy. It must be a valid key handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributes</td><td>The attributes for the new key. They are used as follows:<ul>
<li>The key type and size may be 0. If either is nonzero, it must match the corresponding attribute of the source key.</li>
<li>The key location (the lifetime and, for persistent keys, the key identifier) is used directly.</li>
<li>The policy constraints (usage flags and algorithm policy) are combined from the source key and <code class="param">attributes</code> so that both sets of restrictions apply, as described in the documentation of this function. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target_handle</td><td>On success, a handle to the newly created key. <code>0</code> on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td><code class="param">source_handle</code> is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gaf2b34cc87edc72f3ba90071a08210d20">PSA_ERROR_ALREADY_EXISTS</a></td><td>This is an attempt to create a persistent key, and there is already a persistent key with the given identifier. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td>The lifetime or identifier in <code class="param">attributes</code> are invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td>The policy constraints on the source and specified in <code class="param">attributes</code> are incompatible. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td><code class="param">attributes</code> specifies a key type or key size which does not match the attributes of the source key. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The source key does not have the <a class="el" href="group__policy.html#ga4605d686020a6cb433c5d78bf7e91689">PSA_KEY_USAGE_COPY</a> usage flag. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The source key is not exportable and its lifetime does not allow copying it to the target's lifetime. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga91b2ad8a867517a2651f1b076c5216e5">PSA_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga897a45eb206a6f6b7be7ffbe36f0d766">PSA_ERROR_INSUFFICIENT_STORAGE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga08b10e70fa5ff0b05c631d9f8f6b2c6b">PSA_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f52644312291335682fbc0292c43cd2" name="ga5f52644312291335682fbc0292c43cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f52644312291335682fbc0292c43cd2">&#9670;&#160;</a></span>psa_destroy_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_destroy_key </td>
          <td>(</td>
          <td class="paramtype">mbedtls_svc_key_id_t</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a key. </p>
<p>This function destroys a key from both volatile memory and, if applicable, non-volatile storage. Implementations shall make a best effort to ensure that that the key material cannot be recovered.</p>
<p>This function also erases any metadata such as policies and frees resources associated with the key.</p>
<p>If a key is currently in use in a multipart operation, then destroying the key will cause the multipart operation to fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifier of the key to erase. If this is <code>0</code>, do nothing and return <a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td><code class="param">key</code> was a valid identifier and the key material that it referred to has been erased. Alternatively, <code class="param">key</code> is <code>0</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The key cannot be erased because it is read-only, either due to a policy or due to physical restrictions. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td><code class="param">key</code> is not a valid identifier nor <code>0</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td>There was an failure in communication with the cryptoprocessor. The key material may still be present in the cryptoprocessor. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td>The storage is corrupted. Implementations shall make a best effort to erase key material even in this stage, however applications should be aware that it may be impossible to guarantee that the key material is not recoverable in such cases. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td>An unexpected condition which is not a storage corruption or a communication failure occurred. The cryptoprocessor may have been compromised. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code.</td></tr>
  </table>
  </dd>
</dl>
<p>This function destroys a key from both volatile memory and, if applicable, non-volatile storage. Implementations shall make a best effort to ensure that that the key material cannot be recovered.</p>
<p>This function also erases any metadata such as policies and frees resources associated with the key.</p>
<p>If a key is currently in use in a multipart operation, then destroying the key will cause the multipart operation to fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifier of the key to erase. If this is <code>0</code>, do nothing and return <a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td><code class="param">key</code> was a valid identifier and the key material that it referred to has been erased. Alternatively, <code class="param">key</code> is <code>0</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The key cannot be erased because it is read-only, either due to a policy or due to physical restrictions. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td><code class="param">key</code> is not a valid identifier nor <code>0</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td>There was an failure in communication with the cryptoprocessor. The key material may still be present in the cryptoprocessor. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gacebfbd25a7c2a727694fb57182a66533">PSA_ERROR_DATA_INVALID</a></td><td>This error is typically a result of either storage corruption on a cleartext storage backend, or an attempt to read data that was written by an incompatible version of the library. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td>The storage is corrupted. Implementations shall make a best effort to erase key material even in this stage, however applications should be aware that it may be impossible to guarantee that the key material is not recoverable in such cases. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td>An unexpected condition which is not a storage corruption or a communication failure occurred. The cryptoprocessor may have been compromised. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code.</td></tr>
  </table>
  </dd>
</dl>
<p>This function destroys a key from both volatile memory and, if applicable, non-volatile storage. Implementations shall make a best effort to ensure that that the key material cannot be recovered.</p>
<p>This function also erases any metadata such as policies and frees resources associated with the key. To free all resources associated with the key, all handles to the key must be closed or destroyed.</p>
<p>Destroying the key makes the handle invalid, and the key handle must not be used again by the application. Using other open handles to the destroyed key in a cryptographic operation will result in an error.</p>
<p>If a key is currently in use in a multipart operation, then destroying the key will cause the multipart operation to fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the key to erase. If this is <code>0</code>, do nothing and return <code>PSA_SUCCESS</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td><code class="param">handle</code> was a valid handle and the key material that it referred to has been erased. Alternatively, <code class="param">handle</code> is <code>0</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The key cannot be erased because it is read-only, either due to a policy or due to physical restrictions. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td><code class="param">handle</code> is not a valid handle nor <code>0</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td>There was an failure in communication with the cryptoprocessor. The key material may still be present in the cryptoprocessor. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td>The storage is corrupted. Implementations shall make a best effort to erase key material even in this stage, however applications should be aware that it may be impossible to guarantee that the key material is not recoverable in such cases. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td>An unexpected condition which is not a storage corruption or a communication failure occurred. The cryptoprocessor may have been compromised. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac161d9a354209b0bdaf1f302bf4619d3" name="gac161d9a354209b0bdaf1f302bf4619d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac161d9a354209b0bdaf1f302bf4619d3">&#9670;&#160;</a></span>psa_open_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_open_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__key__lifetimes.html#ga11e986351c65bd3dc3c0fe2cd9926e4b">psa_key_id_t</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">psa_key_handle_t *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a handle to an existing persistent key.</p>
<p>Open a handle to a persistent key. A key is persistent if it was created with a lifetime other than <a class="el" href="group__key__lifetimes.html#ga8b438870ba69489b685730d346455108">PSA_KEY_LIFETIME_VOLATILE</a>. A persistent key always has a nonzero key identifier, set with psa_set_key_id() when creating the key. Implementations may provide additional pre-provisioned keys that can be opened with psa_open_key(). Such keys have a key identifier in the vendor range, as documented in the description of <a class="el" href="group__key__lifetimes.html#ga11e986351c65bd3dc3c0fe2cd9926e4b">psa_key_id_t</a>.</p>
<p>The application must eventually close the handle with psa_close_key() or <a class="el" href="#ga5f52644312291335682fbc0292c43cd2" title="Destroy a key.">psa_destroy_key()</a> to release associated resources. If the application dies without calling one of these functions, the implementation should perform the equivalent of a call to psa_close_key().</p>
<p>Some implementations permit an application to open the same key multiple times. If this is successful, each call to psa_open_key() will return a different key handle.</p>
<dl class="section note"><dt>Note</dt><dd>Applications that rely on opening a key multiple times will not be portable to implementations that only permit a single key handle to be opened. See also :ref:`key-handles`.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>The persistent identifier of the key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">handle</td><td>On success, a handle to the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>Success. The application can now use the value of <code>*handle</code> to access the key. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga91b2ad8a867517a2651f1b076c5216e5">PSA_ERROR_INSUFFICIENT_MEMORY</a></td><td>The implementation does not have sufficient resources to open the key. This can be due to reaching an implementation limit on the number of open keys, the number of open key handles, or available memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga18646babb2ae6cbde02ea3828bbd9141">PSA_ERROR_DOES_NOT_EXIST</a></td><td>There is no persistent key with key identifier <code class="param">id</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td><code class="param">id</code> is not a valid persistent key identifier. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The specified key exists, but the application does not have the permission to access it. Note that this specification does not define any way to create such a key, but it may be possible through implementation-specific means. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code.</td></tr>
  </table>
  </dd>
</dl>
<p>Open a handle to an existing persistent key.</p>
<p>Open a handle to a persistent key. A key is persistent if it was created with a lifetime other than <a class="el" href="group__key__lifetimes.html#ga8b438870ba69489b685730d346455108">PSA_KEY_LIFETIME_VOLATILE</a>. A persistent key always has a nonzero key identifier, set with psa_set_key_id() when creating the key. Implementations may provide additional pre-provisioned keys that can be opened with psa_open_key(). Such keys have an application key identifier in the vendor range, as documented in the description of <a class="el" href="group__key__lifetimes.html#ga11e986351c65bd3dc3c0fe2cd9926e4b">psa_key_id_t</a>.</p>
<p>The application must eventually close the handle with psa_close_key() or <a class="el" href="#ga5f52644312291335682fbc0292c43cd2" title="Destroy a key.">psa_destroy_key()</a> to release associated resources. If the application dies without calling one of these functions, the implementation should perform the equivalent of a call to psa_close_key().</p>
<p>Some implementations permit an application to open the same key multiple times. If this is successful, each call to psa_open_key() will return a different key handle.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not part of the PSA Cryptography API Release 1.0.0 specification. It was defined in the 1.0 Beta 3 version of the specification but was removed in the 1.0.0 released version. This API is kept for the time being to not break applications relying on it. It is not deprecated yet but will be in the near future.</dd>
<dd>
Applications that rely on opening a key multiple times will not be portable to implementations that only permit a single key handle to be opened. See also :ref:`key-handles`.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>The persistent identifier of the key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">handle</td><td>On success, a handle to the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>Success. The application can now use the value of <code>*handle</code> to access the key. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga91b2ad8a867517a2651f1b076c5216e5">PSA_ERROR_INSUFFICIENT_MEMORY</a></td><td>The implementation does not have sufficient resources to open the key. This can be due to reaching an implementation limit on the number of open keys, the number of open key handles, or available memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga18646babb2ae6cbde02ea3828bbd9141">PSA_ERROR_DOES_NOT_EXIST</a></td><td>There is no persistent key with key identifier <code class="param">id</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td><code class="param">id</code> is not a valid persistent key identifier. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The specified key exists, but the application does not have the permission to access it. Note that this specification does not define any way to create such a key, but it may be possible through implementation-specific means. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a68fb898e28685e608c734ea54281b5" name="ga4a68fb898e28685e608c734ea54281b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a68fb898e28685e608c734ea54281b5">&#9670;&#160;</a></span>psa_purge_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_purge_key </td>
          <td>(</td>
          <td class="paramtype">mbedtls_svc_key_id_t</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove non-essential copies of key material from memory.</p>
<p>If the key identifier designates a volatile key, this functions does not do anything and returns successfully.</p>
<p>If the key identifier designates a persistent key, then this function will free all resources associated with the key in volatile memory. The key data in persistent storage is not affected and the key can still be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Identifier of the key to purge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>The key material will have been removed from memory if it is not currently required. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td><code class="param">key</code> is not a valid key identifier. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
