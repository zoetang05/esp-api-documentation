<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: Network interface (NETIF)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__netif.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Network interface (NETIF)<div class="ingroups"><a class="el" href="group__api.html">APIs</a> &raquo; <a class="el" href="group__callbackstyle__api.html">&quot;raw&quot; APIs</a> &#124; <a class="el" href="group__buffif.html">WHD Buffer Interface API</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__netif__ip4.html">IPv4 address handling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__netif__ip6.html">IPv6 address handling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__netif__cd.html">Client data handling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__netif__flags.html">Flags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__netif__mib2.html">MIB2 statistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwhd__netif__funcs.html">whd_netif_funcs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionnetif__ext__callback__args__t.html">netif_ext_callback_args_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga94a4c24c988afc0a577387730f303b19" id="r_ga94a4c24c988afc0a577387730f303b19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga94a4c24c988afc0a577387730f303b19">netif_is_up</a>(<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga94a4c24c988afc0a577387730f303b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab2b9387389513a02027c62e246723808" id="r_gab2b9387389513a02027c62e246723808"><td class="memItemLeft" align="right" valign="top">typedef u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab2b9387389513a02027c62e246723808">netif_nsc_reason_t</a></td></tr>
<tr class="separator:gab2b9387389513a02027c62e246723808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee213cea065424c89c66f138c008da1" id="r_ga5ee213cea065424c89c66f138c008da1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ee213cea065424c89c66f138c008da1">netif_ext_callback_fn</a>) (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>, <a class="el" href="#gab2b9387389513a02027c62e246723808">netif_nsc_reason_t</a> reason, const <a class="el" href="unionnetif__ext__callback__args__t.html">netif_ext_callback_args_t</a> *args)</td></tr>
<tr class="separator:ga5ee213cea065424c89c66f138c008da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3642a8b0fe0df7449730bec92e09c7d4" id="r_ga3642a8b0fe0df7449730bec92e09c7d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3642a8b0fe0df7449730bec92e09c7d4">whd_network_send_ethernet_data</a> (<a class="el" href="whd_8h.html#a2e544c482ddbb690bbb95ce7174e79a0">whd_interface_t</a> ifp, whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>)</td></tr>
<tr class="separator:ga3642a8b0fe0df7449730bec92e09c7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcb3925fb117375739abf97f3a856bcd" id="r_gafcb3925fb117375739abf97f3a856bcd"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafcb3925fb117375739abf97f3a856bcd">netif_add_noaddr</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>, void *<a class="el" href="pal__timer_8c.html#a51d375e3412343fad585076121e7d57a">state</a>, netif_init_fn init, netif_input_fn input)</td></tr>
<tr class="separator:gafcb3925fb117375739abf97f3a856bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde72af134ae7047a46ad7719d2a1ee9" id="r_gabde72af134ae7047a46ad7719d2a1ee9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabde72af134ae7047a46ad7719d2a1ee9">netif_add</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>, void *<a class="el" href="pal__timer_8c.html#a51d375e3412343fad585076121e7d57a">state</a>, netif_init_fn init, netif_input_fn input)</td></tr>
<tr class="separator:gabde72af134ae7047a46ad7719d2a1ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c6e541f0c184e1ea61a5cd8afe3e979" id="r_ga9c6e541f0c184e1ea61a5cd8afe3e979"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9c6e541f0c184e1ea61a5cd8afe3e979">netif_remove</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga9c6e541f0c184e1ea61a5cd8afe3e979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac90f290edd005238d62aa94c4ac9dea3" id="r_gac90f290edd005238d62aa94c4ac9dea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac90f290edd005238d62aa94c4ac9dea3">netif_set_default</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:gac90f290edd005238d62aa94c4ac9dea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9097318532ce3e74220a0cfcb78980" id="r_ga6c9097318532ce3e74220a0cfcb78980"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6c9097318532ce3e74220a0cfcb78980">netif_check_default</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga6c9097318532ce3e74220a0cfcb78980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf19693be401a265a52d2a56c65753121" id="r_gaf19693be401a265a52d2a56c65753121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf19693be401a265a52d2a56c65753121">netif_set_up</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:gaf19693be401a265a52d2a56c65753121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga641d07ed8c31fe5306bc01605a6790cf" id="r_ga641d07ed8c31fe5306bc01605a6790cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga641d07ed8c31fe5306bc01605a6790cf">netif_set_down</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga641d07ed8c31fe5306bc01605a6790cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d2975f189277990e9d5276fdd9e9ea" id="r_gae0d2975f189277990e9d5276fdd9e9ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0d2975f189277990e9d5276fdd9e9ea">netif_set_link_up</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:gae0d2975f189277990e9d5276fdd9e9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e37a1e8e358760dc1c43887922c7db" id="r_ga34e37a1e8e358760dc1c43887922c7db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga34e37a1e8e358760dc1c43887922c7db">netif_set_link_down</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga34e37a1e8e358760dc1c43887922c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763a1f647fb9e8af4254418e813a6ae" id="r_gac763a1f647fb9e8af4254418e813a6ae"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac763a1f647fb9e8af4254418e813a6ae">netif_name_to_index</a> (const char *name)</td></tr>
<tr class="separator:gac763a1f647fb9e8af4254418e813a6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e755cb6624d3365551eeed5430fa226" id="r_ga0e755cb6624d3365551eeed5430fa226"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0e755cb6624d3365551eeed5430fa226">netif_index_to_name</a> (u8_t idx, char *name)</td></tr>
<tr class="separator:ga0e755cb6624d3365551eeed5430fa226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa934434420c0dea7b5cfe6df67f8c77a" id="r_gaa934434420c0dea7b5cfe6df67f8c77a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa934434420c0dea7b5cfe6df67f8c77a">netif_get_by_index</a> (u8_t idx)</td></tr>
<tr class="separator:gaa934434420c0dea7b5cfe6df67f8c77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c82d1c742338828b2f4349a75bb84de" id="r_ga3c82d1c742338828b2f4349a75bb84de"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c82d1c742338828b2f4349a75bb84de">netif_find</a> (const char *name)</td></tr>
<tr class="separator:ga3c82d1c742338828b2f4349a75bb84de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2514130f0833f76109c8ba833bf069f" id="r_gae2514130f0833f76109c8ba833bf069f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae2514130f0833f76109c8ba833bf069f">netif_get_name</a> (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:gae2514130f0833f76109c8ba833bf069f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga518b1ced0ce179043ef44124fb3b8214" id="r_ga518b1ced0ce179043ef44124fb3b8214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="whd__types_8h.html#add62f4b5040a2451e23869d2f9e1ae05">whd_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga518b1ced0ce179043ef44124fb3b8214">whd_buffer_funcs::whd_host_buffer_get</a> )(whd_buffer_t *<a class="el" href="structbuffer.html">buffer</a>, <a class="el" href="group__buffif.html#ga44a64c51498b204ceef5555209e29452">whd_buffer_dir_t</a> direction, unsigned short size, unsigned long timeout_ms)</td></tr>
<tr class="separator:ga518b1ced0ce179043ef44124fb3b8214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a98dd9ae2b3e5ccf57023881529107" id="r_ga36a98dd9ae2b3e5ccf57023881529107"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga36a98dd9ae2b3e5ccf57023881529107">whd_buffer_funcs::whd_buffer_release</a> )(whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>, <a class="el" href="group__buffif.html#ga44a64c51498b204ceef5555209e29452">whd_buffer_dir_t</a> direction)</td></tr>
<tr class="separator:ga36a98dd9ae2b3e5ccf57023881529107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad23a9793f787e47d868114c9be241886" id="r_gad23a9793f787e47d868114c9be241886"><td class="memItemLeft" align="right" valign="top">uint8_t *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad23a9793f787e47d868114c9be241886">whd_buffer_funcs::whd_buffer_get_current_piece_data_pointer</a> )(whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>)</td></tr>
<tr class="separator:gad23a9793f787e47d868114c9be241886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8d968903441976411d3dbd91fba819" id="r_ga6d8d968903441976411d3dbd91fba819"><td class="memItemLeft" align="right" valign="top">uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6d8d968903441976411d3dbd91fba819">whd_buffer_funcs::whd_buffer_get_current_piece_size</a> )(whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>)</td></tr>
<tr class="separator:ga6d8d968903441976411d3dbd91fba819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3011bf458acc6dcb6b3e922cfdb32a33" id="r_ga3011bf458acc6dcb6b3e922cfdb32a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="whd__types_8h.html#add62f4b5040a2451e23869d2f9e1ae05">whd_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3011bf458acc6dcb6b3e922cfdb32a33">whd_buffer_funcs::whd_buffer_set_size</a> )(whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>, unsigned short size)</td></tr>
<tr class="separator:ga3011bf458acc6dcb6b3e922cfdb32a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b3124ee52ee3932334f38a342144c6" id="r_gad6b3124ee52ee3932334f38a342144c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="whd__types_8h.html#add62f4b5040a2451e23869d2f9e1ae05">whd_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6b3124ee52ee3932334f38a342144c6">whd_buffer_funcs::whd_buffer_add_remove_at_front</a> )(whd_buffer_t *<a class="el" href="structbuffer.html">buffer</a>, int32_t add_remove_amount)</td></tr>
<tr class="separator:gad6b3124ee52ee3932334f38a342144c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb9bad2932b75524910de599ef2c9b7" id="r_ga2cb9bad2932b75524910de599ef2c9b7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2cb9bad2932b75524910de599ef2c9b7">whd_netif_funcs::whd_network_process_ethernet_data</a> )(<a class="el" href="whd_8h.html#a2e544c482ddbb690bbb95ce7174e79a0">whd_interface_t</a> ifp, whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>)</td></tr>
<tr class="separator:ga2cb9bad2932b75524910de599ef2c9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Allows WHD to pass received data to the network stack, to send an ethernet frame to WHD, etc. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga94a4c24c988afc0a577387730f303b19" name="ga94a4c24c988afc0a577387730f303b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a4c24c988afc0a577387730f303b19">&#9670;&#160;</a></span>netif_is_up</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define netif_is_up</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structnetif.html">netif</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((<a class="code hl_struct" href="structnetif.html">netif</a>)-&gt;flags &amp; <a class="code hl_define" href="group__netif__flags.html#gab47d7d130693dc155f480a5bf447725e">NETIF_FLAG_UP</a>) ? (u8_t)1 : (u8_t)0)</div>
<div class="ttc" id="agroup__netif__flags_html_gab47d7d130693dc155f480a5bf447725e"><div class="ttname"><a href="group__netif__flags.html#gab47d7d130693dc155f480a5bf447725e">NETIF_FLAG_UP</a></div><div class="ttdeci">#define NETIF_FLAG_UP</div><div class="ttdef"><b>Definition</b> netif.h:85</div></div>
<div class="ttc" id="astructnetif_html"><div class="ttname"><a href="structnetif.html">netif</a></div><div class="ttdef"><b>Definition</b> ppp_service_if.h:157</div></div>
</div><!-- fragment --><p>Ask if an interface is up </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5ee213cea065424c89c66f138c008da1" name="ga5ee213cea065424c89c66f138c008da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee213cea065424c89c66f138c008da1">&#9670;&#160;</a></span>netif_ext_callback_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* netif_ext_callback_fn) (struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>, <a class="el" href="#gab2b9387389513a02027c62e246723808">netif_nsc_reason_t</a> reason, const <a class="el" href="unionnetif__ext__callback__args__t.html">netif_ext_callback_args_t</a> *args)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function used for extended netif status callbacks Note: When parsing reason argument, keep in mind that more reasons may be added in the future! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netif</td><td>netif that is affected by change </td></tr>
    <tr><td class="paramname">reason</td><td>change reason </td></tr>
    <tr><td class="paramname">args</td><td>depends on reason, see reason description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab2b9387389513a02027c62e246723808" name="gab2b9387389513a02027c62e246723808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2b9387389513a02027c62e246723808">&#9670;&#160;</a></span>netif_nsc_reason_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u16_t <a class="el" href="#gab2b9387389513a02027c62e246723808">netif_nsc_reason_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extended netif status callback (NSC) reasons flags. May be extended in the future! </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabde72af134ae7047a46ad7719d2a1ee9" name="gabde72af134ae7047a46ad7719d2a1ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabde72af134ae7047a46ad7719d2a1ee9">&#9670;&#160;</a></span>netif_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnetif.html">netif</a> * netif_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">netif_init_fn</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">netif_input_fn</td>          <td class="paramname"><span class="paramname"><em>input</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a network interface to the list of lwIP netifs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netif</td><td>a pre-allocated netif structure </td></tr>
    <tr><td class="paramname">ipaddr</td><td>IP address for the new netif </td></tr>
    <tr><td class="paramname">netmask</td><td>network mask for the new netif </td></tr>
    <tr><td class="paramname">gw</td><td>default gateway IP address for the new netif </td></tr>
    <tr><td class="paramname">state</td><td>opaque data passed to the new netif </td></tr>
    <tr><td class="paramname">init</td><td>callback function that initializes the interface </td></tr>
    <tr><td class="paramname">input</td><td>callback function that is called to pass ingress packets up in the protocol layer stack.<br  />
It is recommended to use a function that passes the input directly to the stack (<a class="el" href="group__lwip__nosys.html#ga5532f93d68c874fb99c681bff2165385">netif_input()</a>, NO_SYS=1 mode) or via sending a message to TCPIP thread (<a class="el" href="group__lwip__os.html#gae510f195171bed8499ae94e264a92717">tcpip_input()</a>, NO_SYS=0 mode).<br  />
These functions use netif flags NETIF_FLAG_ETHARP and NETIF_FLAG_ETHERNET to decide whether to forward to ethernet_input() or ip_input(). In other words, the functions only work when the netif driver is implemented correctly!<br  />
Most members of struct netif should be be initialized by the netif init function = netif driver (init parameter of this function).<br  />
IPv6: Don't forget to call netif_create_ip6_linklocal_address() after setting the MAC address in struct <a class="el" href="structnetif.html#ab91f76223d5a7f1a64f03ac9dd7113a4">netif.hwaddr</a> (IPv6 requires a link-local address).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>netif, or NULL if failed. </dd></dl>

</div>
</div>
<a id="gafcb3925fb117375739abf97f3a856bcd" name="gafcb3925fb117375739abf97f3a856bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcb3925fb117375739abf97f3a856bcd">&#9670;&#160;</a></span>netif_add_noaddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnetif.html">netif</a> * netif_add_noaddr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">netif_init_fn</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">netif_input_fn</td>          <td class="paramname"><span class="paramname"><em>input</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a network interface to the list of lwIP netifs.</p>
<p>Same as <a class="el" href="#gabde72af134ae7047a46ad7719d2a1ee9">netif_add</a> but without IPv4 addresses </p>

</div>
</div>
<a id="ga6c9097318532ce3e74220a0cfcb78980" name="ga6c9097318532ce3e74220a0cfcb78980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9097318532ce3e74220a0cfcb78980">&#9670;&#160;</a></span>netif_check_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool netif_check_default </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if network interface is the default network interface </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netif</td><td>the default network interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if netif is set to default one otherwise return false </dd></dl>

</div>
</div>
<a id="ga3c82d1c742338828b2f4349a75bb84de" name="ga3c82d1c742338828b2f4349a75bb84de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c82d1c742338828b2f4349a75bb84de">&#9670;&#160;</a></span>netif_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnetif.html">netif</a> * netif_find </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a network interface by searching for its name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the netif (like netif-&gt;name) plus concatenated number in ascii representation (e.g. 'en0') </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa934434420c0dea7b5cfe6df67f8c77a" name="gaa934434420c0dea7b5cfe6df67f8c77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa934434420c0dea7b5cfe6df67f8c77a">&#9670;&#160;</a></span>netif_get_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnetif.html">netif</a> * netif_get_by_index </td>
          <td>(</td>
          <td class="paramtype">u8_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the interface for the netif index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index of netif to find </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2514130f0833f76109c8ba833bf069f" name="gae2514130f0833f76109c8ba833bf069f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2514130f0833f76109c8ba833bf069f">&#9670;&#160;</a></span>netif_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * netif_get_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a network interface name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netif</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name the name of the netif (like netif-&gt;name) plus concatenated number in ascii representation (e.g. 'en0') </dd></dl>

</div>
</div>
<a id="ga0e755cb6624d3365551eeed5430fa226" name="ga0e755cb6624d3365551eeed5430fa226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e755cb6624d3365551eeed5430fa226">&#9670;&#160;</a></span>netif_index_to_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * netif_index_to_name </td>
          <td>(</td>
          <td class="paramtype">u8_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the interface name for the netif matching index or NULL if not found/on error</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the interface index of the netif </td></tr>
    <tr><td class="paramname">name</td><td>char buffer of at least NETIF_NAMESIZE bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac763a1f647fb9e8af4254418e813a6ae" name="gac763a1f647fb9e8af4254418e813a6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac763a1f647fb9e8af4254418e813a6ae">&#9670;&#160;</a></span>netif_name_to_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8_t netif_name_to_index </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the interface index for the netif with name or NETIF_NO_INDEX if not found/on error</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the netif </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c6e541f0c184e1ea61a5cd8afe3e979" name="ga9c6e541f0c184e1ea61a5cd8afe3e979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c6e541f0c184e1ea61a5cd8afe3e979">&#9670;&#160;</a></span>netif_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netif_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a network interface from the list of lwIP netifs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netif</td><td>the network interface to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac90f290edd005238d62aa94c4ac9dea3" name="gac90f290edd005238d62aa94c4ac9dea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac90f290edd005238d62aa94c4ac9dea3">&#9670;&#160;</a></span>netif_set_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netif_set_default </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a network interface as the default network interface (used to output all packets for which no specific route is found)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netif</td><td>the default network interface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga641d07ed8c31fe5306bc01605a6790cf" name="ga641d07ed8c31fe5306bc01605a6790cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga641d07ed8c31fe5306bc01605a6790cf">&#9670;&#160;</a></span>netif_set_down()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netif_set_down </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bring an interface down, disabling any traffic processing. </p>

</div>
</div>
<a id="ga34e37a1e8e358760dc1c43887922c7db" name="ga34e37a1e8e358760dc1c43887922c7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34e37a1e8e358760dc1c43887922c7db">&#9670;&#160;</a></span>netif_set_link_down()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netif_set_link_down </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by a driver when its link goes down </p>

</div>
</div>
<a id="gae0d2975f189277990e9d5276fdd9e9ea" name="gae0d2975f189277990e9d5276fdd9e9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d2975f189277990e9d5276fdd9e9ea">&#9670;&#160;</a></span>netif_set_link_up()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netif_set_link_up </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by a driver when its link goes up </p>

</div>
</div>
<a id="gaf19693be401a265a52d2a56c65753121" name="gaf19693be401a265a52d2a56c65753121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf19693be401a265a52d2a56c65753121">&#9670;&#160;</a></span>netif_set_up()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netif_set_up </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *</td>          <td class="paramname"><span class="paramname"><em>netif</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bring an interface up, available for processing traffic. </p>

</div>
</div>
<a id="ga3642a8b0fe0df7449730bec92e09c7d4" name="ga3642a8b0fe0df7449730bec92e09c7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3642a8b0fe0df7449730bec92e09c7d4">&#9670;&#160;</a></span>whd_network_send_ethernet_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void whd_network_send_ethernet_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="whd_8h.html#a2e544c482ddbb690bbb95ce7174e79a0">whd_interface_t</a></td>          <td class="paramname"><span class="paramname"><em>ifp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">whd_buffer_t</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To send an ethernet frame to WHD (called by the Network Stack)</p>
<p>This function takes ethernet data from the network stack and queues it for transmission over the wireless network. The function can be called from any thread context as it is thread safe, however it must not be called from interrupt context since it might get blocked while waiting for a lock on the transmit queue.</p>
<p>This function returns immediately after the packet has been queued for transmit, NOT after it has been transmitted. Packet buffers passed to the WHD are released inside the WHD once they have been transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ifp</td><td>Pointer to handle instance of whd interface </td></tr>
    <tr><td class="paramname">buffer</td><td>Handle of the packet buffer to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WHD_SUCCESS or Error code</dd></dl>
<p>Sends a data packet.</p>
<p>This function should be called by the bottom of the network stack in order for it to send an ethernet frame. The function prepends a BDC header, before sending to whd_send_to_bus where the BUS header will be added</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>: The ethernet packet buffer to be sent </td></tr>
    <tr><td class="paramname">interface</td><td>: the interface over which to send the packet (AP or STA) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gad6b3124ee52ee3932334f38a342144c6" name="gad6b3124ee52ee3932334f38a342144c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b3124ee52ee3932334f38a342144c6">&#9670;&#160;</a></span>whd_buffer_add_remove_at_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="whd__types_8h.html#add62f4b5040a2451e23869d2f9e1ae05">whd_result_t</a>(* whd_buffer_funcs::whd_buffer_add_remove_at_front) (whd_buffer_t *<a class="el" href="structbuffer.html">buffer</a>, int32_t add_remove_amount)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the current pointer of a packet buffer</p>
<p>Implemented in the port layer interface which is specific to the buffering scheme in use.</p>
<p>Since packet buffers usually need to be created with space at the front for additional headers, this function allows WHD to move the current 'front' location pointer so that it has space to add headers to transmit packets, and so that the network stack does not see the internal WHD headers on received packets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to the handle of the current packet buffer for which the current pointer will be moved. On return this may contain a pointer to a newly allocated packet buffer which has been daisy chained to the front of the given packet buffer. This would be the case if the given packet buffer didn't have enough space at the front. </td></tr>
    <tr><td class="paramname">add_remove_amount</td><td>This is the number of bytes to move the current pointer of the packet buffer - a negative value increases the space for headers at the front of the packet, a positive value decreases the space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WHD_SUCCESS or error code </dd></dl>

</div>
</div>
<a id="gad23a9793f787e47d868114c9be241886" name="gad23a9793f787e47d868114c9be241886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad23a9793f787e47d868114c9be241886">&#9670;&#160;</a></span>whd_buffer_get_current_piece_data_pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t *(* whd_buffer_funcs::whd_buffer_get_current_piece_data_pointer) (whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current pointer of a packet buffer</p>
<p>Implemented in the port layer interface which is specific to the buffering scheme in use. Since packet buffers usually need to be created with space at the front for additional headers, this function allows WHD to get the current 'front' location pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The handle of the packet buffer whose pointer is to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The packet buffer's current pointer. </dd></dl>

</div>
</div>
<a id="ga6d8d968903441976411d3dbd91fba819" name="ga6d8d968903441976411d3dbd91fba819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d8d968903441976411d3dbd91fba819">&#9670;&#160;</a></span>whd_buffer_get_current_piece_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t(* whd_buffer_funcs::whd_buffer_get_current_piece_size) (whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the size of a packet buffer</p>
<p>Implemented in the port layer interface which is specific to the buffering scheme in use. Since packet buffers usually need to be created with space at the front for additional headers, the memory block use to contain a packet buffer will often be larger than the current size of the packet buffer data. This function allows WHD to retrieve the current size of a packet buffer's data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The handle of the packet buffer whose size is to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the packet buffer. </dd></dl>

</div>
</div>
<a id="ga36a98dd9ae2b3e5ccf57023881529107" name="ga36a98dd9ae2b3e5ccf57023881529107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36a98dd9ae2b3e5ccf57023881529107">&#9670;&#160;</a></span>whd_buffer_release</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* whd_buffer_funcs::whd_buffer_release) (whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>, <a class="el" href="group__buffif.html#ga44a64c51498b204ceef5555209e29452">whd_buffer_dir_t</a> direction)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a packet buffer</p>
<p>Implemented in the port layer interface, which will be specific to the buffering scheme in use. This function is used by WHD to indicate that it no longer requires a packet buffer. The buffer can then be released back into a pool for reuse, or the dynamically allocated memory can be freed, according to how the packet was allocated. Returns void since WHD cannot do anything about failures</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The handle of the packet buffer to be released </td></tr>
    <tr><td class="paramname">direction</td><td>Indicates transmit/receive direction that the packet buffer has been used for. This might be needed if tx/rx pools are separate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3011bf458acc6dcb6b3e922cfdb32a33" name="ga3011bf458acc6dcb6b3e922cfdb32a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3011bf458acc6dcb6b3e922cfdb32a33">&#9670;&#160;</a></span>whd_buffer_set_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="whd__types_8h.html#add62f4b5040a2451e23869d2f9e1ae05">whd_result_t</a>(* whd_buffer_funcs::whd_buffer_set_size) (whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>, unsigned short size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current size of a WHD packet</p>
<p>Implemented in the port layer interface which is specific to the buffering scheme in use. This function sets the current length of a WHD packet buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The packet to be modified </td></tr>
    <tr><td class="paramname">size</td><td>The new size of the packet buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WHD_SUCCESS or error code </dd></dl>

</div>
</div>
<a id="ga518b1ced0ce179043ef44124fb3b8214" name="ga518b1ced0ce179043ef44124fb3b8214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga518b1ced0ce179043ef44124fb3b8214">&#9670;&#160;</a></span>whd_host_buffer_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="whd__types_8h.html#add62f4b5040a2451e23869d2f9e1ae05">whd_result_t</a>(* whd_buffer_funcs::whd_host_buffer_get) (whd_buffer_t *<a class="el" href="structbuffer.html">buffer</a>, <a class="el" href="group__buffif.html#ga44a64c51498b204ceef5555209e29452">whd_buffer_dir_t</a> direction, unsigned short size, unsigned long timeout_ms)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a packet buffer</p>
<p>Implemented in the port layer interface which is specific to the buffering scheme in use. Attempts to allocate a packet buffer of the size requested. It can do this by allocating a pre-existing packet from a pool, using a static buffer, or by dynamically allocating memory. The method of allocation does not concern WHD, however it must match the way the network stack expects packet buffers to be allocated. Usually WHD requires packet of size of WHD_LINK_MTU which includes the MTU, other other various header. Refer to <a class="el" href="whd__types_8h.html">whd_types.h</a> to find the size of WHD_LINK_MTU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer which receives the allocated packet buffer handle </td></tr>
    <tr><td class="paramname">direction</td><td>Indicates transmit/receive direction that the packet buffer is used for. This may be needed if tx/rx pools are separate. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to allocate. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Maximum period to block for available buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WHD_SUCCESS or error code </dd></dl>

</div>
</div>
<a id="ga2cb9bad2932b75524910de599ef2c9b7" name="ga2cb9bad2932b75524910de599ef2c9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cb9bad2932b75524910de599ef2c9b7">&#9670;&#160;</a></span>whd_network_process_ethernet_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* whd_netif_funcs::whd_network_process_ethernet_data) (<a class="el" href="whd_8h.html#a2e544c482ddbb690bbb95ce7174e79a0">whd_interface_t</a> ifp, whd_buffer_t <a class="el" href="structbuffer.html">buffer</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by WHD to pass received data to the network stack</p>
<p>Packets received from the Wi-Fi network by WHD are forwarded to by calling function ptr which must be implemented in the network interface. Ethernet headers are present at the start of these packet buffers.</p>
<p>This function is called asynchronously in the context of the WHD thread whenever new data has arrived. Packet buffers are allocated within WHD, and ownership is transferred to the network stack. The network stack or application is thus responsible for releasing the packet buffers. Most packet buffering systems have a pointer to the 'current point' within the packet buffer. When this function is called, the pointer points to the start of the Ethernet header. There is other inconsequential data before the Ethernet header.</p>
<p>It is preferable that the (whd_network_process_ethernet_data)() function simply puts the received packet on a queue for processing by another thread. This avoids the WHD thread being unnecessarily tied up which would delay other packets being transmitted or received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>The interface on which the packet was received. </td></tr>
    <tr><td class="paramname">buffer</td><td>Handle of the packet which has just been received. Responsibility for releasing this buffer is transferred from WHD at this point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
