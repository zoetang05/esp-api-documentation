<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: atomic functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__platform__atomic.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">atomic functions<div class="ingroups"><a class="el" href="group__platform-public-api.html">Platform</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae9a9154d568478a454e3bf79edaf4eb1" id="r_gae9a9154d568478a454e3bf79edaf4eb1"><td class="memItemLeft" align="right" valign="top"><a id="gae9a9154d568478a454e3bf79edaf4eb1" name="gae9a9154d568478a454e3bf79edaf4eb1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_EXCLUSIVE_ACCESS</b>&#160;&#160;&#160;0U</td></tr>
<tr class="separator:gae9a9154d568478a454e3bf79edaf4eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf36030af6d10769e1e2854943da145" id="r_ga6bf36030af6d10769e1e2854943da145"><td class="memItemLeft" align="right" valign="top"><a id="ga6bf36030af6d10769e1e2854943da145" name="ga6bf36030af6d10769e1e2854943da145"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_INLINE_IF_EX</b></td></tr>
<tr class="separator:ga6bf36030af6d10769e1e2854943da145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f56a572a9d71e864311c431ee1131a" id="r_gaa8f56a572a9d71e864311c431ee1131a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8f56a572a9d71e864311c431ee1131a">CORE_UTIL_ATOMIC_FLAG_INIT</a>&#160;&#160;&#160;{ 0 }</td></tr>
<tr class="separator:gaa8f56a572a9d71e864311c431ee1131a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf76273ffa0f2b491126baf28ba1af025" id="r_gaf76273ffa0f2b491126baf28ba1af025"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf76273ffa0f2b491126baf28ba1af025">mbed_memory_order</a></td></tr>
<tr class="separator:gaf76273ffa0f2b491126baf28ba1af025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab09a83ac4701fab4cec225b2dd08b7a8" id="r_gab09a83ac4701fab4cec225b2dd08b7a8"><td class="memItemLeft" align="right" valign="top">typedef struct core_util_atomic_flag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab09a83ac4701fab4cec225b2dd08b7a8">core_util_atomic_flag</a></td></tr>
<tr class="separator:gab09a83ac4701fab4cec225b2dd08b7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa770b34054b2e54c6bcbd0e9423ecd88" id="r_gaa770b34054b2e54c6bcbd0e9423ecd88"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> { <br />
&#160;&#160;<b>mbed_memory_order_relaxed</b> = 0x00
, <b>mbed_memory_order_consume</b> = 0x01
, <b>mbed_memory_order_acquire</b> = 0x02
, <b>mbed_memory_order_release</b> = 0x04
, <br />
&#160;&#160;<b>mbed_memory_order_acq_rel</b> = 0x06
, <b>mbed_memory_order_seq_cst</b> = 0x16
<br />
 }</td></tr>
<tr class="separator:gaa770b34054b2e54c6bcbd0e9423ecd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga089a51dfa1c87b1ad6c9855b67e6143e" id="r_ga089a51dfa1c87b1ad6c9855b67e6143e"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga089a51dfa1c87b1ad6c9855b67e6143e">core_util_atomic_flag_test_and_set</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr)</td></tr>
<tr class="separator:ga089a51dfa1c87b1ad6c9855b67e6143e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae873e0a5133bece10fa16b29c43ecc34" id="r_gae873e0a5133bece10fa16b29c43ecc34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae873e0a5133bece10fa16b29c43ecc34">core_util_atomic_flag_test_and_set_explicit</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gae873e0a5133bece10fa16b29c43ecc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5e3f9d2bd9cf92276dacdc3928f4f0" id="r_gafe5e3f9d2bd9cf92276dacdc3928f4f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe5e3f9d2bd9cf92276dacdc3928f4f0">core_util_atomic_flag_clear</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr)</td></tr>
<tr class="separator:gafe5e3f9d2bd9cf92276dacdc3928f4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1918431bfda711a76ff391ae95f7cdd" id="r_gaa1918431bfda711a76ff391ae95f7cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1918431bfda711a76ff391ae95f7cdd">core_util_atomic_flag_clear_explicit</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaa1918431bfda711a76ff391ae95f7cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767b5eaddcdd294e69bc455f61f8db5b" id="r_ga767b5eaddcdd294e69bc455f61f8db5b"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga767b5eaddcdd294e69bc455f61f8db5b">core_util_atomic_cas_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)</td></tr>
<tr class="separator:ga767b5eaddcdd294e69bc455f61f8db5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c9313f1a6be27bed9a3becfde0bee7" id="r_ga93c9313f1a6be27bed9a3becfde0bee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga93c9313f1a6be27bed9a3becfde0bee7">core_util_atomic_cas_explicit_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga93c9313f1a6be27bed9a3becfde0bee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7fc357ed0e0d9297584ffd5352d1d4" id="r_ga5f7fc357ed0e0d9297584ffd5352d1d4"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f7fc357ed0e0d9297584ffd5352d1d4">core_util_atomic_cas_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)</td></tr>
<tr class="separator:ga5f7fc357ed0e0d9297584ffd5352d1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae923f73dccaad3e5bca9ce02ce47fbe" id="r_gaae923f73dccaad3e5bca9ce02ce47fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaae923f73dccaad3e5bca9ce02ce47fbe">core_util_atomic_cas_explicit_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gaae923f73dccaad3e5bca9ce02ce47fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc5125cdcb932f43d5b8ae36e8e1d2b" id="r_ga4cc5125cdcb932f43d5b8ae36e8e1d2b"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4cc5125cdcb932f43d5b8ae36e8e1d2b">core_util_atomic_cas_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)</td></tr>
<tr class="separator:ga4cc5125cdcb932f43d5b8ae36e8e1d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b4b2754592e31420d1f2b38593b8d7" id="r_ga87b4b2754592e31420d1f2b38593b8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga87b4b2754592e31420d1f2b38593b8d7">core_util_atomic_cas_explicit_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga87b4b2754592e31420d1f2b38593b8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dd9c14f13cf180e6ecdaea8da6fe11" id="r_ga85dd9c14f13cf180e6ecdaea8da6fe11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga85dd9c14f13cf180e6ecdaea8da6fe11">core_util_atomic_cas_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue)</td></tr>
<tr class="separator:ga85dd9c14f13cf180e6ecdaea8da6fe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83dc3029317f487bfef8c984ee92cb06" id="r_ga83dc3029317f487bfef8c984ee92cb06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga83dc3029317f487bfef8c984ee92cb06">core_util_atomic_cas_explicit_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga83dc3029317f487bfef8c984ee92cb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45910fe69f1d67e6f85654e6b137ad3c" id="r_ga45910fe69f1d67e6f85654e6b137ad3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga45910fe69f1d67e6f85654e6b137ad3c">core_util_atomic_cas_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue)</td></tr>
<tr class="separator:ga45910fe69f1d67e6f85654e6b137ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad741471e0981d7dd88e15b7e285d3eb0" id="r_gad741471e0981d7dd88e15b7e285d3eb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad741471e0981d7dd88e15b7e285d3eb0">core_util_atomic_cas_explicit_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gad741471e0981d7dd88e15b7e285d3eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d84165af1254189e8c61166ce6b1ff" id="r_ga05d84165af1254189e8c61166ce6b1ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga05d84165af1254189e8c61166ce6b1ff">core_util_atomic_cas_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue)</td></tr>
<tr class="separator:ga05d84165af1254189e8c61166ce6b1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf63939b06da44cb49a313698053aeb5" id="r_gacf63939b06da44cb49a313698053aeb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacf63939b06da44cb49a313698053aeb5">core_util_atomic_cas_explicit_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gacf63939b06da44cb49a313698053aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205688ff94fc52b0652c9399d38ed875" id="r_ga205688ff94fc52b0652c9399d38ed875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga205688ff94fc52b0652c9399d38ed875">core_util_atomic_cas_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue)</td></tr>
<tr class="separator:ga205688ff94fc52b0652c9399d38ed875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab572aa9bd7e1ded44f7e6adafb7fe13a" id="r_gab572aa9bd7e1ded44f7e6adafb7fe13a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab572aa9bd7e1ded44f7e6adafb7fe13a">core_util_atomic_cas_explicit_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gab572aa9bd7e1ded44f7e6adafb7fe13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eaa833099480b1cd7f87bb06d93da2d" id="r_ga6eaa833099480b1cd7f87bb06d93da2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6eaa833099480b1cd7f87bb06d93da2d">core_util_atomic_cas_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue)</td></tr>
<tr class="separator:ga6eaa833099480b1cd7f87bb06d93da2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69a97a89c2881c8a9584602e087729e" id="r_gad69a97a89c2881c8a9584602e087729e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad69a97a89c2881c8a9584602e087729e">core_util_atomic_cas_explicit_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gad69a97a89c2881c8a9584602e087729e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf62e56b6923b86006b8f04c57b62e2" id="r_gacbf62e56b6923b86006b8f04c57b62e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacbf62e56b6923b86006b8f04c57b62e2">core_util_atomic_cas_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue)</td></tr>
<tr class="separator:gacbf62e56b6923b86006b8f04c57b62e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e8c63fcd66c95d8bf4b29d3bc3745bb" id="r_ga5e8c63fcd66c95d8bf4b29d3bc3745bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5e8c63fcd66c95d8bf4b29d3bc3745bb">core_util_atomic_cas_explicit_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga5e8c63fcd66c95d8bf4b29d3bc3745bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e9cbb15b6cae6154a5f85b483e9358" id="r_gaf9e9cbb15b6cae6154a5f85b483e9358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9e9cbb15b6cae6154a5f85b483e9358">core_util_atomic_cas_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue)</td></tr>
<tr class="separator:gaf9e9cbb15b6cae6154a5f85b483e9358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3370fd30e8d1721807aad74a7a4f44" id="r_ga1c3370fd30e8d1721807aad74a7a4f44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1c3370fd30e8d1721807aad74a7a4f44">core_util_atomic_cas_explicit_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga1c3370fd30e8d1721807aad74a7a4f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75916cac3d2ca9f9b3d502f8131dcbd2" id="r_ga75916cac3d2ca9f9b3d502f8131dcbd2"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga75916cac3d2ca9f9b3d502f8131dcbd2">core_util_atomic_compare_exchange_weak_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)</td></tr>
<tr class="separator:ga75916cac3d2ca9f9b3d502f8131dcbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ea57a2b4c9d2958d6d4b9d981db3f63" id="r_ga8ea57a2b4c9d2958d6d4b9d981db3f63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8ea57a2b4c9d2958d6d4b9d981db3f63">core_util_atomic_compare_exchange_weak_explicit_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga8ea57a2b4c9d2958d6d4b9d981db3f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f9d09cc36f37bc162dd27c32d07148e" id="r_ga5f9d09cc36f37bc162dd27c32d07148e"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f9d09cc36f37bc162dd27c32d07148e">core_util_atomic_compare_exchange_weak_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)</td></tr>
<tr class="separator:ga5f9d09cc36f37bc162dd27c32d07148e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5739219816da159aeaae5096ac4f074d" id="r_ga5739219816da159aeaae5096ac4f074d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5739219816da159aeaae5096ac4f074d">core_util_atomic_compare_exchange_weak_explicit_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga5739219816da159aeaae5096ac4f074d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec41265a1c29e428d75bef02360fc402" id="r_gaec41265a1c29e428d75bef02360fc402"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaec41265a1c29e428d75bef02360fc402">core_util_atomic_compare_exchange_weak_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)</td></tr>
<tr class="separator:gaec41265a1c29e428d75bef02360fc402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc40dbc99cecfa5bac04ebd65c9c0a5" id="r_gafcc40dbc99cecfa5bac04ebd65c9c0a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafcc40dbc99cecfa5bac04ebd65c9c0a5">core_util_atomic_compare_exchange_weak_explicit_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gafcc40dbc99cecfa5bac04ebd65c9c0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadaa71b8ed5127cb9591fed2cd524b1e" id="r_gaadaa71b8ed5127cb9591fed2cd524b1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaadaa71b8ed5127cb9591fed2cd524b1e">core_util_atomic_compare_exchange_weak_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue)</td></tr>
<tr class="separator:gaadaa71b8ed5127cb9591fed2cd524b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb1873cce70f0814a2e65d2bcee84d74" id="r_gabb1873cce70f0814a2e65d2bcee84d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabb1873cce70f0814a2e65d2bcee84d74">core_util_atomic_compare_exchange_weak_explicit_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gabb1873cce70f0814a2e65d2bcee84d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18413a098f190ede59e9a7dd817480f" id="r_gad18413a098f190ede59e9a7dd817480f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad18413a098f190ede59e9a7dd817480f">core_util_atomic_compare_exchange_weak_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue)</td></tr>
<tr class="separator:gad18413a098f190ede59e9a7dd817480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cdb3fd8dfde2fc0b1da38000982bda5" id="r_ga6cdb3fd8dfde2fc0b1da38000982bda5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6cdb3fd8dfde2fc0b1da38000982bda5">core_util_atomic_compare_exchange_weak_explicit_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga6cdb3fd8dfde2fc0b1da38000982bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b36d178f7b14331ac054ee7de7826e" id="r_ga03b36d178f7b14331ac054ee7de7826e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga03b36d178f7b14331ac054ee7de7826e">core_util_atomic_compare_exchange_weak_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue)</td></tr>
<tr class="separator:ga03b36d178f7b14331ac054ee7de7826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e345fb761331b2883c063bc6505892" id="r_ga22e345fb761331b2883c063bc6505892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga22e345fb761331b2883c063bc6505892">core_util_atomic_compare_exchange_weak_explicit_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga22e345fb761331b2883c063bc6505892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf10dda44c9c989072495022edae918" id="r_gaeaf10dda44c9c989072495022edae918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeaf10dda44c9c989072495022edae918">core_util_atomic_compare_exchange_weak_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue)</td></tr>
<tr class="separator:gaeaf10dda44c9c989072495022edae918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7686b4293e7ea7bf4950dd5db438c3d" id="r_gad7686b4293e7ea7bf4950dd5db438c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad7686b4293e7ea7bf4950dd5db438c3d">core_util_atomic_compare_exchange_weak_explicit_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gad7686b4293e7ea7bf4950dd5db438c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d26060ebf45bc519c5e769b369977a" id="r_ga86d26060ebf45bc519c5e769b369977a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga86d26060ebf45bc519c5e769b369977a">core_util_atomic_compare_exchange_weak_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue)</td></tr>
<tr class="separator:ga86d26060ebf45bc519c5e769b369977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae818c803e9b789a9155f2582957284cc" id="r_gae818c803e9b789a9155f2582957284cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae818c803e9b789a9155f2582957284cc">core_util_atomic_compare_exchange_weak_explicit_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gae818c803e9b789a9155f2582957284cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d769b78dbd7f22cbb904d7b768ca45" id="r_gab1d769b78dbd7f22cbb904d7b768ca45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1d769b78dbd7f22cbb904d7b768ca45">core_util_atomic_compare_exchange_weak_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue)</td></tr>
<tr class="separator:gab1d769b78dbd7f22cbb904d7b768ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeec7abf1f4deb39287ae36d53e543b4" id="r_gadeec7abf1f4deb39287ae36d53e543b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadeec7abf1f4deb39287ae36d53e543b4">core_util_atomic_compare_exchange_weak_explicit_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gadeec7abf1f4deb39287ae36d53e543b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1778c0381b19ace75e5228c4be8448d" id="r_gaf1778c0381b19ace75e5228c4be8448d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf1778c0381b19ace75e5228c4be8448d">core_util_atomic_compare_exchange_weak_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue)</td></tr>
<tr class="separator:gaf1778c0381b19ace75e5228c4be8448d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad9cc64f6c880a1608a120f41c8ffbb" id="r_ga0ad9cc64f6c880a1608a120f41c8ffbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0ad9cc64f6c880a1608a120f41c8ffbb">core_util_atomic_compare_exchange_weak_explicit_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga0ad9cc64f6c880a1608a120f41c8ffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2840954e59468ea85b91e17ca50ad009" id="r_ga2840954e59468ea85b91e17ca50ad009"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2840954e59468ea85b91e17ca50ad009">core_util_atomic_load_u8</a> (const volatile uint8_t *valuePtr)</td></tr>
<tr class="separator:ga2840954e59468ea85b91e17ca50ad009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5b21126d2a22858faaf8018b5e66f9" id="r_ga4b5b21126d2a22858faaf8018b5e66f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b5b21126d2a22858faaf8018b5e66f9">core_util_atomic_load_explicit_u8</a> (const volatile uint8_t *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga4b5b21126d2a22858faaf8018b5e66f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b13b1196ed2a63802d7acf2ea08aaf4" id="r_ga6b13b1196ed2a63802d7acf2ea08aaf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6b13b1196ed2a63802d7acf2ea08aaf4">core_util_atomic_load_u16</a> (const volatile uint16_t *valuePtr)</td></tr>
<tr class="separator:ga6b13b1196ed2a63802d7acf2ea08aaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a81771e47a93b508d6ec3f4666b506e" id="r_ga2a81771e47a93b508d6ec3f4666b506e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2a81771e47a93b508d6ec3f4666b506e">core_util_atomic_load_explicit_u16</a> (const volatile uint16_t *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga2a81771e47a93b508d6ec3f4666b506e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade580faac99dbf59aeda5da1e4c213ad" id="r_gade580faac99dbf59aeda5da1e4c213ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gade580faac99dbf59aeda5da1e4c213ad">core_util_atomic_load_u32</a> (const volatile uint32_t *valuePtr)</td></tr>
<tr class="separator:gade580faac99dbf59aeda5da1e4c213ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa85935b1f85886bd69c028aad61d16ce" id="r_gaa85935b1f85886bd69c028aad61d16ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa85935b1f85886bd69c028aad61d16ce">core_util_atomic_load_explicit_u32</a> (const volatile uint32_t *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaa85935b1f85886bd69c028aad61d16ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae79f750b7b18b9b6c54b9f67c235195f" id="r_gae79f750b7b18b9b6c54b9f67c235195f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae79f750b7b18b9b6c54b9f67c235195f">core_util_atomic_load_u64</a> (const volatile uint64_t *valuePtr)</td></tr>
<tr class="separator:gae79f750b7b18b9b6c54b9f67c235195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf24e043d3f39b59e5c4e53f7d39558d0" id="r_gaf24e043d3f39b59e5c4e53f7d39558d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf24e043d3f39b59e5c4e53f7d39558d0">core_util_atomic_load_explicit_u64</a> (const volatile uint64_t *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaf24e043d3f39b59e5c4e53f7d39558d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecfddc99e71a90287f0220e8fd3e206" id="r_gaeecfddc99e71a90287f0220e8fd3e206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeecfddc99e71a90287f0220e8fd3e206">core_util_atomic_load_s8</a> (const volatile int8_t *valuePtr)</td></tr>
<tr class="separator:gaeecfddc99e71a90287f0220e8fd3e206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765734c8f47168fbf2e1d3583466df96" id="r_ga765734c8f47168fbf2e1d3583466df96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga765734c8f47168fbf2e1d3583466df96">core_util_atomic_load_explicit_s8</a> (const volatile int8_t *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga765734c8f47168fbf2e1d3583466df96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga663356b18705a1c4ae4d87643ae239f6" id="r_ga663356b18705a1c4ae4d87643ae239f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga663356b18705a1c4ae4d87643ae239f6">core_util_atomic_load_s16</a> (const volatile int16_t *valuePtr)</td></tr>
<tr class="separator:ga663356b18705a1c4ae4d87643ae239f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99004d90211c9e8b31d40a5a86312a8f" id="r_ga99004d90211c9e8b31d40a5a86312a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga99004d90211c9e8b31d40a5a86312a8f">core_util_atomic_load_explicit_s16</a> (const volatile int16_t *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga99004d90211c9e8b31d40a5a86312a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1994aaeae2efb36b58051da401a95b36" id="r_ga1994aaeae2efb36b58051da401a95b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1994aaeae2efb36b58051da401a95b36">core_util_atomic_load_s32</a> (const volatile int32_t *valuePtr)</td></tr>
<tr class="separator:ga1994aaeae2efb36b58051da401a95b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a70e0153206702a003de75ffe9b86aa" id="r_ga5a70e0153206702a003de75ffe9b86aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a70e0153206702a003de75ffe9b86aa">core_util_atomic_load_explicit_s32</a> (const volatile int32_t *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga5a70e0153206702a003de75ffe9b86aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga100297ebd80cd21846398c6ad7d81f43" id="r_ga100297ebd80cd21846398c6ad7d81f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga100297ebd80cd21846398c6ad7d81f43">core_util_atomic_load_s64</a> (const volatile int64_t *valuePtr)</td></tr>
<tr class="separator:ga100297ebd80cd21846398c6ad7d81f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga426c13fee706b73968b19273be5544fd" id="r_ga426c13fee706b73968b19273be5544fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga426c13fee706b73968b19273be5544fd">core_util_atomic_load_explicit_s64</a> (const volatile int64_t *valuePtr, <a class="el" href="group__platform__toolchain.html#ga3e0b3dc191a8e64de80be44bbc8d5193">MBED_UNUSED</a> <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga426c13fee706b73968b19273be5544fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba968e929680be76321b4c639287f968" id="r_gaba968e929680be76321b4c639287f968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaba968e929680be76321b4c639287f968">core_util_atomic_load_bool</a> (const volatile bool *valuePtr)</td></tr>
<tr class="separator:gaba968e929680be76321b4c639287f968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4b4c68346a582ed810f5a42f9083e6" id="r_ga2b4b4c68346a582ed810f5a42f9083e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2b4b4c68346a582ed810f5a42f9083e6">core_util_atomic_load_explicit_bool</a> (const volatile bool *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga2b4b4c68346a582ed810f5a42f9083e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87170ad015a30beac00a7764b456c7ea" id="r_ga87170ad015a30beac00a7764b456c7ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga87170ad015a30beac00a7764b456c7ea">core_util_atomic_load_ptr</a> (void *const volatile *valuePtr)</td></tr>
<tr class="separator:ga87170ad015a30beac00a7764b456c7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce10c2fe84037a9ffc96d99090f154a" id="r_ga9ce10c2fe84037a9ffc96d99090f154a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9ce10c2fe84037a9ffc96d99090f154a">core_util_atomic_load_explicit_ptr</a> (void *const volatile *valuePtr, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga9ce10c2fe84037a9ffc96d99090f154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c3fa6d415e012c34c7c82056817f29" id="r_gaf5c3fa6d415e012c34c7c82056817f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5c3fa6d415e012c34c7c82056817f29">core_util_atomic_store_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue)</td></tr>
<tr class="separator:gaf5c3fa6d415e012c34c7c82056817f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1cdaf85b894b8bccb88e870577f324" id="r_gaca1cdaf85b894b8bccb88e870577f324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaca1cdaf85b894b8bccb88e870577f324">core_util_atomic_store_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaca1cdaf85b894b8bccb88e870577f324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f38862b163d1a943b28dabfd39fc8ef" id="r_ga2f38862b163d1a943b28dabfd39fc8ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f38862b163d1a943b28dabfd39fc8ef">core_util_atomic_store_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue)</td></tr>
<tr class="separator:ga2f38862b163d1a943b28dabfd39fc8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad81d69ed6094e7cd6cfb1f3b729955fc" id="r_gad81d69ed6094e7cd6cfb1f3b729955fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad81d69ed6094e7cd6cfb1f3b729955fc">core_util_atomic_store_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gad81d69ed6094e7cd6cfb1f3b729955fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga981dd31a80f495369723280424a3999e" id="r_ga981dd31a80f495369723280424a3999e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga981dd31a80f495369723280424a3999e">core_util_atomic_store_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue)</td></tr>
<tr class="separator:ga981dd31a80f495369723280424a3999e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2960e2d63e4c37c93f202cbb597189a9" id="r_ga2960e2d63e4c37c93f202cbb597189a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2960e2d63e4c37c93f202cbb597189a9">core_util_atomic_store_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga2960e2d63e4c37c93f202cbb597189a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaffb39f69f9e80d787404bcdc627bd39" id="r_gaaffb39f69f9e80d787404bcdc627bd39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaffb39f69f9e80d787404bcdc627bd39">core_util_atomic_store_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue)</td></tr>
<tr class="separator:gaaffb39f69f9e80d787404bcdc627bd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54a248229f8606e148c9708c7237334" id="r_gad54a248229f8606e148c9708c7237334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad54a248229f8606e148c9708c7237334">core_util_atomic_store_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gad54a248229f8606e148c9708c7237334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2024d6b1bd77f35d0bd27b9abeaca252" id="r_ga2024d6b1bd77f35d0bd27b9abeaca252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2024d6b1bd77f35d0bd27b9abeaca252">core_util_atomic_store_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue)</td></tr>
<tr class="separator:ga2024d6b1bd77f35d0bd27b9abeaca252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361bc02b02df102a3f3ddf0ae84a9df0" id="r_ga361bc02b02df102a3f3ddf0ae84a9df0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga361bc02b02df102a3f3ddf0ae84a9df0">core_util_atomic_store_explicit_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga361bc02b02df102a3f3ddf0ae84a9df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae67ef75f813610e1bd3804b4cfa22565" id="r_gae67ef75f813610e1bd3804b4cfa22565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae67ef75f813610e1bd3804b4cfa22565">core_util_atomic_store_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue)</td></tr>
<tr class="separator:gae67ef75f813610e1bd3804b4cfa22565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd333e4cab3877d64f041e538cff66b" id="r_gaedd333e4cab3877d64f041e538cff66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaedd333e4cab3877d64f041e538cff66b">core_util_atomic_store_explicit_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaedd333e4cab3877d64f041e538cff66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d826b01dc7aae7c3a473c349f0ee32" id="r_ga63d826b01dc7aae7c3a473c349f0ee32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga63d826b01dc7aae7c3a473c349f0ee32">core_util_atomic_store_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue)</td></tr>
<tr class="separator:ga63d826b01dc7aae7c3a473c349f0ee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b27494dba292ef9caa12d164b7a1b9d" id="r_ga3b27494dba292ef9caa12d164b7a1b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b27494dba292ef9caa12d164b7a1b9d">core_util_atomic_store_explicit_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3b27494dba292ef9caa12d164b7a1b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15431b3da92b29949c1d597f425c7a07" id="r_ga15431b3da92b29949c1d597f425c7a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga15431b3da92b29949c1d597f425c7a07">core_util_atomic_store_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue)</td></tr>
<tr class="separator:ga15431b3da92b29949c1d597f425c7a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade28bd9fce9c1c0f448eab73cb00e460" id="r_gade28bd9fce9c1c0f448eab73cb00e460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gade28bd9fce9c1c0f448eab73cb00e460">core_util_atomic_store_explicit_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gade28bd9fce9c1c0f448eab73cb00e460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4692889cc8d1bd170af962728be04dc3" id="r_ga4692889cc8d1bd170af962728be04dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4692889cc8d1bd170af962728be04dc3">core_util_atomic_store_bool</a> (volatile bool *valuePtr, bool desiredValue)</td></tr>
<tr class="separator:ga4692889cc8d1bd170af962728be04dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ca948b9322559e941dd359400ae4fe" id="r_gab9ca948b9322559e941dd359400ae4fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab9ca948b9322559e941dd359400ae4fe">core_util_atomic_store_explicit_bool</a> (volatile bool *valuePtr, bool desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gab9ca948b9322559e941dd359400ae4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa112a4db89b94efa5f785035415f0d5a" id="r_gaa112a4db89b94efa5f785035415f0d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa112a4db89b94efa5f785035415f0d5a">core_util_atomic_store_ptr</a> (void *volatile *valuePtr, void *desiredValue)</td></tr>
<tr class="separator:gaa112a4db89b94efa5f785035415f0d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4ebe09fe2de1ddc6ce8151baefc991" id="r_gaca4ebe09fe2de1ddc6ce8151baefc991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaca4ebe09fe2de1ddc6ce8151baefc991">core_util_atomic_store_explicit_ptr</a> (void *volatile *valuePtr, void *desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaca4ebe09fe2de1ddc6ce8151baefc991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8eb68cac5919c4bcd5af6fedc197eb4" id="r_gad8eb68cac5919c4bcd5af6fedc197eb4"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad8eb68cac5919c4bcd5af6fedc197eb4">core_util_atomic_exchange_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue)</td></tr>
<tr class="separator:gad8eb68cac5919c4bcd5af6fedc197eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7780847ac95064b466ea04bad2a61a2" id="r_gac7780847ac95064b466ea04bad2a61a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac7780847ac95064b466ea04bad2a61a2">core_util_atomic_exchange_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gac7780847ac95064b466ea04bad2a61a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88aa3a0d0479d92b0b32e0a4a901d76e" id="r_ga88aa3a0d0479d92b0b32e0a4a901d76e"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga88aa3a0d0479d92b0b32e0a4a901d76e">core_util_atomic_exchange_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue)</td></tr>
<tr class="separator:ga88aa3a0d0479d92b0b32e0a4a901d76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09407fb1c3ba1c8518e09b75bc12c6e0" id="r_ga09407fb1c3ba1c8518e09b75bc12c6e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga09407fb1c3ba1c8518e09b75bc12c6e0">core_util_atomic_exchange_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga09407fb1c3ba1c8518e09b75bc12c6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc72c4b4e0f8ead04b946b6e281e75c" id="r_ga9fc72c4b4e0f8ead04b946b6e281e75c"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9fc72c4b4e0f8ead04b946b6e281e75c">core_util_atomic_exchange_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue)</td></tr>
<tr class="separator:ga9fc72c4b4e0f8ead04b946b6e281e75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd0876d934c04cf3d097d6048d5b94c" id="r_ga3cd0876d934c04cf3d097d6048d5b94c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3cd0876d934c04cf3d097d6048d5b94c">core_util_atomic_exchange_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3cd0876d934c04cf3d097d6048d5b94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a53ffc716df9594b56a94fca8ce5cf7" id="r_ga7a53ffc716df9594b56a94fca8ce5cf7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7a53ffc716df9594b56a94fca8ce5cf7">core_util_atomic_exchange_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue)</td></tr>
<tr class="separator:ga7a53ffc716df9594b56a94fca8ce5cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab492757a2fc1fdaed58f56877126fc85" id="r_gab492757a2fc1fdaed58f56877126fc85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab492757a2fc1fdaed58f56877126fc85">core_util_atomic_exchange_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gab492757a2fc1fdaed58f56877126fc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c915efbc7c77b3c72328783af87277d" id="r_ga9c915efbc7c77b3c72328783af87277d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9c915efbc7c77b3c72328783af87277d">core_util_atomic_exchange_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue)</td></tr>
<tr class="separator:ga9c915efbc7c77b3c72328783af87277d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32133579ae8ddda64548e209f85a282" id="r_gab32133579ae8ddda64548e209f85a282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab32133579ae8ddda64548e209f85a282">core_util_atomic_exchange_explicit_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gab32133579ae8ddda64548e209f85a282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02cc6c6d66a90be4b943dd02a682089" id="r_gad02cc6c6d66a90be4b943dd02a682089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad02cc6c6d66a90be4b943dd02a682089">core_util_atomic_exchange_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue)</td></tr>
<tr class="separator:gad02cc6c6d66a90be4b943dd02a682089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff86a2b74166999e50784676e624a9c" id="r_ga3ff86a2b74166999e50784676e624a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3ff86a2b74166999e50784676e624a9c">core_util_atomic_exchange_explicit_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3ff86a2b74166999e50784676e624a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5592ae0738feab92516d27d14c0921b" id="r_gaa5592ae0738feab92516d27d14c0921b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa5592ae0738feab92516d27d14c0921b">core_util_atomic_exchange_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue)</td></tr>
<tr class="separator:gaa5592ae0738feab92516d27d14c0921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf601f85ee6eff49b498bd02d5355b986" id="r_gaf601f85ee6eff49b498bd02d5355b986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf601f85ee6eff49b498bd02d5355b986">core_util_atomic_exchange_explicit_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaf601f85ee6eff49b498bd02d5355b986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac09a70a91d5b50e5e4d18af85f8224de" id="r_gac09a70a91d5b50e5e4d18af85f8224de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac09a70a91d5b50e5e4d18af85f8224de">core_util_atomic_exchange_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue)</td></tr>
<tr class="separator:gac09a70a91d5b50e5e4d18af85f8224de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a1020edbe4b1cfc98cb2470b228c07" id="r_ga44a1020edbe4b1cfc98cb2470b228c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga44a1020edbe4b1cfc98cb2470b228c07">core_util_atomic_exchange_explicit_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga44a1020edbe4b1cfc98cb2470b228c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga085fd843aab08f03815e6925b7b56e35" id="r_ga085fd843aab08f03815e6925b7b56e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga085fd843aab08f03815e6925b7b56e35">core_util_atomic_exchange_bool</a> (volatile bool *valuePtr, bool desiredValue)</td></tr>
<tr class="separator:ga085fd843aab08f03815e6925b7b56e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11616204b0007487d3607cfd0036e966" id="r_ga11616204b0007487d3607cfd0036e966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga11616204b0007487d3607cfd0036e966">core_util_atomic_exchange_explicit_bool</a> (volatile bool *valuePtr, bool desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga11616204b0007487d3607cfd0036e966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd245e89bb0303090ea1f880823ccde3" id="r_gadd245e89bb0303090ea1f880823ccde3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadd245e89bb0303090ea1f880823ccde3">core_util_atomic_exchange_ptr</a> (void *volatile *valuePtr, void *desiredValue)</td></tr>
<tr class="separator:gadd245e89bb0303090ea1f880823ccde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373b2f859a298cb11ef3186816033c33" id="r_ga373b2f859a298cb11ef3186816033c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga373b2f859a298cb11ef3186816033c33">core_util_atomic_exchange_explicit_ptr</a> (void *volatile *valuePtr, void *desiredValue, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga373b2f859a298cb11ef3186816033c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97639d48a80bb088d578407ec894de40" id="r_ga97639d48a80bb088d578407ec894de40"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga97639d48a80bb088d578407ec894de40">core_util_atomic_incr_u8</a> (volatile uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="separator:ga97639d48a80bb088d578407ec894de40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b09ba48b5d1998308d9652ab102a0dc" id="r_ga6b09ba48b5d1998308d9652ab102a0dc"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6b09ba48b5d1998308d9652ab102a0dc">core_util_atomic_incr_u16</a> (volatile uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="separator:ga6b09ba48b5d1998308d9652ab102a0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a097df540b0f9d73d01bde72f5d09af" id="r_ga9a097df540b0f9d73d01bde72f5d09af"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a097df540b0f9d73d01bde72f5d09af">core_util_atomic_incr_u32</a> (volatile uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="separator:ga9a097df540b0f9d73d01bde72f5d09af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da475be0bf8e7d9e7cd16177e3d13a5" id="r_ga1da475be0bf8e7d9e7cd16177e3d13a5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1da475be0bf8e7d9e7cd16177e3d13a5">core_util_atomic_incr_u64</a> (volatile uint64_t *valuePtr, uint64_t delta)</td></tr>
<tr class="separator:ga1da475be0bf8e7d9e7cd16177e3d13a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad991d615f9643f15f883e6c4638fe31e" id="r_gad991d615f9643f15f883e6c4638fe31e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad991d615f9643f15f883e6c4638fe31e">core_util_atomic_incr_s8</a> (volatile int8_t *valuePtr, int8_t delta)</td></tr>
<tr class="separator:gad991d615f9643f15f883e6c4638fe31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71073f46116c910e80c0c4c7409b995" id="r_gaf71073f46116c910e80c0c4c7409b995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf71073f46116c910e80c0c4c7409b995">core_util_atomic_incr_s16</a> (volatile int16_t *valuePtr, int16_t delta)</td></tr>
<tr class="separator:gaf71073f46116c910e80c0c4c7409b995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad1b7864af7323246bd38768aff11cf8" id="r_gaad1b7864af7323246bd38768aff11cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaad1b7864af7323246bd38768aff11cf8">core_util_atomic_incr_s32</a> (volatile int32_t *valuePtr, int32_t delta)</td></tr>
<tr class="separator:gaad1b7864af7323246bd38768aff11cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8058a48a1ddde0bfd1900f9fc789eca" id="r_gad8058a48a1ddde0bfd1900f9fc789eca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad8058a48a1ddde0bfd1900f9fc789eca">core_util_atomic_incr_s64</a> (volatile int64_t *valuePtr, int64_t delta)</td></tr>
<tr class="separator:gad8058a48a1ddde0bfd1900f9fc789eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552c51b9a90675e7f5c70d3769e2c5e8" id="r_ga552c51b9a90675e7f5c70d3769e2c5e8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga552c51b9a90675e7f5c70d3769e2c5e8">core_util_atomic_incr_ptr</a> (void *volatile *valuePtr, ptrdiff_t delta)</td></tr>
<tr class="separator:ga552c51b9a90675e7f5c70d3769e2c5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga507fee72a9e872e2bae67af997302186" id="r_ga507fee72a9e872e2bae67af997302186"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga507fee72a9e872e2bae67af997302186">core_util_atomic_decr_u8</a> (volatile uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="separator:ga507fee72a9e872e2bae67af997302186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d0e74d331981a1ce4280a7439a061e" id="r_gae0d0e74d331981a1ce4280a7439a061e"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0d0e74d331981a1ce4280a7439a061e">core_util_atomic_decr_u16</a> (volatile uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="separator:gae0d0e74d331981a1ce4280a7439a061e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f117fabc89892e77ff98ff24db78eab" id="r_ga1f117fabc89892e77ff98ff24db78eab"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1f117fabc89892e77ff98ff24db78eab">core_util_atomic_decr_u32</a> (volatile uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="separator:ga1f117fabc89892e77ff98ff24db78eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad40c29bee47dc525faefb7544cce2ac0" id="r_gad40c29bee47dc525faefb7544cce2ac0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad40c29bee47dc525faefb7544cce2ac0">core_util_atomic_decr_u64</a> (volatile uint64_t *valuePtr, uint64_t delta)</td></tr>
<tr class="separator:gad40c29bee47dc525faefb7544cce2ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb322baa1bd668947e5f0bfd3134283" id="r_gadeb322baa1bd668947e5f0bfd3134283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadeb322baa1bd668947e5f0bfd3134283">core_util_atomic_decr_s8</a> (volatile int8_t *valuePtr, int8_t delta)</td></tr>
<tr class="separator:gadeb322baa1bd668947e5f0bfd3134283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga752f3c2b1a007fb57340d827087c7acf" id="r_ga752f3c2b1a007fb57340d827087c7acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga752f3c2b1a007fb57340d827087c7acf">core_util_atomic_decr_s16</a> (volatile int16_t *valuePtr, int16_t delta)</td></tr>
<tr class="separator:ga752f3c2b1a007fb57340d827087c7acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ffa4563fded0662921120ec752c4e9" id="r_ga89ffa4563fded0662921120ec752c4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga89ffa4563fded0662921120ec752c4e9">core_util_atomic_decr_s32</a> (volatile int32_t *valuePtr, int32_t delta)</td></tr>
<tr class="separator:ga89ffa4563fded0662921120ec752c4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aded12e7bbd8250c0f9392617141829" id="r_ga1aded12e7bbd8250c0f9392617141829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1aded12e7bbd8250c0f9392617141829">core_util_atomic_decr_s64</a> (volatile int64_t *valuePtr, int64_t delta)</td></tr>
<tr class="separator:ga1aded12e7bbd8250c0f9392617141829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43270010ce23b14d180cac14b0070137" id="r_ga43270010ce23b14d180cac14b0070137"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga43270010ce23b14d180cac14b0070137">core_util_atomic_decr_ptr</a> (void *volatile *valuePtr, ptrdiff_t delta)</td></tr>
<tr class="separator:ga43270010ce23b14d180cac14b0070137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f569432de64b03b369c41e911f7013b" id="r_ga2f569432de64b03b369c41e911f7013b"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f569432de64b03b369c41e911f7013b">core_util_atomic_fetch_add_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="separator:ga2f569432de64b03b369c41e911f7013b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651ae50190ea63b037e38c1e3d058f62" id="r_ga651ae50190ea63b037e38c1e3d058f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga651ae50190ea63b037e38c1e3d058f62">core_util_atomic_fetch_add_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga651ae50190ea63b037e38c1e3d058f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3707ed5422ba9e5741b7fddd0530dc3" id="r_gac3707ed5422ba9e5741b7fddd0530dc3"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3707ed5422ba9e5741b7fddd0530dc3">core_util_atomic_fetch_add_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="separator:gac3707ed5422ba9e5741b7fddd0530dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1fe9a8547ec4ba9be99695c2d10688" id="r_ga9b1fe9a8547ec4ba9be99695c2d10688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9b1fe9a8547ec4ba9be99695c2d10688">core_util_atomic_fetch_add_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga9b1fe9a8547ec4ba9be99695c2d10688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f26fa5f6aa85ebc795336c8c4e805b5" id="r_ga3f26fa5f6aa85ebc795336c8c4e805b5"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f26fa5f6aa85ebc795336c8c4e805b5">core_util_atomic_fetch_add_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="separator:ga3f26fa5f6aa85ebc795336c8c4e805b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2cf84841529895574591de06da0a81" id="r_ga6e2cf84841529895574591de06da0a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6e2cf84841529895574591de06da0a81">core_util_atomic_fetch_add_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga6e2cf84841529895574591de06da0a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdbfedfdbdad88c8f18caf0a3212f9b" id="r_gaccdbfedfdbdad88c8f18caf0a3212f9b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaccdbfedfdbdad88c8f18caf0a3212f9b">core_util_atomic_fetch_add_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="separator:gaccdbfedfdbdad88c8f18caf0a3212f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a5a54967b6603caad8a7013b5603d4" id="r_ga52a5a54967b6603caad8a7013b5603d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga52a5a54967b6603caad8a7013b5603d4">core_util_atomic_fetch_add_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga52a5a54967b6603caad8a7013b5603d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab749485f59e3e2d83e62ee565aeca6f5" id="r_gab749485f59e3e2d83e62ee565aeca6f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab749485f59e3e2d83e62ee565aeca6f5">core_util_atomic_fetch_add_s8</a> (volatile int8_t *valuePtr, int8_t arg)</td></tr>
<tr class="separator:gab749485f59e3e2d83e62ee565aeca6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d95c74bb5c805196eb6f001704474e" id="r_gad4d95c74bb5c805196eb6f001704474e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad4d95c74bb5c805196eb6f001704474e">core_util_atomic_fetch_add_explicit_s8</a> (volatile int8_t *valuePtr, int8_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gad4d95c74bb5c805196eb6f001704474e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacb556c12ab10eb1bac2ce28d837415" id="r_gadacb556c12ab10eb1bac2ce28d837415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadacb556c12ab10eb1bac2ce28d837415">core_util_atomic_fetch_add_s16</a> (volatile int16_t *valuePtr, int16_t arg)</td></tr>
<tr class="separator:gadacb556c12ab10eb1bac2ce28d837415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec6975ddf7e77d74ade6d5157b89224" id="r_gaeec6975ddf7e77d74ade6d5157b89224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeec6975ddf7e77d74ade6d5157b89224">core_util_atomic_fetch_add_explicit_s16</a> (volatile int16_t *valuePtr, int16_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaeec6975ddf7e77d74ade6d5157b89224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce4cf4be0c038e724bc5be4d03d9026" id="r_ga5ce4cf4be0c038e724bc5be4d03d9026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ce4cf4be0c038e724bc5be4d03d9026">core_util_atomic_fetch_add_s32</a> (volatile int32_t *valuePtr, int32_t arg)</td></tr>
<tr class="separator:ga5ce4cf4be0c038e724bc5be4d03d9026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e312ade8a7e075e99b146628909800c" id="r_ga7e312ade8a7e075e99b146628909800c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7e312ade8a7e075e99b146628909800c">core_util_atomic_fetch_add_explicit_s32</a> (volatile int32_t *valuePtr, int32_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga7e312ade8a7e075e99b146628909800c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71166f17a0453072cb2a53c9b2c70b50" id="r_ga71166f17a0453072cb2a53c9b2c70b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga71166f17a0453072cb2a53c9b2c70b50">core_util_atomic_fetch_add_s64</a> (volatile int64_t *valuePtr, int64_t arg)</td></tr>
<tr class="separator:ga71166f17a0453072cb2a53c9b2c70b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529c15151f84f8d992f0b7b73b89114c" id="r_ga529c15151f84f8d992f0b7b73b89114c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga529c15151f84f8d992f0b7b73b89114c">core_util_atomic_fetch_add_explicit_s64</a> (volatile int64_t *valuePtr, int64_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga529c15151f84f8d992f0b7b73b89114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b970ad6426c9488eacff7a8b60f7c9a" id="r_ga1b970ad6426c9488eacff7a8b60f7c9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b970ad6426c9488eacff7a8b60f7c9a">core_util_atomic_fetch_add_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg)</td></tr>
<tr class="separator:ga1b970ad6426c9488eacff7a8b60f7c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612c1b23f221aaeb1ea9eec37c9e0924" id="r_ga612c1b23f221aaeb1ea9eec37c9e0924"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga612c1b23f221aaeb1ea9eec37c9e0924">core_util_atomic_fetch_add_explicit_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga612c1b23f221aaeb1ea9eec37c9e0924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32bf21c75f714c837dac8baa9e55eb6d" id="r_ga32bf21c75f714c837dac8baa9e55eb6d"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga32bf21c75f714c837dac8baa9e55eb6d">core_util_atomic_fetch_sub_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="separator:ga32bf21c75f714c837dac8baa9e55eb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cdf17854e749a41ffb1ef1c9391ccb1" id="r_ga0cdf17854e749a41ffb1ef1c9391ccb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0cdf17854e749a41ffb1ef1c9391ccb1">core_util_atomic_fetch_sub_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga0cdf17854e749a41ffb1ef1c9391ccb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3d5a4f47e55bb26db95d0cc82d5120" id="r_ga9f3d5a4f47e55bb26db95d0cc82d5120"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9f3d5a4f47e55bb26db95d0cc82d5120">core_util_atomic_fetch_sub_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="separator:ga9f3d5a4f47e55bb26db95d0cc82d5120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef713cf9e4b240fc9333ae986a64f3ad" id="r_gaef713cf9e4b240fc9333ae986a64f3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaef713cf9e4b240fc9333ae986a64f3ad">core_util_atomic_fetch_sub_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaef713cf9e4b240fc9333ae986a64f3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf936945ebc2a75d628bf979d587af28e" id="r_gaf936945ebc2a75d628bf979d587af28e"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf936945ebc2a75d628bf979d587af28e">core_util_atomic_fetch_sub_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="separator:gaf936945ebc2a75d628bf979d587af28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a744e93eda19b361077c2d283f69c11" id="r_ga6a744e93eda19b361077c2d283f69c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6a744e93eda19b361077c2d283f69c11">core_util_atomic_fetch_sub_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga6a744e93eda19b361077c2d283f69c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f7d9554d99b226c04021bf058809e9" id="r_ga63f7d9554d99b226c04021bf058809e9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga63f7d9554d99b226c04021bf058809e9">core_util_atomic_fetch_sub_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="separator:ga63f7d9554d99b226c04021bf058809e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71e00325c1ca7d78bfec53182c972a1" id="r_gaf71e00325c1ca7d78bfec53182c972a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf71e00325c1ca7d78bfec53182c972a1">core_util_atomic_fetch_sub_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaf71e00325c1ca7d78bfec53182c972a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b868ca82165d3e1e86ff8cb3cc45878" id="r_ga9b868ca82165d3e1e86ff8cb3cc45878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9b868ca82165d3e1e86ff8cb3cc45878">core_util_atomic_fetch_sub_s8</a> (volatile int8_t *valuePtr, int8_t arg)</td></tr>
<tr class="separator:ga9b868ca82165d3e1e86ff8cb3cc45878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7d33c43f941840f436513972cffdf1" id="r_gafc7d33c43f941840f436513972cffdf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafc7d33c43f941840f436513972cffdf1">core_util_atomic_fetch_sub_explicit_s8</a> (volatile int8_t *valuePtr, int8_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gafc7d33c43f941840f436513972cffdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1f99cad729bd49aa63c570a968a489" id="r_ga1b1f99cad729bd49aa63c570a968a489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b1f99cad729bd49aa63c570a968a489">core_util_atomic_fetch_sub_s16</a> (volatile int16_t *valuePtr, int16_t arg)</td></tr>
<tr class="separator:ga1b1f99cad729bd49aa63c570a968a489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3198e21d50306edeca33e63eb6121613" id="r_ga3198e21d50306edeca33e63eb6121613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3198e21d50306edeca33e63eb6121613">core_util_atomic_fetch_sub_explicit_s16</a> (volatile int16_t *valuePtr, int16_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3198e21d50306edeca33e63eb6121613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8dce75d68ca82cb52baeb761d6abee3" id="r_gaf8dce75d68ca82cb52baeb761d6abee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf8dce75d68ca82cb52baeb761d6abee3">core_util_atomic_fetch_sub_s32</a> (volatile int32_t *valuePtr, int32_t arg)</td></tr>
<tr class="separator:gaf8dce75d68ca82cb52baeb761d6abee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038e3bea482bb48b4d2cec13a568c382" id="r_ga038e3bea482bb48b4d2cec13a568c382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga038e3bea482bb48b4d2cec13a568c382">core_util_atomic_fetch_sub_explicit_s32</a> (volatile int32_t *valuePtr, int32_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga038e3bea482bb48b4d2cec13a568c382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf4f676b1bf6a95e8fd98fd02fe63d" id="r_ga17bf4f676b1bf6a95e8fd98fd02fe63d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga17bf4f676b1bf6a95e8fd98fd02fe63d">core_util_atomic_fetch_sub_s64</a> (volatile int64_t *valuePtr, int64_t arg)</td></tr>
<tr class="separator:ga17bf4f676b1bf6a95e8fd98fd02fe63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644d915b39e49bf2d83f44d3b5762927" id="r_ga644d915b39e49bf2d83f44d3b5762927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga644d915b39e49bf2d83f44d3b5762927">core_util_atomic_fetch_sub_explicit_s64</a> (volatile int64_t *valuePtr, int64_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga644d915b39e49bf2d83f44d3b5762927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga693d6b9a52e7334f01b6893d132cecb1" id="r_ga693d6b9a52e7334f01b6893d132cecb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga693d6b9a52e7334f01b6893d132cecb1">core_util_atomic_fetch_sub_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg)</td></tr>
<tr class="separator:ga693d6b9a52e7334f01b6893d132cecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga096af7149a60b608b9c528530d61a232" id="r_ga096af7149a60b608b9c528530d61a232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga096af7149a60b608b9c528530d61a232">core_util_atomic_fetch_sub_explicit_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga096af7149a60b608b9c528530d61a232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c8a0d06e0106275397f533d22dee91" id="r_gae6c8a0d06e0106275397f533d22dee91"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae6c8a0d06e0106275397f533d22dee91">core_util_atomic_fetch_and_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="separator:gae6c8a0d06e0106275397f533d22dee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118df0bb30ca68d2be8c084be472289b" id="r_ga118df0bb30ca68d2be8c084be472289b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga118df0bb30ca68d2be8c084be472289b">core_util_atomic_fetch_and_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga118df0bb30ca68d2be8c084be472289b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e66326fd7f787dbfe46e64662160b4" id="r_ga34e66326fd7f787dbfe46e64662160b4"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga34e66326fd7f787dbfe46e64662160b4">core_util_atomic_fetch_and_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="separator:ga34e66326fd7f787dbfe46e64662160b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2f48d1bb656d61c0dc92f255c6f21a" id="r_gaeb2f48d1bb656d61c0dc92f255c6f21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb2f48d1bb656d61c0dc92f255c6f21a">core_util_atomic_fetch_and_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaeb2f48d1bb656d61c0dc92f255c6f21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ff2cb2140b2c447d4af4da3d26a983" id="r_ga25ff2cb2140b2c447d4af4da3d26a983"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga25ff2cb2140b2c447d4af4da3d26a983">core_util_atomic_fetch_and_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="separator:ga25ff2cb2140b2c447d4af4da3d26a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6169b1a76622a0260d8ce24f2a27a071" id="r_ga6169b1a76622a0260d8ce24f2a27a071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6169b1a76622a0260d8ce24f2a27a071">core_util_atomic_fetch_and_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga6169b1a76622a0260d8ce24f2a27a071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9ca48255c2fb18551881f37b86f004" id="r_gacf9ca48255c2fb18551881f37b86f004"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacf9ca48255c2fb18551881f37b86f004">core_util_atomic_fetch_and_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="separator:gacf9ca48255c2fb18551881f37b86f004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2969415714af3a77fbb565e78328a4f" id="r_gac2969415714af3a77fbb565e78328a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac2969415714af3a77fbb565e78328a4f">core_util_atomic_fetch_and_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gac2969415714af3a77fbb565e78328a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1d4c46bdffd018dd1f8e06e8049a978" id="r_gae1d4c46bdffd018dd1f8e06e8049a978"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae1d4c46bdffd018dd1f8e06e8049a978">core_util_atomic_fetch_or_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="separator:gae1d4c46bdffd018dd1f8e06e8049a978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a483c3c606c7a95e539c269937b3fa" id="r_ga19a483c3c606c7a95e539c269937b3fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga19a483c3c606c7a95e539c269937b3fa">core_util_atomic_fetch_or_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga19a483c3c606c7a95e539c269937b3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee96da40990d243bb1f2afa44e20d32" id="r_gadee96da40990d243bb1f2afa44e20d32"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadee96da40990d243bb1f2afa44e20d32">core_util_atomic_fetch_or_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="separator:gadee96da40990d243bb1f2afa44e20d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa1ebeb601da04d37d5e7170e52505d" id="r_gaffa1ebeb601da04d37d5e7170e52505d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaffa1ebeb601da04d37d5e7170e52505d">core_util_atomic_fetch_or_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaffa1ebeb601da04d37d5e7170e52505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65c93e9a7b8b173fc03c022037d95a9b" id="r_ga65c93e9a7b8b173fc03c022037d95a9b"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga65c93e9a7b8b173fc03c022037d95a9b">core_util_atomic_fetch_or_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="separator:ga65c93e9a7b8b173fc03c022037d95a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987adeb2ae9c2db2551a61aa4b426df2" id="r_ga987adeb2ae9c2db2551a61aa4b426df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga987adeb2ae9c2db2551a61aa4b426df2">core_util_atomic_fetch_or_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga987adeb2ae9c2db2551a61aa4b426df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8c5f724d821fa01783eeb9f9b6654bc" id="r_gaa8c5f724d821fa01783eeb9f9b6654bc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8c5f724d821fa01783eeb9f9b6654bc">core_util_atomic_fetch_or_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="separator:gaa8c5f724d821fa01783eeb9f9b6654bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7733cc83af1260afd5484d9f8ab64a52" id="r_ga7733cc83af1260afd5484d9f8ab64a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7733cc83af1260afd5484d9f8ab64a52">core_util_atomic_fetch_or_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga7733cc83af1260afd5484d9f8ab64a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3509db0dc730a9ad7b3009ed0a83059d" id="r_ga3509db0dc730a9ad7b3009ed0a83059d"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3509db0dc730a9ad7b3009ed0a83059d">core_util_atomic_fetch_xor_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="separator:ga3509db0dc730a9ad7b3009ed0a83059d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f687c46f29f48b760123770f9cf30f8" id="r_ga7f687c46f29f48b760123770f9cf30f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f687c46f29f48b760123770f9cf30f8">core_util_atomic_fetch_xor_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga7f687c46f29f48b760123770f9cf30f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7172411bd4b7fa44777dd7f945af81" id="r_ga7f7172411bd4b7fa44777dd7f945af81"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f7172411bd4b7fa44777dd7f945af81">core_util_atomic_fetch_xor_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="separator:ga7f7172411bd4b7fa44777dd7f945af81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cac1f70d86145102d3bf1ceaaed4b54" id="r_ga0cac1f70d86145102d3bf1ceaaed4b54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0cac1f70d86145102d3bf1ceaaed4b54">core_util_atomic_fetch_xor_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga0cac1f70d86145102d3bf1ceaaed4b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab471f077a79eadf1a398464ab72e1016" id="r_gab471f077a79eadf1a398464ab72e1016"><td class="memItemLeft" align="right" valign="top">MBED_INLINE_IF_EX uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab471f077a79eadf1a398464ab72e1016">core_util_atomic_fetch_xor_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="separator:gab471f077a79eadf1a398464ab72e1016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cf9e78a72b5ed55edcb09240af4e187" id="r_ga7cf9e78a72b5ed55edcb09240af4e187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7cf9e78a72b5ed55edcb09240af4e187">core_util_atomic_fetch_xor_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga7cf9e78a72b5ed55edcb09240af4e187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b70c15733c776dbcae1a7ee5c056201" id="r_ga6b70c15733c776dbcae1a7ee5c056201"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6b70c15733c776dbcae1a7ee5c056201">core_util_atomic_fetch_xor_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="separator:ga6b70c15733c776dbcae1a7ee5c056201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cda9f9445bbace6d20e5ae02bc4a6e8" id="r_ga3cda9f9445bbace6d20e5ae02bc4a6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3cda9f9445bbace6d20e5ae02bc4a6e8">core_util_atomic_fetch_xor_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3cda9f9445bbace6d20e5ae02bc4a6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Atomic functions function analogously to C11 and C++11 - loads have acquire semantics, stores have release semantics, and atomic operations are sequentially consistent. Atomicity is enforced both between threads and interrupt handlers. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa8f56a572a9d71e864311c431ee1131a" name="gaa8f56a572a9d71e864311c431ee1131a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f56a572a9d71e864311c431ee1131a">&#9670;&#160;</a></span>CORE_UTIL_ATOMIC_FLAG_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CORE_UTIL_ATOMIC_FLAG_INIT&#160;&#160;&#160;{ 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer for a <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> in_progress = <a class="code hl_define" href="#gaa8f56a572a9d71e864311c431ee1131a">CORE_UTIL_ATOMIC_FLAG_INIT</a>;</div>
<div class="ttc" id="agroup__platform__atomic_html_gaa8f56a572a9d71e864311c431ee1131a"><div class="ttname"><a href="#gaa8f56a572a9d71e864311c431ee1131a">CORE_UTIL_ATOMIC_FLAG_INIT</a></div><div class="ttdeci">#define CORE_UTIL_ATOMIC_FLAG_INIT</div><div class="ttdef"><b>Definition</b> mbed_atomic.h:130</div></div>
<div class="ttc" id="astructcore__util__atomic__flag_html"><div class="ttname"><a href="structcore__util__atomic__flag.html">core_util_atomic_flag</a></div><div class="ttdef"><b>Definition</b> mbed_atomic.h:118</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab09a83ac4701fab4cec225b2dd08b7a8" name="gab09a83ac4701fab4cec225b2dd08b7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab09a83ac4701fab4cec225b2dd08b7a8">&#9670;&#160;</a></span>core_util_atomic_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct core_util_atomic_flag core_util_atomic_flag</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A lock-free, primitive atomic flag.</p>
<p>Emulate C11's atomic_flag. The flag is initially in an indeterminate state unless explicitly initialized with CORE_UTIL_ATOMIC_FLAG_INIT. </p>

</div>
</div>
<a id="gaf76273ffa0f2b491126baf28ba1af025" name="gaf76273ffa0f2b491126baf28ba1af025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf76273ffa0f2b491126baf28ba1af025">&#9670;&#160;</a></span>mbed_memory_order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory order constraints for atomic operations. Intended semantics are as per C++11. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa770b34054b2e54c6bcbd0e9423ecd88" name="gaa770b34054b2e54c6bcbd0e9423ecd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa770b34054b2e54c6bcbd0e9423ecd88">&#9670;&#160;</a></span>mbed_memory_order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory order constraints for atomic operations. Intended semantics are as per C++11. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacbf62e56b6923b86006b8f04c57b62e2" name="gacbf62e56b6923b86006b8f04c57b62e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbf62e56b6923b86006b8f04c57b62e2">&#9670;&#160;</a></span>core_util_atomic_cas_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>

</div>
</div>
<a id="ga5e8c63fcd66c95d8bf4b29d3bc3745bb" name="ga5e8c63fcd66c95d8bf4b29d3bc3745bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e8c63fcd66c95d8bf4b29d3bc3745bb">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c3370fd30e8d1721807aad74a7a4f44" name="ga1c3370fd30e8d1721807aad74a7a4f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c3370fd30e8d1721807aad74a7a4f44">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf63939b06da44cb49a313698053aeb5" name="gacf63939b06da44cb49a313698053aeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf63939b06da44cb49a313698053aeb5">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab572aa9bd7e1ded44f7e6adafb7fe13a" name="gab572aa9bd7e1ded44f7e6adafb7fe13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab572aa9bd7e1ded44f7e6adafb7fe13a">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad69a97a89c2881c8a9584602e087729e" name="gad69a97a89c2881c8a9584602e087729e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad69a97a89c2881c8a9584602e087729e">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad741471e0981d7dd88e15b7e285d3eb0" name="gad741471e0981d7dd88e15b7e285d3eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad741471e0981d7dd88e15b7e285d3eb0">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae923f73dccaad3e5bca9ce02ce47fbe" name="gaae923f73dccaad3e5bca9ce02ce47fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae923f73dccaad3e5bca9ce02ce47fbe">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87b4b2754592e31420d1f2b38593b8d7" name="ga87b4b2754592e31420d1f2b38593b8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b4b2754592e31420d1f2b38593b8d7">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83dc3029317f487bfef8c984ee92cb06" name="ga83dc3029317f487bfef8c984ee92cb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83dc3029317f487bfef8c984ee92cb06">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93c9313f1a6be27bed9a3becfde0bee7" name="ga93c9313f1a6be27bed9a3becfde0bee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c9313f1a6be27bed9a3becfde0bee7">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9e9cbb15b6cae6154a5f85b483e9358" name="gaf9e9cbb15b6cae6154a5f85b483e9358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9e9cbb15b6cae6154a5f85b483e9358">&#9670;&#160;</a></span>core_util_atomic_cas_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>

</div>
</div>
<a id="ga05d84165af1254189e8c61166ce6b1ff" name="ga05d84165af1254189e8c61166ce6b1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d84165af1254189e8c61166ce6b1ff">&#9670;&#160;</a></span>core_util_atomic_cas_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>

</div>
</div>
<a id="ga205688ff94fc52b0652c9399d38ed875" name="ga205688ff94fc52b0652c9399d38ed875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga205688ff94fc52b0652c9399d38ed875">&#9670;&#160;</a></span>core_util_atomic_cas_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>

</div>
</div>
<a id="ga6eaa833099480b1cd7f87bb06d93da2d" name="ga6eaa833099480b1cd7f87bb06d93da2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eaa833099480b1cd7f87bb06d93da2d">&#9670;&#160;</a></span>core_util_atomic_cas_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>

</div>
</div>
<a id="ga45910fe69f1d67e6f85654e6b137ad3c" name="ga45910fe69f1d67e6f85654e6b137ad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45910fe69f1d67e6f85654e6b137ad3c">&#9670;&#160;</a></span>core_util_atomic_cas_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>

</div>
</div>
<a id="ga5f7fc357ed0e0d9297584ffd5352d1d4" name="ga5f7fc357ed0e0d9297584ffd5352d1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f7fc357ed0e0d9297584ffd5352d1d4">&#9670;&#160;</a></span>core_util_atomic_cas_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX bool core_util_atomic_cas_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>

</div>
</div>
<a id="ga4cc5125cdcb932f43d5b8ae36e8e1d2b" name="ga4cc5125cdcb932f43d5b8ae36e8e1d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cc5125cdcb932f43d5b8ae36e8e1d2b">&#9670;&#160;</a></span>core_util_atomic_cas_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX bool core_util_atomic_cas_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>

</div>
</div>
<a id="ga85dd9c14f13cf180e6ecdaea8da6fe11" name="ga85dd9c14f13cf180e6ecdaea8da6fe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85dd9c14f13cf180e6ecdaea8da6fe11">&#9670;&#160;</a></span>core_util_atomic_cas_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.    </dd></dl>

</div>
</div>
<a id="ga767b5eaddcdd294e69bc455f61f8db5b" name="ga767b5eaddcdd294e69bc455f61f8db5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga767b5eaddcdd294e69bc455f61f8db5b">&#9670;&#160;</a></span>core_util_atomic_cas_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX bool core_util_atomic_cas_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p>However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

</div>
</div>
<a id="gab1d769b78dbd7f22cbb904d7b768ca45" name="gab1d769b78dbd7f22cbb904d7b768ca45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1d769b78dbd7f22cbb904d7b768ca45">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>

</div>
</div>
<a id="gadeec7abf1f4deb39287ae36d53e543b4" name="gadeec7abf1f4deb39287ae36d53e543b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeec7abf1f4deb39287ae36d53e543b4">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ad9cc64f6c880a1608a120f41c8ffbb" name="ga0ad9cc64f6c880a1608a120f41c8ffbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad9cc64f6c880a1608a120f41c8ffbb">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22e345fb761331b2883c063bc6505892" name="ga22e345fb761331b2883c063bc6505892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22e345fb761331b2883c063bc6505892">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad7686b4293e7ea7bf4950dd5db438c3d" name="gad7686b4293e7ea7bf4950dd5db438c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7686b4293e7ea7bf4950dd5db438c3d">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae818c803e9b789a9155f2582957284cc" name="gae818c803e9b789a9155f2582957284cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae818c803e9b789a9155f2582957284cc">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cdb3fd8dfde2fc0b1da38000982bda5" name="ga6cdb3fd8dfde2fc0b1da38000982bda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cdb3fd8dfde2fc0b1da38000982bda5">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5739219816da159aeaae5096ac4f074d" name="ga5739219816da159aeaae5096ac4f074d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5739219816da159aeaae5096ac4f074d">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafcc40dbc99cecfa5bac04ebd65c9c0a5" name="gafcc40dbc99cecfa5bac04ebd65c9c0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcc40dbc99cecfa5bac04ebd65c9c0a5">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb1873cce70f0814a2e65d2bcee84d74" name="gabb1873cce70f0814a2e65d2bcee84d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb1873cce70f0814a2e65d2bcee84d74">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ea57a2b4c9d2958d6d4b9d981db3f63" name="ga8ea57a2b4c9d2958d6d4b9d981db3f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ea57a2b4c9d2958d6d4b9d981db3f63">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>success</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>failure</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1778c0381b19ace75e5228c4be8448d" name="gaf1778c0381b19ace75e5228c4be8448d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1778c0381b19ace75e5228c4be8448d">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>

</div>
</div>
<a id="ga03b36d178f7b14331ac054ee7de7826e" name="ga03b36d178f7b14331ac054ee7de7826e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03b36d178f7b14331ac054ee7de7826e">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>

</div>
</div>
<a id="gaeaf10dda44c9c989072495022edae918" name="gaeaf10dda44c9c989072495022edae918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaf10dda44c9c989072495022edae918">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>

</div>
</div>
<a id="ga86d26060ebf45bc519c5e769b369977a" name="ga86d26060ebf45bc519c5e769b369977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d26060ebf45bc519c5e769b369977a">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>

</div>
</div>
<a id="gad18413a098f190ede59e9a7dd817480f" name="gad18413a098f190ede59e9a7dd817480f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad18413a098f190ede59e9a7dd817480f">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>

</div>
</div>
<a id="ga5f9d09cc36f37bc162dd27c32d07148e" name="ga5f9d09cc36f37bc162dd27c32d07148e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f9d09cc36f37bc162dd27c32d07148e">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX bool core_util_atomic_compare_exchange_weak_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>

</div>
</div>
<a id="gaec41265a1c29e428d75bef02360fc402" name="gaec41265a1c29e428d75bef02360fc402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec41265a1c29e428d75bef02360fc402">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX bool core_util_atomic_compare_exchange_weak_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>

</div>
</div>
<a id="gaadaa71b8ed5127cb9591fed2cd524b1e" name="gaadaa71b8ed5127cb9591fed2cd524b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadaa71b8ed5127cb9591fed2cd524b1e">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.    </dd></dl>

</div>
</div>
<a id="ga75916cac3d2ca9f9b3d502f8131dcbd2" name="ga75916cac3d2ca9f9b3d502f8131dcbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75916cac3d2ca9f9b3d502f8131dcbd2">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX bool core_util_atomic_compare_exchange_weak_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>expectedCurrentValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p>Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

</div>
</div>
<a id="ga43270010ce23b14d180cac14b0070137" name="ga43270010ce23b14d180cac14b0070137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43270010ce23b14d180cac14b0070137">&#9670;&#160;</a></span>core_util_atomic_decr_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_decr_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.    </dd></dl>

</div>
</div>
<a id="ga752f3c2b1a007fb57340d827087c7acf" name="ga752f3c2b1a007fb57340d827087c7acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga752f3c2b1a007fb57340d827087c7acf">&#9670;&#160;</a></span>core_util_atomic_decr_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_decr_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.    </dd></dl>

</div>
</div>
<a id="ga89ffa4563fded0662921120ec752c4e9" name="ga89ffa4563fded0662921120ec752c4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89ffa4563fded0662921120ec752c4e9">&#9670;&#160;</a></span>core_util_atomic_decr_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_decr_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.    </dd></dl>

</div>
</div>
<a id="ga1aded12e7bbd8250c0f9392617141829" name="ga1aded12e7bbd8250c0f9392617141829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aded12e7bbd8250c0f9392617141829">&#9670;&#160;</a></span>core_util_atomic_decr_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_decr_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.    </dd></dl>

</div>
</div>
<a id="gadeb322baa1bd668947e5f0bfd3134283" name="gadeb322baa1bd668947e5f0bfd3134283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeb322baa1bd668947e5f0bfd3134283">&#9670;&#160;</a></span>core_util_atomic_decr_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_decr_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.    </dd></dl>

</div>
</div>
<a id="gae0d0e74d331981a1ce4280a7439a061e" name="gae0d0e74d331981a1ce4280a7439a061e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d0e74d331981a1ce4280a7439a061e">&#9670;&#160;</a></span>core_util_atomic_decr_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint16_t core_util_atomic_decr_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.    </dd></dl>

</div>
</div>
<a id="ga1f117fabc89892e77ff98ff24db78eab" name="ga1f117fabc89892e77ff98ff24db78eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f117fabc89892e77ff98ff24db78eab">&#9670;&#160;</a></span>core_util_atomic_decr_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint32_t core_util_atomic_decr_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.    </dd></dl>

</div>
</div>
<a id="gad40c29bee47dc525faefb7544cce2ac0" name="gad40c29bee47dc525faefb7544cce2ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad40c29bee47dc525faefb7544cce2ac0">&#9670;&#160;</a></span>core_util_atomic_decr_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_decr_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.    </dd></dl>

</div>
</div>
<a id="ga507fee72a9e872e2bae67af997302186" name="ga507fee72a9e872e2bae67af997302186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga507fee72a9e872e2bae67af997302186">&#9670;&#160;</a></span>core_util_atomic_decr_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint8_t core_util_atomic_decr_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a id="ga085fd843aab08f03815e6925b7b56e35" name="ga085fd843aab08f03815e6925b7b56e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga085fd843aab08f03815e6925b7b56e35">&#9670;&#160;</a></span>core_util_atomic_exchange_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_exchange_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>

</div>
</div>
<a id="ga11616204b0007487d3607cfd0036e966" name="ga11616204b0007487d3607cfd0036e966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11616204b0007487d3607cfd0036e966">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_exchange_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga373b2f859a298cb11ef3186816033c33" name="ga373b2f859a298cb11ef3186816033c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373b2f859a298cb11ef3186816033c33">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_exchange_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ff86a2b74166999e50784676e624a9c" name="ga3ff86a2b74166999e50784676e624a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ff86a2b74166999e50784676e624a9c">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_exchange_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf601f85ee6eff49b498bd02d5355b986" name="gaf601f85ee6eff49b498bd02d5355b986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf601f85ee6eff49b498bd02d5355b986">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_exchange_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44a1020edbe4b1cfc98cb2470b228c07" name="ga44a1020edbe4b1cfc98cb2470b228c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44a1020edbe4b1cfc98cb2470b228c07">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_exchange_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab32133579ae8ddda64548e209f85a282" name="gab32133579ae8ddda64548e209f85a282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab32133579ae8ddda64548e209f85a282">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_exchange_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09407fb1c3ba1c8518e09b75bc12c6e0" name="ga09407fb1c3ba1c8518e09b75bc12c6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09407fb1c3ba1c8518e09b75bc12c6e0">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_exchange_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3cd0876d934c04cf3d097d6048d5b94c" name="ga3cd0876d934c04cf3d097d6048d5b94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd0876d934c04cf3d097d6048d5b94c">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_exchange_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab492757a2fc1fdaed58f56877126fc85" name="gab492757a2fc1fdaed58f56877126fc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab492757a2fc1fdaed58f56877126fc85">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_exchange_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac7780847ac95064b466ea04bad2a61a2" name="gac7780847ac95064b466ea04bad2a61a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7780847ac95064b466ea04bad2a61a2">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_exchange_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd245e89bb0303090ea1f880823ccde3" name="gadd245e89bb0303090ea1f880823ccde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd245e89bb0303090ea1f880823ccde3">&#9670;&#160;</a></span>core_util_atomic_exchange_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_exchange_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>

</div>
</div>
<a id="gad02cc6c6d66a90be4b943dd02a682089" name="gad02cc6c6d66a90be4b943dd02a682089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad02cc6c6d66a90be4b943dd02a682089">&#9670;&#160;</a></span>core_util_atomic_exchange_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_exchange_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>

</div>
</div>
<a id="gaa5592ae0738feab92516d27d14c0921b" name="gaa5592ae0738feab92516d27d14c0921b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5592ae0738feab92516d27d14c0921b">&#9670;&#160;</a></span>core_util_atomic_exchange_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_exchange_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>

</div>
</div>
<a id="gac09a70a91d5b50e5e4d18af85f8224de" name="gac09a70a91d5b50e5e4d18af85f8224de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac09a70a91d5b50e5e4d18af85f8224de">&#9670;&#160;</a></span>core_util_atomic_exchange_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_exchange_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>

</div>
</div>
<a id="ga9c915efbc7c77b3c72328783af87277d" name="ga9c915efbc7c77b3c72328783af87277d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c915efbc7c77b3c72328783af87277d">&#9670;&#160;</a></span>core_util_atomic_exchange_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_exchange_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>

</div>
</div>
<a id="ga88aa3a0d0479d92b0b32e0a4a901d76e" name="ga88aa3a0d0479d92b0b32e0a4a901d76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88aa3a0d0479d92b0b32e0a4a901d76e">&#9670;&#160;</a></span>core_util_atomic_exchange_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint16_t core_util_atomic_exchange_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>

</div>
</div>
<a id="ga9fc72c4b4e0f8ead04b946b6e281e75c" name="ga9fc72c4b4e0f8ead04b946b6e281e75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fc72c4b4e0f8ead04b946b6e281e75c">&#9670;&#160;</a></span>core_util_atomic_exchange_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint32_t core_util_atomic_exchange_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>

</div>
</div>
<a id="ga7a53ffc716df9594b56a94fca8ce5cf7" name="ga7a53ffc716df9594b56a94fca8ce5cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a53ffc716df9594b56a94fca8ce5cf7">&#9670;&#160;</a></span>core_util_atomic_exchange_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_exchange_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.    </dd></dl>

</div>
</div>
<a id="gad8eb68cac5919c4bcd5af6fedc197eb4" name="gad8eb68cac5919c4bcd5af6fedc197eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8eb68cac5919c4bcd5af6fedc197eb4">&#9670;&#160;</a></span>core_util_atomic_exchange_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint8_t core_util_atomic_exchange_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic exchange. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

</div>
</div>
<a id="ga612c1b23f221aaeb1ea9eec37c9e0924" name="ga612c1b23f221aaeb1ea9eec37c9e0924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga612c1b23f221aaeb1ea9eec37c9e0924">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_fetch_add_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeec6975ddf7e77d74ade6d5157b89224" name="gaeec6975ddf7e77d74ade6d5157b89224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeec6975ddf7e77d74ade6d5157b89224">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_add_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e312ade8a7e075e99b146628909800c" name="ga7e312ade8a7e075e99b146628909800c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e312ade8a7e075e99b146628909800c">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_add_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga529c15151f84f8d992f0b7b73b89114c" name="ga529c15151f84f8d992f0b7b73b89114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga529c15151f84f8d992f0b7b73b89114c">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_add_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4d95c74bb5c805196eb6f001704474e" name="gad4d95c74bb5c805196eb6f001704474e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d95c74bb5c805196eb6f001704474e">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_add_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b1fe9a8547ec4ba9be99695c2d10688" name="ga9b1fe9a8547ec4ba9be99695c2d10688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b1fe9a8547ec4ba9be99695c2d10688">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_add_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e2cf84841529895574591de06da0a81" name="ga6e2cf84841529895574591de06da0a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e2cf84841529895574591de06da0a81">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_add_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga52a5a54967b6603caad8a7013b5603d4" name="ga52a5a54967b6603caad8a7013b5603d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a5a54967b6603caad8a7013b5603d4">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_add_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga651ae50190ea63b037e38c1e3d058f62" name="ga651ae50190ea63b037e38c1e3d058f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga651ae50190ea63b037e38c1e3d058f62">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_add_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b970ad6426c9488eacff7a8b60f7c9a" name="ga1b970ad6426c9488eacff7a8b60f7c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b970ad6426c9488eacff7a8b60f7c9a">&#9670;&#160;</a></span>core_util_atomic_fetch_add_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_fetch_add_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gadacb556c12ab10eb1bac2ce28d837415" name="gadacb556c12ab10eb1bac2ce28d837415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadacb556c12ab10eb1bac2ce28d837415">&#9670;&#160;</a></span>core_util_atomic_fetch_add_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_add_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga5ce4cf4be0c038e724bc5be4d03d9026" name="ga5ce4cf4be0c038e724bc5be4d03d9026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce4cf4be0c038e724bc5be4d03d9026">&#9670;&#160;</a></span>core_util_atomic_fetch_add_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_add_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga71166f17a0453072cb2a53c9b2c70b50" name="ga71166f17a0453072cb2a53c9b2c70b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71166f17a0453072cb2a53c9b2c70b50">&#9670;&#160;</a></span>core_util_atomic_fetch_add_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_add_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gab749485f59e3e2d83e62ee565aeca6f5" name="gab749485f59e3e2d83e62ee565aeca6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab749485f59e3e2d83e62ee565aeca6f5">&#9670;&#160;</a></span>core_util_atomic_fetch_add_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_add_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gac3707ed5422ba9e5741b7fddd0530dc3" name="gac3707ed5422ba9e5741b7fddd0530dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3707ed5422ba9e5741b7fddd0530dc3">&#9670;&#160;</a></span>core_util_atomic_fetch_add_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint16_t core_util_atomic_fetch_add_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga3f26fa5f6aa85ebc795336c8c4e805b5" name="ga3f26fa5f6aa85ebc795336c8c4e805b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f26fa5f6aa85ebc795336c8c4e805b5">&#9670;&#160;</a></span>core_util_atomic_fetch_add_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint32_t core_util_atomic_fetch_add_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gaccdbfedfdbdad88c8f18caf0a3212f9b" name="gaccdbfedfdbdad88c8f18caf0a3212f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccdbfedfdbdad88c8f18caf0a3212f9b">&#9670;&#160;</a></span>core_util_atomic_fetch_add_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_add_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga2f569432de64b03b369c41e911f7013b" name="ga2f569432de64b03b369c41e911f7013b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f569432de64b03b369c41e911f7013b">&#9670;&#160;</a></span>core_util_atomic_fetch_add_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint8_t core_util_atomic_fetch_add_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="gaeb2f48d1bb656d61c0dc92f255c6f21a" name="gaeb2f48d1bb656d61c0dc92f255c6f21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb2f48d1bb656d61c0dc92f255c6f21a">&#9670;&#160;</a></span>core_util_atomic_fetch_and_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_and_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise and. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6169b1a76622a0260d8ce24f2a27a071" name="ga6169b1a76622a0260d8ce24f2a27a071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6169b1a76622a0260d8ce24f2a27a071">&#9670;&#160;</a></span>core_util_atomic_fetch_and_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_and_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise and. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac2969415714af3a77fbb565e78328a4f" name="gac2969415714af3a77fbb565e78328a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2969415714af3a77fbb565e78328a4f">&#9670;&#160;</a></span>core_util_atomic_fetch_and_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_and_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise and. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga118df0bb30ca68d2be8c084be472289b" name="ga118df0bb30ca68d2be8c084be472289b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118df0bb30ca68d2be8c084be472289b">&#9670;&#160;</a></span>core_util_atomic_fetch_and_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_and_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise and. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga34e66326fd7f787dbfe46e64662160b4" name="ga34e66326fd7f787dbfe46e64662160b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34e66326fd7f787dbfe46e64662160b4">&#9670;&#160;</a></span>core_util_atomic_fetch_and_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint16_t core_util_atomic_fetch_and_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise and. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga25ff2cb2140b2c447d4af4da3d26a983" name="ga25ff2cb2140b2c447d4af4da3d26a983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25ff2cb2140b2c447d4af4da3d26a983">&#9670;&#160;</a></span>core_util_atomic_fetch_and_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint32_t core_util_atomic_fetch_and_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise and. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gacf9ca48255c2fb18551881f37b86f004" name="gacf9ca48255c2fb18551881f37b86f004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9ca48255c2fb18551881f37b86f004">&#9670;&#160;</a></span>core_util_atomic_fetch_and_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_and_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise and. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gae6c8a0d06e0106275397f533d22dee91" name="gae6c8a0d06e0106275397f533d22dee91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6c8a0d06e0106275397f533d22dee91">&#9670;&#160;</a></span>core_util_atomic_fetch_and_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint8_t core_util_atomic_fetch_and_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic bitwise and. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="gaffa1ebeb601da04d37d5e7170e52505d" name="gaffa1ebeb601da04d37d5e7170e52505d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffa1ebeb601da04d37d5e7170e52505d">&#9670;&#160;</a></span>core_util_atomic_fetch_or_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_or_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise inclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga987adeb2ae9c2db2551a61aa4b426df2" name="ga987adeb2ae9c2db2551a61aa4b426df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987adeb2ae9c2db2551a61aa4b426df2">&#9670;&#160;</a></span>core_util_atomic_fetch_or_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_or_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise inclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7733cc83af1260afd5484d9f8ab64a52" name="ga7733cc83af1260afd5484d9f8ab64a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7733cc83af1260afd5484d9f8ab64a52">&#9670;&#160;</a></span>core_util_atomic_fetch_or_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_or_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise inclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19a483c3c606c7a95e539c269937b3fa" name="ga19a483c3c606c7a95e539c269937b3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a483c3c606c7a95e539c269937b3fa">&#9670;&#160;</a></span>core_util_atomic_fetch_or_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_or_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise inclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadee96da40990d243bb1f2afa44e20d32" name="gadee96da40990d243bb1f2afa44e20d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadee96da40990d243bb1f2afa44e20d32">&#9670;&#160;</a></span>core_util_atomic_fetch_or_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint16_t core_util_atomic_fetch_or_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise inclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga65c93e9a7b8b173fc03c022037d95a9b" name="ga65c93e9a7b8b173fc03c022037d95a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65c93e9a7b8b173fc03c022037d95a9b">&#9670;&#160;</a></span>core_util_atomic_fetch_or_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint32_t core_util_atomic_fetch_or_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise inclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gaa8c5f724d821fa01783eeb9f9b6654bc" name="gaa8c5f724d821fa01783eeb9f9b6654bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8c5f724d821fa01783eeb9f9b6654bc">&#9670;&#160;</a></span>core_util_atomic_fetch_or_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_or_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise inclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gae1d4c46bdffd018dd1f8e06e8049a978" name="gae1d4c46bdffd018dd1f8e06e8049a978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1d4c46bdffd018dd1f8e06e8049a978">&#9670;&#160;</a></span>core_util_atomic_fetch_or_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint8_t core_util_atomic_fetch_or_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic bitwise inclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="ga096af7149a60b608b9c528530d61a232" name="ga096af7149a60b608b9c528530d61a232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga096af7149a60b608b9c528530d61a232">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_fetch_sub_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3198e21d50306edeca33e63eb6121613" name="ga3198e21d50306edeca33e63eb6121613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3198e21d50306edeca33e63eb6121613">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_sub_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga038e3bea482bb48b4d2cec13a568c382" name="ga038e3bea482bb48b4d2cec13a568c382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga038e3bea482bb48b4d2cec13a568c382">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_sub_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga644d915b39e49bf2d83f44d3b5762927" name="ga644d915b39e49bf2d83f44d3b5762927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644d915b39e49bf2d83f44d3b5762927">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_sub_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc7d33c43f941840f436513972cffdf1" name="gafc7d33c43f941840f436513972cffdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7d33c43f941840f436513972cffdf1">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_sub_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef713cf9e4b240fc9333ae986a64f3ad" name="gaef713cf9e4b240fc9333ae986a64f3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef713cf9e4b240fc9333ae986a64f3ad">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_sub_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a744e93eda19b361077c2d283f69c11" name="ga6a744e93eda19b361077c2d283f69c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a744e93eda19b361077c2d283f69c11">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_sub_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf71e00325c1ca7d78bfec53182c972a1" name="gaf71e00325c1ca7d78bfec53182c972a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf71e00325c1ca7d78bfec53182c972a1">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_sub_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0cdf17854e749a41ffb1ef1c9391ccb1" name="ga0cdf17854e749a41ffb1ef1c9391ccb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cdf17854e749a41ffb1ef1c9391ccb1">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_sub_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga693d6b9a52e7334f01b6893d132cecb1" name="ga693d6b9a52e7334f01b6893d132cecb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga693d6b9a52e7334f01b6893d132cecb1">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_fetch_sub_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga1b1f99cad729bd49aa63c570a968a489" name="ga1b1f99cad729bd49aa63c570a968a489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1f99cad729bd49aa63c570a968a489">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_sub_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gaf8dce75d68ca82cb52baeb761d6abee3" name="gaf8dce75d68ca82cb52baeb761d6abee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8dce75d68ca82cb52baeb761d6abee3">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_sub_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga17bf4f676b1bf6a95e8fd98fd02fe63d" name="ga17bf4f676b1bf6a95e8fd98fd02fe63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17bf4f676b1bf6a95e8fd98fd02fe63d">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_sub_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga9b868ca82165d3e1e86ff8cb3cc45878" name="ga9b868ca82165d3e1e86ff8cb3cc45878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b868ca82165d3e1e86ff8cb3cc45878">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_sub_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga9f3d5a4f47e55bb26db95d0cc82d5120" name="ga9f3d5a4f47e55bb26db95d0cc82d5120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f3d5a4f47e55bb26db95d0cc82d5120">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint16_t core_util_atomic_fetch_sub_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gaf936945ebc2a75d628bf979d587af28e" name="gaf936945ebc2a75d628bf979d587af28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf936945ebc2a75d628bf979d587af28e">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint32_t core_util_atomic_fetch_sub_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga63f7d9554d99b226c04021bf058809e9" name="ga63f7d9554d99b226c04021bf058809e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63f7d9554d99b226c04021bf058809e9">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_sub_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga32bf21c75f714c837dac8baa9e55eb6d" name="ga32bf21c75f714c837dac8baa9e55eb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32bf21c75f714c837dac8baa9e55eb6d">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint8_t core_util_atomic_fetch_sub_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic subtract. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="ga0cac1f70d86145102d3bf1ceaaed4b54" name="ga0cac1f70d86145102d3bf1ceaaed4b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cac1f70d86145102d3bf1ceaaed4b54">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_xor_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise exclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7cf9e78a72b5ed55edcb09240af4e187" name="ga7cf9e78a72b5ed55edcb09240af4e187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cf9e78a72b5ed55edcb09240af4e187">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_xor_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise exclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3cda9f9445bbace6d20e5ae02bc4a6e8" name="ga3cda9f9445bbace6d20e5ae02bc4a6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cda9f9445bbace6d20e5ae02bc4a6e8">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_xor_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise exclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f687c46f29f48b760123770f9cf30f8" name="ga7f687c46f29f48b760123770f9cf30f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f687c46f29f48b760123770f9cf30f8">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_xor_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise exclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f7172411bd4b7fa44777dd7f945af81" name="ga7f7172411bd4b7fa44777dd7f945af81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7172411bd4b7fa44777dd7f945af81">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint16_t core_util_atomic_fetch_xor_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise exclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="gab471f077a79eadf1a398464ab72e1016" name="gab471f077a79eadf1a398464ab72e1016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab471f077a79eadf1a398464ab72e1016">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint32_t core_util_atomic_fetch_xor_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise exclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga6b70c15733c776dbcae1a7ee5c056201" name="ga6b70c15733c776dbcae1a7ee5c056201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b70c15733c776dbcae1a7ee5c056201">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_xor_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic bitwise exclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.    </dd></dl>

</div>
</div>
<a id="ga3509db0dc730a9ad7b3009ed0a83059d" name="ga3509db0dc730a9ad7b3009ed0a83059d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3509db0dc730a9ad7b3009ed0a83059d">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint8_t core_util_atomic_fetch_xor_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic bitwise exclusive or. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="gafe5e3f9d2bd9cf92276dacdc3928f4f0" name="gafe5e3f9d2bd9cf92276dacdc3928f4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe5e3f9d2bd9cf92276dacdc3928f4f0">&#9670;&#160;</a></span>core_util_atomic_flag_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_flag_clear </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *</td>          <td class="paramname"><span class="paramname"><em>flagPtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic clear.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flagPtr</td><td>Target flag being cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1918431bfda711a76ff391ae95f7cdd" name="gaa1918431bfda711a76ff391ae95f7cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1918431bfda711a76ff391ae95f7cdd">&#9670;&#160;</a></span>core_util_atomic_flag_clear_explicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_flag_clear_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *</td>          <td class="paramname"><span class="paramname"><em>flagPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\ copydoc core_util_atomic_flag_clear </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga089a51dfa1c87b1ad6c9855b67e6143e" name="ga089a51dfa1c87b1ad6c9855b67e6143e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga089a51dfa1c87b1ad6c9855b67e6143e">&#9670;&#160;</a></span>core_util_atomic_flag_test_and_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX bool core_util_atomic_flag_test_and_set </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *</td>          <td class="paramname"><span class="paramname"><em>flagPtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic test and set.</p>
<p>Atomically tests then sets the flag to true, returning the previous value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flagPtr</td><td>Target flag being tested and set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

</div>
</div>
<a id="gae873e0a5133bece10fa16b29c43ecc34" name="gae873e0a5133bece10fa16b29c43ecc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae873e0a5133bece10fa16b29c43ecc34">&#9670;&#160;</a></span>core_util_atomic_flag_test_and_set_explicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_flag_test_and_set_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\ copydoc core_util_atomic_flag_test_and_set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga552c51b9a90675e7f5c70d3769e2c5e8" name="ga552c51b9a90675e7f5c70d3769e2c5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga552c51b9a90675e7f5c70d3769e2c5e8">&#9670;&#160;</a></span>core_util_atomic_incr_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_incr_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.    </dd></dl>

</div>
</div>
<a id="gaf71073f46116c910e80c0c4c7409b995" name="gaf71073f46116c910e80c0c4c7409b995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf71073f46116c910e80c0c4c7409b995">&#9670;&#160;</a></span>core_util_atomic_incr_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_incr_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.    </dd></dl>

</div>
</div>
<a id="gaad1b7864af7323246bd38768aff11cf8" name="gaad1b7864af7323246bd38768aff11cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad1b7864af7323246bd38768aff11cf8">&#9670;&#160;</a></span>core_util_atomic_incr_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_incr_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.    </dd></dl>

</div>
</div>
<a id="gad8058a48a1ddde0bfd1900f9fc789eca" name="gad8058a48a1ddde0bfd1900f9fc789eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8058a48a1ddde0bfd1900f9fc789eca">&#9670;&#160;</a></span>core_util_atomic_incr_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_incr_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.    </dd></dl>

</div>
</div>
<a id="gad991d615f9643f15f883e6c4638fe31e" name="gad991d615f9643f15f883e6c4638fe31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad991d615f9643f15f883e6c4638fe31e">&#9670;&#160;</a></span>core_util_atomic_incr_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_incr_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.    </dd></dl>

</div>
</div>
<a id="ga6b09ba48b5d1998308d9652ab102a0dc" name="ga6b09ba48b5d1998308d9652ab102a0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b09ba48b5d1998308d9652ab102a0dc">&#9670;&#160;</a></span>core_util_atomic_incr_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint16_t core_util_atomic_incr_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.    </dd></dl>

</div>
</div>
<a id="ga9a097df540b0f9d73d01bde72f5d09af" name="ga9a097df540b0f9d73d01bde72f5d09af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a097df540b0f9d73d01bde72f5d09af">&#9670;&#160;</a></span>core_util_atomic_incr_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint32_t core_util_atomic_incr_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.    </dd></dl>

</div>
</div>
<a id="ga1da475be0bf8e7d9e7cd16177e3d13a5" name="ga1da475be0bf8e7d9e7cd16177e3d13a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da475be0bf8e7d9e7cd16177e3d13a5">&#9670;&#160;</a></span>core_util_atomic_incr_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_incr_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.    </dd></dl>

</div>
</div>
<a id="ga97639d48a80bb088d578407ec894de40" name="ga97639d48a80bb088d578407ec894de40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97639d48a80bb088d578407ec894de40">&#9670;&#160;</a></span>core_util_atomic_incr_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBED_INLINE_IF_EX uint8_t core_util_atomic_incr_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a id="gaba968e929680be76321b4c639287f968" name="gaba968e929680be76321b4c639287f968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba968e929680be76321b4c639287f968">&#9670;&#160;</a></span>core_util_atomic_load_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_load_bool </td>
          <td>(</td>
          <td class="paramtype">const volatile bool *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="ga2b4b4c68346a582ed810f5a42f9083e6" name="ga2b4b4c68346a582ed810f5a42f9083e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b4b4c68346a582ed810f5a42f9083e6">&#9670;&#160;</a></span>core_util_atomic_load_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_load_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">const volatile bool *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="ga9ce10c2fe84037a9ffc96d99090f154a" name="ga9ce10c2fe84037a9ffc96d99090f154a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ce10c2fe84037a9ffc96d99090f154a">&#9670;&#160;</a></span>core_util_atomic_load_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_load_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *const volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="ga99004d90211c9e8b31d40a5a86312a8f" name="ga99004d90211c9e8b31d40a5a86312a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99004d90211c9e8b31d40a5a86312a8f">&#9670;&#160;</a></span>core_util_atomic_load_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_load_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">const volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a70e0153206702a003de75ffe9b86aa" name="ga5a70e0153206702a003de75ffe9b86aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a70e0153206702a003de75ffe9b86aa">&#9670;&#160;</a></span>core_util_atomic_load_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_load_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">const volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga426c13fee706b73968b19273be5544fd" name="ga426c13fee706b73968b19273be5544fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga426c13fee706b73968b19273be5544fd">&#9670;&#160;</a></span>core_util_atomic_load_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_load_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">const volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__toolchain.html#ga3e0b3dc191a8e64de80be44bbc8d5193">MBED_UNUSED</a> <a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="ga765734c8f47168fbf2e1d3583466df96" name="ga765734c8f47168fbf2e1d3583466df96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga765734c8f47168fbf2e1d3583466df96">&#9670;&#160;</a></span>core_util_atomic_load_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_load_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">const volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a81771e47a93b508d6ec3f4666b506e" name="ga2a81771e47a93b508d6ec3f4666b506e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a81771e47a93b508d6ec3f4666b506e">&#9670;&#160;</a></span>core_util_atomic_load_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_load_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa85935b1f85886bd69c028aad61d16ce" name="gaa85935b1f85886bd69c028aad61d16ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa85935b1f85886bd69c028aad61d16ce">&#9670;&#160;</a></span>core_util_atomic_load_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_load_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf24e043d3f39b59e5c4e53f7d39558d0" name="gaf24e043d3f39b59e5c4e53f7d39558d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf24e043d3f39b59e5c4e53f7d39558d0">&#9670;&#160;</a></span>core_util_atomic_load_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_load_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4b5b21126d2a22858faaf8018b5e66f9" name="ga4b5b21126d2a22858faaf8018b5e66f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b5b21126d2a22858faaf8018b5e66f9">&#9670;&#160;</a></span>core_util_atomic_load_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_load_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87170ad015a30beac00a7764b456c7ea" name="ga87170ad015a30beac00a7764b456c7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87170ad015a30beac00a7764b456c7ea">&#9670;&#160;</a></span>core_util_atomic_load_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_load_ptr </td>
          <td>(</td>
          <td class="paramtype">void *const volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="ga663356b18705a1c4ae4d87643ae239f6" name="ga663356b18705a1c4ae4d87643ae239f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga663356b18705a1c4ae4d87643ae239f6">&#9670;&#160;</a></span>core_util_atomic_load_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_load_s16 </td>
          <td>(</td>
          <td class="paramtype">const volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="ga1994aaeae2efb36b58051da401a95b36" name="ga1994aaeae2efb36b58051da401a95b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1994aaeae2efb36b58051da401a95b36">&#9670;&#160;</a></span>core_util_atomic_load_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_load_s32 </td>
          <td>(</td>
          <td class="paramtype">const volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="ga100297ebd80cd21846398c6ad7d81f43" name="ga100297ebd80cd21846398c6ad7d81f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga100297ebd80cd21846398c6ad7d81f43">&#9670;&#160;</a></span>core_util_atomic_load_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_load_s64 </td>
          <td>(</td>
          <td class="paramtype">const volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="gaeecfddc99e71a90287f0220e8fd3e206" name="gaeecfddc99e71a90287f0220e8fd3e206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeecfddc99e71a90287f0220e8fd3e206">&#9670;&#160;</a></span>core_util_atomic_load_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_load_s8 </td>
          <td>(</td>
          <td class="paramtype">const volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="ga6b13b1196ed2a63802d7acf2ea08aaf4" name="ga6b13b1196ed2a63802d7acf2ea08aaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b13b1196ed2a63802d7acf2ea08aaf4">&#9670;&#160;</a></span>core_util_atomic_load_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_load_u16 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="gade580faac99dbf59aeda5da1e4c213ad" name="gade580faac99dbf59aeda5da1e4c213ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade580faac99dbf59aeda5da1e4c213ad">&#9670;&#160;</a></span>core_util_atomic_load_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_load_u32 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="gae79f750b7b18b9b6c54b9f67c235195f" name="gae79f750b7b18b9b6c54b9f67c235195f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae79f750b7b18b9b6c54b9f67c235195f">&#9670;&#160;</a></span>core_util_atomic_load_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_load_u64 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value.    </dd></dl>

</div>
</div>
<a id="ga2840954e59468ea85b91e17ca50ad009" name="ga2840954e59468ea85b91e17ca50ad009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2840954e59468ea85b91e17ca50ad009">&#9670;&#160;</a></span>core_util_atomic_load_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_load_u8 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a id="ga4692889cc8d1bd170af962728be04dc3" name="ga4692889cc8d1bd170af962728be04dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4692889cc8d1bd170af962728be04dc3">&#9670;&#160;</a></span>core_util_atomic_store_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab9ca948b9322559e941dd359400ae4fe" name="gab9ca948b9322559e941dd359400ae4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9ca948b9322559e941dd359400ae4fe">&#9670;&#160;</a></span>core_util_atomic_store_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca4ebe09fe2de1ddc6ce8151baefc991" name="gaca4ebe09fe2de1ddc6ce8151baefc991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca4ebe09fe2de1ddc6ce8151baefc991">&#9670;&#160;</a></span>core_util_atomic_store_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaedd333e4cab3877d64f041e538cff66b" name="gaedd333e4cab3877d64f041e538cff66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedd333e4cab3877d64f041e538cff66b">&#9670;&#160;</a></span>core_util_atomic_store_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b27494dba292ef9caa12d164b7a1b9d" name="ga3b27494dba292ef9caa12d164b7a1b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b27494dba292ef9caa12d164b7a1b9d">&#9670;&#160;</a></span>core_util_atomic_store_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade28bd9fce9c1c0f448eab73cb00e460" name="gade28bd9fce9c1c0f448eab73cb00e460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade28bd9fce9c1c0f448eab73cb00e460">&#9670;&#160;</a></span>core_util_atomic_store_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga361bc02b02df102a3f3ddf0ae84a9df0" name="ga361bc02b02df102a3f3ddf0ae84a9df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga361bc02b02df102a3f3ddf0ae84a9df0">&#9670;&#160;</a></span>core_util_atomic_store_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad81d69ed6094e7cd6cfb1f3b729955fc" name="gad81d69ed6094e7cd6cfb1f3b729955fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad81d69ed6094e7cd6cfb1f3b729955fc">&#9670;&#160;</a></span>core_util_atomic_store_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2960e2d63e4c37c93f202cbb597189a9" name="ga2960e2d63e4c37c93f202cbb597189a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2960e2d63e4c37c93f202cbb597189a9">&#9670;&#160;</a></span>core_util_atomic_store_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad54a248229f8606e148c9708c7237334" name="gad54a248229f8606e148c9708c7237334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54a248229f8606e148c9708c7237334">&#9670;&#160;</a></span>core_util_atomic_store_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca1cdaf85b894b8bccb88e870577f324" name="gaca1cdaf85b894b8bccb88e870577f324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca1cdaf85b894b8bccb88e870577f324">&#9670;&#160;</a></span>core_util_atomic_store_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa112a4db89b94efa5f785035415f0d5a" name="gaa112a4db89b94efa5f785035415f0d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa112a4db89b94efa5f785035415f0d5a">&#9670;&#160;</a></span>core_util_atomic_store_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae67ef75f813610e1bd3804b4cfa22565" name="gae67ef75f813610e1bd3804b4cfa22565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae67ef75f813610e1bd3804b4cfa22565">&#9670;&#160;</a></span>core_util_atomic_store_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63d826b01dc7aae7c3a473c349f0ee32" name="ga63d826b01dc7aae7c3a473c349f0ee32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63d826b01dc7aae7c3a473c349f0ee32">&#9670;&#160;</a></span>core_util_atomic_store_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15431b3da92b29949c1d597f425c7a07" name="ga15431b3da92b29949c1d597f425c7a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15431b3da92b29949c1d597f425c7a07">&#9670;&#160;</a></span>core_util_atomic_store_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2024d6b1bd77f35d0bd27b9abeaca252" name="ga2024d6b1bd77f35d0bd27b9abeaca252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2024d6b1bd77f35d0bd27b9abeaca252">&#9670;&#160;</a></span>core_util_atomic_store_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f38862b163d1a943b28dabfd39fc8ef" name="ga2f38862b163d1a943b28dabfd39fc8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f38862b163d1a943b28dabfd39fc8ef">&#9670;&#160;</a></span>core_util_atomic_store_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga981dd31a80f495369723280424a3999e" name="ga981dd31a80f495369723280424a3999e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga981dd31a80f495369723280424a3999e">&#9670;&#160;</a></span>core_util_atomic_store_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaffb39f69f9e80d787404bcdc627bd39" name="gaaffb39f69f9e80d787404bcdc627bd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaffb39f69f9e80d787404bcdc627bd39">&#9670;&#160;</a></span>core_util_atomic_store_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf5c3fa6d415e012c34c7c82056817f29" name="gaf5c3fa6d415e012c34c7c82056817f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5c3fa6d415e012c34c7c82056817f29">&#9670;&#160;</a></span>core_util_atomic_store_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *</td>          <td class="paramname"><span class="paramname"><em>valuePtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>desiredValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic store. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
