<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: Porting guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2connectivity_2FEATURE__BLE_2include_2ble_2driver_2doc_2PortingGuide.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Porting guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md179"></a></p>
<p>There are two main steps to enable the Mbed <a class="el" href="classBLE.html">BLE</a> Cordio port:</p>
<ol type="1">
<li>Configure your target to include Cordio <a class="el" href="classBLE.html">BLE</a> port and Cordio libraries during the build process.</li>
<li>Implement the <code>CordioHCIDriver</code> class targeting the Bluetooth controller.</li>
</ol>
<h2><a class="anchor" id="autotoc_md180"></a>
Configure the target</h2>
<ol type="1">
<li>Define all Mbed OS targets in the <code>targets/target.json</code> file:</li>
</ol>
<ol type="1">
<li>Add <a class="el" href="classBLE.html">BLE</a> support to the target:<ul>
<li>Add the string <code><a class="el" href="classBLE.html">BLE</a></code> to the target's list of <code>features</code>. This adds the <a class="el" href="classBLE.html">BLE</a> API sources to the list of sources compiled for the target:</li>
</ul>
</li>
</ol>
<div class="fragment"><div class="line">&quot;TARGET_NAME&quot;: {</div>
<div class="line">    &quot;features&quot;: [&quot;target features ...&quot;, &quot;BLE&quot;]</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md181"></a>
Include Cordio BLE implementation</h2>
<p>Compile the <a class="el" href="classBLE.html">BLE</a> Cordio port sources:</p>
<ul>
<li>Add the string <code>CORDIO</code> to the <code>extra_labels</code> property of the JSON file:</li>
</ul>
<div class="fragment"><div class="line">&quot;TARGET_NAME&quot;: {</div>
<div class="line">    &quot;extra_labels&quot;: [&quot;target extra labels ...&quot;, &quot;CORDIO&quot;],</div>
<div class="line">    &quot;features&quot;: [&quot;target features ...&quot;, &quot;BLE&quot;]</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md182"></a>
Implement CordioHCIDriver:</h2>
<p>Include an HCI driver for the <a class="el" href="classBLE.html">BLE</a> module used by the target, and a factory function that creates the <a class="el" href="classBLE.html">BLE</a> instance you use.</p>
<h3><a class="anchor" id="autotoc_md183"></a>
Create source folder</h3>
<ol type="1">
<li>Navigate to the folder of the <a class="el" href="classBLE.html">BLE</a> API that hosts the target port <code>features/FEATURE_BLE/targets</code>.</li>
</ol>
<ol type="1">
<li>Create a folder containing the port code to isolate it from other code.</li>
</ol>
<ol type="1">
<li>Begin this folder's name with <code>TARGET_</code> and the rest of the name in capital letters.</li>
</ol>
<h3><a class="anchor" id="autotoc_md184"></a>
Create the HCI driver</h3>
<p>The HCI driver is split into two entities. One handles HCI communication with the Bluetooth module. The other handles the initialization, reset sequence, and memory dedicated to the Bluetooth controller.</p>
<p>More information about the architecture can be found in <a class="el" href="md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2connectivity_2FEATURE__BLE_2include_2ble_2driver_2doc_2HCIAbstraction.html">HCI abstraction architecture</a>.</p>
<h3><a class="anchor" id="autotoc_md185"></a>
HCITransport</h3>
<p><span class="notes"><b>Note:</b> If the Bluetooth controller uses an H4 communication interface and the host exposes serial flow control in Mbed, you can skip this step. Use the class <code>ble::H4TransportDriver</code> as the transport driver.</span></p>
<p>The transport driver shall inherit publicly from the base class <code>CordioHCITransportDriver</code>.</p>
<p>To code a basic transport driver:</p>
<div class="fragment"><div class="line">#include &quot;CordioHCITransportDriver.h&quot;</div>
<div class="line"> </div>
<div class="line">namespace ble {</div>
<div class="line">namespace vendor {</div>
<div class="line">namespace target_name {</div>
<div class="line"> </div>
<div class="line">class TransportDriver : public CordioHCITransportDriver {</div>
<div class="line">public:</div>
<div class="line">    TransportDriver(/* specific constructor arguments*/);</div>
<div class="line"> </div>
<div class="line">    virtual ~TransportDriver();</div>
<div class="line"> </div>
<div class="line">    virtual void initialize();</div>
<div class="line"> </div>
<div class="line">    virtual void terminate();</div>
<div class="line"> </div>
<div class="line">    virtual uint16_t write(uint8_t packet_type, uint16_t len, uint8_t *data);</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    // private driver declarations</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} // namespace target_name</div>
<div class="line">} // namespace vendor</div>
<div class="line">} // namespace ble</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md186"></a>
Functions</h4>
<ul>
<li><b>Initialization/termination</b>: The functions <code>initialize</code> and <code>terminate</code> are responsible for initializing and terminating the transport driver. It is not necessary to initialize the transport in the constructor.</li>
<li><b>Sending data</b>: The function <code>write</code> sends data as input to the Bluetooth controller and returns the number of bytes in the <code>data</code> buffer sent. Depending on the type of transport you implement, you may need to send the packet <code>type</code> to the controller before the packet data.</li>
<li><b>Receiving data</b>: Inject HCI data from the Bluetooth controller to the system by calling <code>on_data_received</code>. This is a static function provided by the base class.</li>
</ul>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">void on_data_received(uint8_t* data_received, uint16_t length_of_data_received);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md187"></a>
HCIDriver</h3>
<p>The HCI Driver shall inherit publicly from the base class <code>CordioHCIDriver</code>.</p>
<p>The driver template is:</p>
<div class="fragment"><div class="line">#include &quot;CordioHCIDriver.h&quot;</div>
<div class="line"> </div>
<div class="line">namespace ble {</div>
<div class="line">namespace vendor {</div>
<div class="line">namespace target_name {</div>
<div class="line"> </div>
<div class="line">class HCIDriver : public CordioHCIDriver {</div>
<div class="line">public:</div>
<div class="line">    HCIDriver(</div>
<div class="line">        CordioHCITransportDriver&amp; transport_driver,</div>
<div class="line">        /* specific constructor arguments*/</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    virtual ~HCIDriver();</div>
<div class="line"> </div>
<div class="line">    virtual void do_initialize();</div>
<div class="line"> </div>
<div class="line">    virtual void do_terminate();</div>
<div class="line"> </div>
<div class="line">    virtual buf_pool_desc_t get_buffer_pool_description();</div>
<div class="line"> </div>
<div class="line">    virtual void start_reset_sequence();</div>
<div class="line"> </div>
<div class="line">    virtual void handle_reset_sequence(uint8_t *msg);</div>
<div class="line">private:</div>
<div class="line">    // private driver declarations</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} // namespace target_name</div>
<div class="line">} // namespace vendor</div>
<div class="line">} // namespace ble</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md188"></a>
Initialization process</h4>
<p>The functions <code>do_initialize</code> and <code>do_terminate</code> handle initialization and termination processes. These functions manage the state of the Bluetooth controller.</p>
<p><span class="notes"><b>Note:</b> It is unnecessary to initialize or terminate the HCI transport in these functions, because that is handled by the base class. The HCI transport is initialized right before the call to <code>do_initialize</code> and is terminated right after the call to <code>do_terminate</code>.</span></p>
<h4><a class="anchor" id="autotoc_md189"></a>
Memory pool</h4>
<p>Porters must override the <code>get_buffer_pool_description</code> function, which should return a buffer pool for the Cordio stack to use.</p>
<p>The function <code>get_default_buffer_pool_description</code> in the base class returns a buffer of 2250 bytes divided into different memory pools, and most implementations can use it:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Chunk size (bytes)   </th><th class="markdownTableHeadNone">Number of chunks    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">16    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">16    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">64   </td><td class="markdownTableBodyNone">8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">128   </td><td class="markdownTableBodyNone">4    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">272   </td><td class="markdownTableBodyNone">1   </td></tr>
</table>
<p><b>Example:</b> </p><div class="fragment"><div class="line">buf_pool_desc_t CordioHCIDriver::get_buffer_pool_description()  {</div>
<div class="line">    return get_default_buffer_pool_description();</div>
<div class="line">}</div>
</div><!-- fragment --><p>If the memory the base class provides doesn't match what the Bluetooth controller driver requires, a custom pool can be returned.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">buf_pool_desc_t CordioHCIDriver::get_buffer_pool_description()  {</div>
<div class="line">    static uint8_t buffer[/* buffer size */];</div>
<div class="line">    static const wsfBufPoolDesc_t pool_desc[] = {</div>
<div class="line">        { /* chunk size */, /* number of chunks */ },</div>
<div class="line">        { /* chunk size */, /* number of chunks */ },</div>
<div class="line">        { /* chunk size */, /* number of chunks */ },</div>
<div class="line">        { /* chunk size */, /* number of chunks */ },</div>
<div class="line">        { /* chunk size */, /* number of chunks */ },</div>
<div class="line">        { /* chunk size */, /* number of chunks */ },</div>
<div class="line">        { /* chunk size */, /* number of chunks */ },</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    return buf_pool_desc_t(buffer, pool_desc);</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md190"></a>
Reset sequence</h4>
<p>Three functions handle the reset sequence process:</p>
<ul>
<li><code>start_reset_sequence</code>: This function starts the process. It sends an HCI reset command to the Bluetooth controller. You can override this function <em>if</em> the Bluetooth controller requires more than just sending the standard reset command.</li>
<li><code>handle_reset_sequence</code>: Entry point to the state machine handling the reset process. Every time an HCI packet is received during the reset sequence, this function is called with the HCI packet received. Its purpose is to prepare the Bluetooth controller and set the parameters the stack needs to operate properly. You can override this function if necessary.</li>
<li><code>signal_reset_sequence_done</code>: Once the reset sequence is completed, you can call this function. You cannot override it.</li>
</ul>
<h5><a class="anchor" id="autotoc_md191"></a>
Controller parameters to set</h5>
<p>This step tells the controller which events are relevant to the stack.</p>
<p>You should set the following parameters in the controller (if supported):</p>
<ul>
<li><b>Event mask:</b> Call <code>HciSetEventMaskCmd((uint8_t *) hciEventMask)</code>.</li>
<li><b>LE event mask:</b> Call <code>HciLeSetEventMaskCmd((uint8_t *) hciLeEventMask)</code>.</li>
<li><b>2nd page of events mask:</b> Call <code>HciSetEventMaskPage2Cmd((uint8_t *) hciEventMaskPage2)</code>.</li>
</ul>
<h5><a class="anchor" id="autotoc_md192"></a>
Stack runtime parameters</h5>
<p>At runtime, you can get stack parameters from the controller:</p>
<ul>
<li><b>Bluetooth address:</b> Query this with <code>HciReadBdAddrCmd</code>. Copy the response into <code>hciCoreCb.bdAddr</code> with <code>BdaCpy</code>.</li>
<li><b><a class="el" href="classBuffer.html">Buffer</a> size of the controller:</b> Query this with <code>HciLeReadBufSizeCmd</code>.<ul>
<li>The return parameter <code>HC_ACL_Data_Packet_Length</code> is copied to <code>hciCoreCb.bufSize</code>. Copy the response parameter <code>HC_Synchronous_Data_Packet_Length</code> into <code>hciCoreCb.numBufs</code>. <code>hciCoreCb.numBufs</code> initializes the value of <code>hciCoreCb.availBufs</code>.</li>
</ul>
</li>
<li><b>Supported state:</b> Query this with <code>HciLeReadSupStatesCmd</code>, and copy the response into <code>hciCoreCb.leStates</code>.</li>
<li><b>Whitelist size:</b> Query this with <code>HciLeReadWhiteListSizeCmd</code>, and copy the response into <code>hciCoreCb.whiteListSize</code>.</li>
<li><b>LE features supported:</b> Query this with <code>HciLeReadLocalSupFeatCmd</code>, and copy the response into <code>hciCoreCb.leSupFeat</code>.</li>
<li><b>Resolving list size:</b> Query this with <code>hciCoreReadResolvingListSize</code>, and copy the response into <code>hciCoreCb.resListSize</code>.</li>
<li><b>Max data length:</b> Query this with <code>hciCoreReadMaxDataLen</code>, and pass the response parameters <code>supportedMaxTxOctets</code> and <code>supportedMaxTxTime</code> to the function <code>HciLeWriteDefDataLen</code>.</li>
</ul>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">void HCIDriver::handle_reset_sequence(uint8_t *pMsg)</div>
<div class="line">{</div>
<div class="line">    // only accept command complete event:</div>
<div class="line">    if (*pMsg != HCI_CMD_CMPL_EVT) {</div>
<div class="line">        return;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    uint16_t       opcode;</div>
<div class="line">    static uint8_t randCnt;</div>
<div class="line"> </div>
<div class="line">    /* parse parameters */</div>
<div class="line">    pMsg += HCI_EVT_HDR_LEN;</div>
<div class="line">    pMsg++;                   /* skip num packets */</div>
<div class="line">    BSTREAM_TO_UINT16(opcode, pMsg); // copy opcode</div>
<div class="line">    pMsg++;                   /* skip status */</div>
<div class="line"> </div>
<div class="line">    /* decode opcode */</div>
<div class="line">    switch (opcode)</div>
<div class="line">    {</div>
<div class="line">        case HCI_OPCODE_RESET:</div>
<div class="line">            /* initialize rand command count */</div>
<div class="line">            randCnt = 0;</div>
<div class="line">            // Set the event mask to control which events are generated by the controller for the host.</div>
<div class="line">            HciSetEventMaskCmd((uint8_t *) hciEventMask);</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_SET_EVENT_MASK:</div>
<div class="line">            // Set the event mask to control which LE events are generated by the controller for the host.</div>
<div class="line">            HciLeSetEventMaskCmd((uint8_t *) hciLeEventMask);</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_SET_EVENT_MASK:</div>
<div class="line">            // Set the event mask to control which events are generated by the controller for the host (2nd page of flags).</div>
<div class="line">            HciSetEventMaskPage2Cmd((uint8_t *) hciEventMaskPage2);</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_SET_EVENT_MASK_PAGE2:</div>
<div class="line">            // Ask the Bluetooth address of the controller.</div>
<div class="line">            HciReadBdAddrCmd();</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_READ_BD_ADDR:</div>
<div class="line">            // Store the Bluetooth address in the stack runtime parameter.</div>
<div class="line">            BdaCpy(hciCoreCb.bdAddr, pMsg);</div>
<div class="line"> </div>
<div class="line">            // Read the size of the buffer of the controller.</div>
<div class="line">            HciLeReadBufSizeCmd();</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_READ_BUF_SIZE:</div>
<div class="line">            // Store the buffer parameters in the stack runtime parameters.</div>
<div class="line">            BSTREAM_TO_UINT16(hciCoreCb.bufSize, pMsg);</div>
<div class="line">            BSTREAM_TO_UINT8(hciCoreCb.numBufs, pMsg);</div>
<div class="line"> </div>
<div class="line">            /* initialize ACL buffer accounting */</div>
<div class="line">            hciCoreCb.availBufs = hciCoreCb.numBufs;</div>
<div class="line"> </div>
<div class="line">            // Read the states and state combinations supported by the link layer of the controller.</div>
<div class="line">            HciLeReadSupStatesCmd();</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_READ_SUP_STATES:</div>
<div class="line">            // Store supported state and combination in the runtime parameters of the stack.</div>
<div class="line">            memcpy(hciCoreCb.leStates, pMsg, HCI_LE_STATES_LEN);</div>
<div class="line"> </div>
<div class="line">            // Read the total of whitelist entries that can be stored in the controller.</div>
<div class="line">            HciLeReadWhiteListSizeCmd();</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_READ_WHITE_LIST_SIZE:</div>
<div class="line">            // Store the number of whitelist entries in the stack runtime parameters.</div>
<div class="line">            BSTREAM_TO_UINT8(hciCoreCb.whiteListSize, pMsg);</div>
<div class="line"> </div>
<div class="line">            // Read the LE features supported by the controller.</div>
<div class="line">            HciLeReadLocalSupFeatCmd();</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_READ_LOCAL_SUP_FEAT:</div>
<div class="line">            // Store the set of LE features supported by the controller.</div>
<div class="line">            BSTREAM_TO_UINT16(hciCoreCb.leSupFeat, pMsg);</div>
<div class="line"> </div>
<div class="line">            // Read the total number of address translation entries which can be stored in the controller resolving list.</div>
<div class="line">            hciCoreReadResolvingListSize();</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_READ_RES_LIST_SIZE:</div>
<div class="line">            // Store the number of address translation entries in the stack runtime parameter.</div>
<div class="line">            BSTREAM_TO_UINT8(hciCoreCb.resListSize, pMsg);</div>
<div class="line"> </div>
<div class="line">            // Read the Controller’s maximum supported payload octets and packet duration times for transmission and reception.</div>
<div class="line">            hciCoreReadMaxDataLen();</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_READ_MAX_DATA_LEN:</div>
<div class="line">            {</div>
<div class="line">                // Store payload definition in the runtime stack parameters.</div>
<div class="line">                uint16_t maxTxOctets;</div>
<div class="line">                uint16_t maxTxTime;</div>
<div class="line"> </div>
<div class="line">                BSTREAM_TO_UINT16(maxTxOctets, pMsg);</div>
<div class="line">                BSTREAM_TO_UINT16(maxTxTime, pMsg);</div>
<div class="line"> </div>
<div class="line">                /* use Controller&#39;s maximum supported payload octets and packet duration times</div>
<div class="line">                * for transmission as Host&#39;s suggested values for maximum transmission number</div>
<div class="line">                * of payload octets and maximum packet transmission time for new connections.</div>
<div class="line">                */</div>
<div class="line">                HciLeWriteDefDataLen(maxTxOctets, maxTxTime);</div>
<div class="line">            }</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_WRITE_DEF_DATA_LEN:</div>
<div class="line">            if (hciCoreCb.extResetSeq)</div>
<div class="line">            {</div>
<div class="line">                /* send first extended command */</div>
<div class="line">                (*hciCoreCb.extResetSeq)(pMsg, opcode);</div>
<div class="line">            }</div>
<div class="line">            else</div>
<div class="line">            {</div>
<div class="line">                /* initialize extended parameters */</div>
<div class="line">                hciCoreCb.maxAdvDataLen = 0;</div>
<div class="line">                hciCoreCb.numSupAdvSets = 0;</div>
<div class="line">                hciCoreCb.perAdvListSize = 0;</div>
<div class="line"> </div>
<div class="line">                /* send next command in sequence */</div>
<div class="line">                HciLeRandCmd();</div>
<div class="line">            }</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_READ_MAX_ADV_DATA_LEN:</div>
<div class="line">        case HCI_OPCODE_LE_READ_NUM_SUP_ADV_SETS:</div>
<div class="line">        case HCI_OPCODE_LE_READ_PER_ADV_LIST_SIZE:</div>
<div class="line">            // handle extended command</div>
<div class="line">            if (hciCoreCb.extResetSeq)</div>
<div class="line">            {</div>
<div class="line">                /* send next extended command in sequence */</div>
<div class="line">                (*hciCoreCb.extResetSeq)(pMsg, opcode);</div>
<div class="line">            }</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        case HCI_OPCODE_LE_RAND:</div>
<div class="line">            /* check if need to send second rand command */</div>
<div class="line">            if (randCnt &lt; (HCI_RESET_RAND_CNT-1))</div>
<div class="line">            {</div>
<div class="line">                randCnt++;</div>
<div class="line">                HciLeRandCmd();</div>
<div class="line">            }</div>
<div class="line">            else</div>
<div class="line">            {</div>
<div class="line">                /* last command in sequence; set resetting state and call callback */</div>
<div class="line">                signal_reset_sequence_done();</div>
<div class="line">            }</div>
<div class="line">            break;</div>
<div class="line"> </div>
<div class="line">        default:</div>
<div class="line">            break;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">static void hciCoreReadMaxDataLen(void)</div>
<div class="line">{</div>
<div class="line">    /* if LE Data Packet Length Extensions is supported by Controller and included */</div>
<div class="line">    if ((hciCoreCb.leSupFeat &amp; HCI_LE_SUP_FEAT_DATA_LEN_EXT) &amp;&amp;</div>
<div class="line">        (hciLeSupFeatCfg &amp; HCI_LE_SUP_FEAT_DATA_LEN_EXT))</div>
<div class="line">    {</div>
<div class="line">        /* send next command in sequence */</div>
<div class="line">        HciLeReadMaxDataLen();</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">        /* send next command in sequence */</div>
<div class="line">        HciLeRandCmd();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">static void hciCoreReadResolvingListSize(void)</div>
<div class="line">{</div>
<div class="line">    /* if LL Privacy is supported by Controller and included */</div>
<div class="line">    if ((hciCoreCb.leSupFeat &amp; HCI_LE_SUP_FEAT_PRIVACY) &amp;&amp;</div>
<div class="line">        (hciLeSupFeatCfg &amp; HCI_LE_SUP_FEAT_PRIVACY))</div>
<div class="line">    {</div>
<div class="line">        /* send next command in sequence */</div>
<div class="line">        HciLeReadResolvingListSize();</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">        hciCoreCb.resListSize = 0;</div>
<div class="line"> </div>
<div class="line">        /* send next command in sequence */</div>
<div class="line">        hciCoreReadMaxDataLen();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md193"></a>
HCI accessor function</h2>
<p>The HCI driver is injected to the <code>CordioBLE</code> class at manufacture.</p>
<p>Given that the <code>CordioBLE</code> class doesn't know which class constructs the driver nor how to construct it, the port provides a function returning a reference to the HCI driver.</p>
<p>This function is in the global namespace, and its signature is:</p>
<div class="fragment"><div class="line">ble::CordioHCIDriver&amp; ble_cordio_get_hci_driver();</div>
</div><!-- fragment --><p><b>Example:</b></p>
<div class="fragment"><div class="line">ble::CordioHCIDriver&amp; ble_cordio_get_hci_driver()</div>
<div class="line">{</div>
<div class="line">    static ble::vendor::target_name::TransportDriver transport_driver(</div>
<div class="line">        /* transport parameters */</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    static ble::vendor::target_name::HCIDriver hci_driver(</div>
<div class="line">        transport_driver, /* other hci driver parameters */</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    return hci_driver;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md194"></a>
Tests</h2>
<p>We bundle Greentea tests with the Cordio port of the <a class="el" href="classBLE.html">BLE</a> API, so the transport driver and validation of Cordio stack initialization both work. You can run these tests with the following command:</p>
<div class="fragment"><div class="line">mbed test -t &lt;toolchain&gt; -m &lt;target&gt; -n mbed-os-features-feature_ble-targets-target_cordio-tests-cordio_hci-driver,mbed-os-features-feature_ble-targets-target_cordio-tests-cordio_hci-transport</div>
</div><!-- fragment --><ul>
<li><code>mbed-os-features-feature_ble-targets-target_cordio-tests-cordio_hci-transport</code>: Ensures that the transport is able to send an HCI reset command and receive the corresponding HCI status event.</li>
<li><code>mbed-os-features-feature_ble-targets-target_cordio-tests-cordio_hci-driver</code>: Runs the whole initialization process, then ensures the HCI driver has properly initialized the Cordio stack.</li>
</ul>
<h2><a class="anchor" id="autotoc_md195"></a>
Tools</h2>
<p>You can use the application <a href="https://github.com/ARMmbed/mbed-os-cordio-hci-passthrough">mbed-os-cordio-hci-passthrough</a> to proxify a Bluetooth controller connected to an Mbed board.</p>
<p>The host sent bytes over the board serial, which the <code>HCITransport Driver</code> forwards. Bytes sent by the controller go back to the host through the board serial.</p>
<p>You can use this application to validate the transport driver and debug the initialization process. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
