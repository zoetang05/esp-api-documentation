<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: Multihoming in MbedOS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2connectivity_2docs_2Multihoming_01-_01Design_01document.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Multihoming in MbedOS</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md10"></a></p>
<h1><a class="anchor" id="autotoc_md11"></a>
Table of contents</h1>
<ol type="1">
<li>Revision history.</li>
</ol>
<ol type="1">
<li>Introduction.<ol type="a">
<li>Overview and background.</li>
</ol>
<ol type="a">
<li>Requirements and assumptions.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>System architecture and high-level design.<ol type="a">
<li>Architecture.</li>
</ol>
<ol type="a">
<li>Component interaction.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Detailed design.<ol type="a">
<li>MbedOS networking class diagram extension proposal.</li>
<li>Simplified LWIP and EMAC.</li>
</ol>
<ol type="a">
<li>LWIPInterface changes.</li>
</ol>
<ol type="a">
<li>EMACInterface and EMAC driver.</li>
</ol>
<ol type="a">
<li>L3IPInterface and L3IP driver.</li>
</ol>
<ol type="a">
<li>Memory manager.</li>
</ol>
<ol type="a">
<li>Network default interface construction.</li>
</ol>
<ol type="a">
<li>Adding interface.</li>
</ol>
<ol type="a">
<li>Removing interface.</li>
</ol>
<ol type="a">
<li>Connecting Ethernet or Wifi.</li>
</ol>
<ol type="a">
<li>Disconnecting Ethernet or Wifi.</li>
</ol>
<ol type="a">
<li>Connecting Cellular.</li>
</ol>
<ol type="a">
<li>Disconnecting Cellular.</li>
</ol>
<ol type="a">
<li>Addressing.</li>
</ol>
<ol type="a">
<li>LWIP IP core.<ol type="i">
<li>EMAC based outgoing traffic for ethernet and wifi.</li>
</ol>
<ol type="i">
<li>PPP based outgoing traffic for cellular.</li>
</ol>
<ol type="i">
<li>EMAC based incoming traffic for ethernet and wifi.</li>
</ol>
<ol type="i">
<li>PPP based incoming traffic for cellular.</li>
</ol>
<ol type="i">
<li>IP Route changes.</li>
</ol>
</li>
</ol>
<ol type="a">
<li>Network stack interface.</li>
</ol>
<ol type="a">
<li>Sockets changes.</li>
</ol>
<ol type="a">
<li>DNS changes.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Usage scenario.</li>
</ol>
<h1><a class="anchor" id="autotoc_md12"></a>
Revision history</h1>
<p>| Revision | Date | Authors | Mbed OS version | Comments |</p>
<p>| 1.0 | 25 September 2018 | Tymoteusz Bloch | 5.11 | Initial revision |</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Introduction</h1>
<h2><a class="anchor" id="autotoc_md14"></a>
Overview and background</h2>
<p>This document refers to mutlihoming for MbedOS ARM CortexM based embedded devices. Multihoming is the way of connecting device to more than one network interface. This can be done in order to increase reliability or performance.</p>
<p>Under normal operating condition embedded ip stack is connected to only one network driver. In many situations , it can be useful to connect an embedded device to multiple networks, to increase reliability (if a one network link fails, data can still be routed through the remaining networks) and to improve performance (depending on the destination, it is more efficient to route through multiple networks ).</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Requirements and assumptions</h2>
<p>To use multihoming embedded device board must be equipped with more than one network interface, driver and physical medium device. It can be a combination of ethernet, wifi, cellular modules as well as the same type multiple devices eg. two ethernet physical devices.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
System architecture and high-level design</h1>
<h2><a class="anchor" id="autotoc_md17"></a>
Architecture</h2>
<p>Mbed OS network functionality is implemented inside <b>features</b> module.</p>
<p>High level view is on picture below</p>
<p><img src="hi_level.png" alt="high_level_architecture" class="inline"/></p>
<p>For connectivity MbedOS uses Netsocket module. It contains :</p>
<ul>
<li>sockets</li>
<li><a class="el" href="classDNS.html">DNS</a></li>
<li>TCP/UDP</li>
<li>network interfaces</li>
<li>IP stacks</li>
<li>glue logic between IP stacks and network interfaces</li>
</ul>
<p>MbedOS support following IP stacks :</p>
<ul>
<li><a class="el" href="classLWIP.html">LWIP</a></li>
<li><a class="el" href="classNanostack.html">Nanostack</a></li>
</ul>
<p>This design refers to only <a class="el" href="classLWIP.html">LWIP</a> multihoming support so <a class="el" href="classNanostack.html">Nanostack</a> will be omitted.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Component interaction</h2>
<p><img src="components.png" alt="components" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md19"></a>
Detailed design</h1>
<h2><a class="anchor" id="autotoc_md20"></a>
MbedOS networking class diagram extension proposal</h2>
<p><img src="class_diagram.png" alt="class_diagram" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md21"></a>
Simplified LWIP and EMAC</h2>
<p><img src="EmacInterface_simple.png" alt="simply_emac" class="inline"/></p>
<p><img src="lwip_simply.png" alt="simply_lwip" class="inline"/> </p><pre class="fragment">NetworkInterface *net;
net = NetworkInterface::get_default_instance();
net-&gt;connect();
</pre><p><b><a class="el" href="classEMACInterface.html#abf11adb7c47186537cf1c7c72f6cece5">EMACInterface::connect</a></b> will call: </p><pre class="fragment">- Stack -&gt; add interface.
- Stack::Interface -&gt;bringup.
</pre><h2><a class="anchor" id="autotoc_md22"></a>
LWIPInterface changes</h2>
<p><a class="el" href="classLWIP.html">LWIP</a> and is a top class responsible for <a class="el" href="classLWIP.html">LWIP</a> network stack implementation in Mbed OS. <b>LWIP/inner Interface</b> class view is shown below. For better readability view is simplified. <br  />
</p>
<p><img src="lwip_class.png" alt="lwip_class" class="inline"/></p>
<p>It's existing <b><a class="el" href="classEMAC.html">EMAC</a> only</b> version.</p>
<p>For clear view all members from <b>LWIP/inner Interface</b> are removed except <b><a class="el" href="classEMAC.html">EMAC</a></b> related ones which are important from multi interface point of view.</p>
<p><img src="lwip_changes_old.png" alt="lwip_changes_old" class="inline"/></p>
<p>Those members are defined in <b>LWIPInterfaceEMAC.cpp</b> module.</p>
<p>To use <b>non <a class="el" href="classEMAC.html">EMAC</a></b> drivers for cellular new members must be add. <b>Lwip/Interface</b> after extension is shown below.</p>
<p><img src="lwip_changes_new.png" alt="lwip_changes_new" class="inline"/></p>
<p>New <b><a class="el" href="classL3IP.html">L3IP</a></b> related members will be defined in <b>LWIPInterfaceL3IP.cpp</b> module.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
EMACInterface and EMAC driver</h2>
<p><img src="EMACInterface.png" alt="EMACInterface" class="inline"/></p>
<p><b><a class="el" href="classEMAC.html">EMAC</a> driver</b> class should be used to abstract low level access to networking hardware All operations receive a <code>void *</code> hw pointer which an <a class="el" href="classEMAC.html">EMAC</a> device provides when it is registered with a stack.</p>
<p>Existing <b><a class="el" href="classEMAC.html">EMAC</a></b> class pure virtual definitions are shown below and must be overrided by target HW dedicated class driver derived from it.</p>
<p><img src="EMAC.png" alt="EMAC" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md24"></a>
L3IPInterface and L3IP driver</h2>
<p><b><a class="el" href="classL3IPInterface.html">L3IPInterface</a></b> is new helper class dedicated to cellular connection. It based on existing <b><a class="el" href="classEMACInterface.html">EMACInterface</a></b> and looks similar to it. However class methods have different implementation eg connect calls <b>lwip::add_l3ip_interface(**) to add the interface instead of **lwip::add_ethernet_interface</b>. Currently the existing interface does not support destruct and remove drivers. So <b>remove/destruct</b> functionality is proposed to implement.</p>
<p><img src="L3IPInterface.png" alt="L3IPInterface" class="inline"/></p>
<p><b><a class="el" href="classL3IP.html">L3IP</a></b> driver abstract class ia also based on <b><a class="el" href="classEMAC.html">EMAC</a></b> class it also looks similar but is bound to cellular driver. <img src="L3IP.png" alt="L3IP" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md25"></a>
Memory manager</h2>
<p>Currently there is memory manager dedicated to ethernet. It does not require changes however should be renamed from <b><a class="el" href="classEMACMemoryManager.html">EMACMemoryManager</a></b> to non confusing generic name like <b><a class="el" href="classNetStackMemoryManager.html">NetStackMemoryManager</a></b>. Also memory buffer <b>emac_mem_buf_t</b> should folow this change to just <b>net_stack_mem_buf_t</b>.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Network default interface construction</h2>
<p>Mbed OS support automated factories for default interface.</p>
<p>It depends on JSON configuration customized for particular target HW.</p>
<p>To instantiate it <b>::get_default_instance</b> must be invoked on user desired interface type.</p>
<p>The top-level <a class="el" href="classNetworkInterface.html">NetworkInterface</a> use the following parameter</p>
<p><b>MBED_CONF_TARGET_NETWORK_DEFAULT_INTERFACE_TYPE</b> for creating proper one :</p>
<ul>
<li>(ETHERNET ) <a class="el" href="classEthInterface.html">EthInterface</a> ::get_default_instance()</li>
<li>(CELLULAR ) CellularBase ::get_default_instance()</li>
<li>(WIFI ) <a class="el" href="classWiFiInterface.html#a70d442535b92e16303d545f85047ce83">WiFiInterface::get_default_instance()</a></li>
<li>(MESH ) <a class="el" href="classMeshInterface.html#a7a2d5734d6bb491b2186a90488ce3d21">MeshInterface::get_default_instance()</a></li>
</ul>
<p>Code for automated construction is in <b>NetwokInterfaceDefaults.cpp</b> module.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Adding interface</h2>
<p>Since automated factory suport creation only one <b>default interface</b>, others must be constructed and added to <a class="el" href="classLWIP.html">LWIP</a> manually.</p>
<p>For <b>ethernet/wifi</b> first new interface, <b><a class="el" href="classEMACInterface.html">EMACInterface</a></b> helper and <b><a class="el" href="classEMAC.html">EMAC</a></b> driver must be instantiated. For this connection types constructors are already implemented </p><pre class="fragment">EthernetInterface(EMAC &amp;emac = EMAC::get_default_instance(),
                  OnboardNetworkStack &amp;stack = OnboardNetworkStack::get_default_instance()) : EMACInterface(emac, stack) { }
</pre><p>or </p><pre class="fragment">OdinWiFiInterface(OdinWiFiEMAC &amp;emac = OdinWiFiEMAC::get_instance(), OnboardNetworkStack &amp;stack = OnboardNetworkStack::get_default_instance());
</pre><p>For cellular the situation is a little bit different due no support any ethernet like interfaces (ethernet,wlan). In this case constructor looks like below and is not yet implemented. This is new code proposal for new clases <a class="el" href="classL3IPInterface.html">L3IPInterface</a> and <a class="el" href="classL3IP.html">L3IP</a>. <br  />
</p>
<pre class="fragment">L3IPInterface(L3IP &amp;l3ip = L3IP::get_default_instance(),OnboardNetworkStack &amp;stack = OnboardNetworkStack::get_default_instance());
</pre><p>Regardless of interface type <a class="el" href="classLWIP.html">LWIP</a> must be informed about new low level interface. This can be done by calling <b>connect()</b> method on proper helper class( <b><a class="el" href="classEMACInterface.html">EMACInterface</a></b> or <b><a class="el" href="classL3IPInterface.html">L3IPInterface</a></b>). Connect adds new network interface and then sets up a connection on <a class="el" href="classLWIP.html">LWIP</a> stack with <b>bringup()</b> method.</p>
<p>First it registers a network interface with the IP stack. Connects <b>EMAC/L3IP</b> layer with the IP stack and initializes all the required infrastructure. This function should be called only once for each available interface.</p>
<p>For <b>ethernet/wifi</b> its already implemented as: </p><pre class="fragment">LWIP::add_ethernet_interface(EMAC &amp;emac, bool default_if, OnboardNetworkStack::Interface **interface_out)
</pre><p>Cellular connection doesn't support it yet. This is new feature. Proposal is shown below </p><pre class="fragment">LWIP::add_l3ip_interface(L3IP &amp;l3ip, bool default_if, OnboardNetworkStack::Interface **interface_out)
</pre><p>Both methods have the same purpose but must differ in implementation due to cellular handles layer 2 differently and doesn't support any ethernet like interfaces (ethernet,wlan) and ARP.</p>
<p>Important part of addition new network interface is configuring <a class="el" href="classLWIP.html">LWIP</a> struct called <b>netif</b>. This is the core part of <a class="el" href="classLWIP.html">LWIP</a>. Simplifed more readable form (removed comments and preprocesors directives) is shown below.</p>
<p><b>netif</b> is a generic data structure used for all lwIP network interfaces. </p><pre class="fragment">struct netif {
struct netif *next;
ip_addr_t ip_addr;
ip_addr_t netmask;
ip_addr_t gw;
ip_addr_t ip6_addr[LWIP_IPV6_NUM_ADDRESSES];
u8_t ip6_addr_state[LWIP_IPV6_NUM_ADDRESSES]; 
u32_t ip6_addr_valid_life[LWIP_IPV6_NUM_ADDRESSES];
u32_t ip6_addr_pref_life[LWIP_IPV6_NUM_ADDRESSES];
netif_input_fn input;
netif_output_fn output;
netif_linkoutput_fn linkoutput;
netif_output_ip6_fn output_ip6;
netif_status_callback_fn status_callback;
netif_status_callback_fn link_callback;
netif_status_callback_fn remove_callback;
void *state;    
u8_t ip6_autoconfig_enabled;    

const char*  hostname;
u16_t chksum_flags;
u16_t mtu;  
u8_t hwaddr_len;    
u8_t hwaddr[NETIF_MAX_HWADDR_LEN];
u8_t flags;
char name[2];
u8_t num;
netif_igmp_mac_filter_fn igmp_mac_filter;
netif_mld_mac_filter_fn mld_mac_filter;
u8_t *addr_hint;
u16_t loop_cnt_current;
};
</pre><p>Existing member <b>name[2]</b> can be used to bind <b>netif</b> to socket. It is get with <b><a class="el" href="classEMAC.html">EMAC</a></b> class member <b>get_ifname</b> from hw driver and have unique 2 char in length name.</p>
<p>Currently following names exists: </p><pre class="fragment">"en"  ethernet  
"wl"  wifi
"l6"  mesh
"lo"  loopback
"pp"  ppp
</pre><p> etc. For cellular it can be "cl"</p>
<p>Two character name string is concatenated with 8 bit value containing index which is incremented on each netif addition eg <b>"wl0"</b>. If no multiple interfaces of one type <b>"en0", "en1","en2"</b> ... exists, <b>name[2]</b> member is sufficient to distinguish between different interface types like** wifi, ethernet** and <b>cellular</b>.</p>
<p>This <b>netif</b> struct uses handlers passed by </p><pre class="fragment">-   (emac/l3ip)_low_level_output
-   (emac/l3ip)_input
-   (emac/l3ip)_state_change 
-   (emac/l3ip)_igmp_mac_filter  
-   (emac/l3ip)_mld_mac_filter 
-   (emac/l3ip)_if_init 
</pre><p>for bounding </p><pre class="fragment">-received data from driver  to LWIP input handler
-LWIP outgoing data to driver for tramsmiting
-status callback from device driver
-filters settings
</pre><p>From our point of view important function pointers are: </p><pre class="fragment">-netif_output_fn output  
-netif_linkoutput_fn linkoutput 
</pre><p>From <a class="el" href="classLWIP.html">LWIP</a> documentation we can read.</p>
<p><b>"output"</b> is called by the IP module when it wants to send a packet on the interface. It first resolves the hardware address, then sends the packet. For ethernet physical layer, this is usually <b>etharp_output()</b>.</p>
<p><b>"linkoutput"</b> is called by <b>ethernet_output()</b> when it wants to send a packet on the interface. This function outputs the pbuf as-is on the link medium.</p>
<p>ARP in used in ethernet and wifi but for Cellular modem <b>output</b> must be bound to low level write handler. In case of cellular this is done by <a class="el" href="classPPP.html">PPP</a> over serial module (<b>PPPOS</b>) and currently is bound to <b>pppos_netif_output</b> with proper IP4/IP6 flag. This writes data to cellular modem UART based file handler. Due to different implementation of <b>PPPOS</b> <b>"linkoutput"</b> is not used for cellular.</p>
<p>To add all params to <b>new netif</b> following function must be called. This is the part of <a class="el" href="classLWIP.html">LWIP</a> stack.</p>
<p>struct netif * netif_add(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Removing interface</h2>
<p>To remove interface proper method must be called</p>
<pre class="fragment">LWIP::remove_L3IP_interface(OnboardNetworkStack::Interface *interface)
</pre><p>Currently the <b><a class="el" href="classEMACInterface.html">EMACInterface</a></b> does not support remove and <b><a class="el" href="classEMAC.html">EMAC</a></b> drivers do not support destruct however implementation of remove/destruct functionality is considered for <a class="el" href="classEMAC.html">EMAC</a> interface/drivers.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Connecting Ethernet or Wifi</h2>
<p><b><a class="el" href="classEMACInterface.html">EMACInterface</a></b> is constructed with <b><a class="el" href="classEMAC.html">EMAC</a></b> driver and (default) onboard network stack.</p>
<p>When <b><a class="el" href="classEMACInterface.html#abf11adb7c47186537cf1c7c72f6cece5">EMACInterface::connect()</a></b> is called it calls the <a class="el" href="classLWIP.html">LWIP</a>::<b>add_ethernet_interface()</b> from lwip and after that lwip <b>bringup()</b> which activates the interface on lwip.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Disconnecting Ethernet or Wifi</h2>
<p><a class="el" href="classEMACInterface.html">EMACInterface</a>::<b>disconnect()</b> will bring the interface down.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Connecting Cellular</h2>
<p><b><a class="el" href="classL3IPInterface.html">L3IPInterface</a></b> is constructed with <b><a class="el" href="classL3IP.html">L3IP</a></b> driver and (default) onboard network stack.</p>
<p>When <b><a class="el" href="classL3IPInterface.html#a8e4668c242951c1336b8bff2a4bf19f9">L3IPInterface::connect()</a></b> is called it will call the <a class="el" href="classLWIP.html">LWIP</a>::<b>add_l3ip_interface()</b> from lwip and after that lwip <b>bringup()</b> which activates the interface on lwip as in <a class="el" href="classEMACInterface.html">EMACInterface</a>.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Disconnecting Cellular</h2>
<p><b><a class="el" href="classL3IPInterface.html#acbfe638d626c1e0e8e82848f3cae8e96">L3IPInterface::disconnect()</a></b> will bring the interface down.</p>
<p>Its destructor will call the <a class="el" href="classLWIP.html">LWIP</a>::<b>L3IP_remove_interface()</b> and remove itself from lwip/lwip **netif*.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Addressing</h2>
<p>IP address can provided as <b>LWIP::Interface::bringup()</b> parameter as a static IP or DHCP. If DHCP flag is true than address is set ansynchronously as negotiation finish. Currently static address change after <b>LWIP::Interface::bringup()</b> is not used but there is proper setting member implemented for DHCP so it can be used for static IP change. This is open issue.</p>
<p>For <b><a class="el" href="classL3IPInterface.html">L3IPInterface</a></b> IPv6 unique identifier for construction link local address can be used similarly as in <a class="el" href="classPPP.html">PPP</a>. Both SLAAC and DHCP can be used. This is also open issue.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
LWIP IP core</h2>
<p>All outgoing packets regardles of TCP,UDP or RAW are procesed by <br  />
 **ip(4\6)_output_if_opt_src** in <a class="el" href="classLWIP.html">LWIP</a> IP module.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
EMAC based outgoing traffic for ethernet and wifi</h3>
<p>For this interface **\ip_output_if_opt_src** calls <b>netif-&gt;output</b> bound for low level ARP (ethernet) and proceed <b>netif-&gt;linkoutput</b> bound for ethernet output driver function.</p>
<p><img src="outgoing_eth.png" alt="outgoing_eth" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md36"></a>
PPP based outgoing traffic for cellular</h3>
<p>For cellular **\ip_output_if_opt_src** calls <b>netif-&gt;output</b> bound for low level ARP (ethernet) or <a class="el" href="classPPP.html">PPP</a> (cellular). <img src="outgoing_ppp.png" alt="outgoing_ppp" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md37"></a>
EMAC based incoming traffic for ethernet and wifi</h3>
<p><img src="incoming_emac.png" alt="incoming_emac" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md38"></a>
PPP based incoming traffic for cellular</h3>
<p><img src="incoming_ppp.png" alt="incoming_ppp" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md39"></a>
IP Route changes</h3>
<p>This <a class="el" href="classLWIP.html">LWIP</a> IP netif selection must be extended for routing to a specific <b>netif</b> instead <b>default one</b>.</p>
<p>Original <b>ip4_route</b> finds the appropriate network interface for a given IP address. It searches the list of network interfaces linearly. A match is found if the masked IP address of the network interface equals the masked IP address given to the function.</p>
<p>Passed param dest is the destination IP address for which to find the route New paremeter <b>interface_name</b> will be add to origin <b>ip4_route</b> for improved selection of desired <b>netif</b>.</p>
<p>Function returns the proper <b>netif</b> responsible for sending data to reach dest </p><pre class="fragment">struct netif * ip4_route(const ip4_addr_t *dest)
{
 struct netif *netif;

#if LWIP_MULTICAST_TX_OPTIONS
/* Use administratively selected interface for multicast by default */
if (ip4_addr_ismulticast(dest) &amp;&amp; ip4_default_multicast_netif) {
 return ip4_default_multicast_netif;
 }
#endif /* LWIP_MULTICAST_TX_OPTIONS */

/* iterate through netifs */
for (netif = netif_list; netif != NULL; netif = netif-&gt;next) {
/* is the netif up, does it have a link and a valid address? */
if (netif_is_up(netif) &amp;&amp; netif_is_link_up(netif) &amp;&amp; !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
  /* network mask matches? */
  if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
    /* return netif on which to forward IP packet */
    return netif;
  }
  /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
  if (((netif-&gt;flags &amp; NETIF_FLAG_BROADCAST) == 0) &amp;&amp; ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
    /* return netif on which to forward IP packet */
    return netif;
  }
}
}

#if LWIP_NETIF_LOOPBACK &amp;&amp; !LWIP_HAVE_LOOPIF
 /* loopif is disabled, looopback traffic is passed through any netif */
if (ip4_addr_isloopback(dest)) {
    /* don't check for link on loopback traffic */
    if (netif_default != NULL &amp;&amp; netif_is_up(netif_default)) {
      return netif_default;
 }
    /* default netif is not up, just use any netif for loopback traffic */
    for (netif = netif_list; netif != NULL; netif = netif-&gt;next) {
     if (netif_is_up(netif)) {
     return netif;
    }
 }
 return NULL;
 }
#endif /* LWIP_NETIF_LOOPBACK &amp;&amp; !LWIP_HAVE_LOOPIF */

#ifdef LWIP_HOOK_IP4_ROUTE_SRC
 netif = LWIP_HOOK_IP4_ROUTE_SRC(dest, NULL);
if (netif != NULL) {
    return netif;
}
#elif defined(LWIP_HOOK_IP4_ROUTE)
 netif = LWIP_HOOK_IP4_ROUTE(dest);
if (netif != NULL) {
 return netif;
 }
#endif

if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
  ip4_addr_isany_val(*netif_ip4_addr(netif_default))) {
/* No matching netif found and default netif is not usable.
   If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
  ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
IP_STATS_INC(ip.rterr);
MIB2_STATS_INC(mib2.ipoutnoroutes);
return NULL;
}

return netif_default;
}
</pre><h2><a class="anchor" id="autotoc_md40"></a>
Network stack interface</h2>
<p>For multiple <b>netif's</b> there is need to get <a class="el" href="classDNS.html">DNS</a> and IP addresses for an <b>interface_name</b></p>
<p>Currently <a class="el" href="classLWIP.html">LWIP</a> class members has no such parameter </p><pre class="fragment">get_ip_address()
get_dns_server(int index, SocketAddress *address)
</pre><p>Also there is only pointer to one <b>netif</b>. </p><pre class="fragment">const struct netif *netif
</pre><p>So single netif should be replaced with array of netif pointers and members above must support to get IP and <a class="el" href="classDNS.html">DNS</a> from proper netif instance. Therefore new parameter "interface_name" should be added to <b>get_dns_server</b> and new member <b>get_ip_address_if</b> must be implemented to the <b><a class="el" href="classNetworkInterface.html">NetworkInterface</a></b> class.</p>
<pre class="fragment">    get_ip_address_if(const char *interface_name)
    get_dns_server(int index, SocketAddress *address, const char *interface_name)
</pre><p>From multihoming point of view it is desirable to get interface name and select any interface to default one at runtime. Therefore following new members need to be implemented </p><pre class="fragment">    get_interface_name(char *interface_name)
    set_as_default()
</pre><p>Netif <b>interface_name</b> should be added also to <br  />
 </p><pre class="fragment">   dns_setserver(u8_t numdns, const ip_addr_t *dnsserver,const char *interface_name);
</pre><h1><a class="anchor" id="autotoc_md41"></a>
Sockets changes</h1>
<p>For multihoming its needed to bind socket to desired network interface. To perform this new socket option must be add for socket class.</p>
<p>Member for <a class="el" href="classLWIP.html">LWIP</a> stack specific socket option settings already exist in <a class="el" href="classLWIP.html">LWIP</a> class. New option for socket binding to netif must be implemented inside:</p>
<pre class="fragment">    nsapi_error_t LWIP::setsockopt(nsapi_socket_t handle, int level, int optname, const void *optval, unsigned optlen)
</pre><p>New socket option enum <b>NSAPI_BIND_NETIF</b> must be added.</p>
<p><a class="el" href="classSocket.html">Socket</a> options after changes. </p><pre class="fragment">typedef enum nsapi_socket_option {
NSAPI_REUSEADDR,         /*!&lt; Allow bind to reuse local addresses */
NSAPI_KEEPALIVE,         /*!&lt; Enables sending of keepalive messages */
NSAPI_KEEPIDLE,          /*!&lt; Sets timeout value to initiate keepalive */
NSAPI_KEEPINTVL,         /*!&lt; Sets timeout value for keepalive */
NSAPI_LINGER,            /*!&lt; Keeps close from returning until queues empty */
NSAPI_SNDBUF,            /*!&lt; Sets send buffer size */
NSAPI_RCVBUF,            /*!&lt; Sets recv buffer size */
NSAPI_ADD_MEMBERSHIP,    /*!&lt; Add membership to multicast address */
NSAPI_DROP_MEMBERSHIP,   /*!&lt; Drop membership to multicast address */
NSAPI_BIND_NETIF,        /*!&lt; Biid nefit to socket */
} nsapi_socket_option_t;
</pre><p><a class="el" href="classLWIP.html">LWIP</a> specific socket is shown below </p><pre class="fragment">struct mbed_lwip_socket {
    bool in_use;

    struct netconn *conn;
    struct netbuf *buf;
    u16_t offset;

    void (*cb)(void *);
    void *data;

    // Track multicast addresses subscribed to by this socket
    nsapi_ip_mreq_t *multicast_memberships;
    uint32_t         multicast_memberships_count;
    uint32_t         multicast_memberships_registry;
};
</pre><p>New binding option should be placed into <b>netconn</b> struct. Descriptor for <b>netconn</b> is shown below.</p>
<pre class="fragment">    struct netconn {
                    enum netconn_type type;
                    enum netconn_state state;
                    union {
                            struct ip_pcb  *ip;
                            struct tcp_pcb *tcp;
                            struct udp_pcb *udp;
                            struct raw_pcb *raw;
                          } pcb; 
                    err_t last_err;
                    sys_sem_t op_completed;
                    sys_mbox_t recvmbox;
                    sys_mbox_t acceptmbox;
                    int socket;
                    s32_t send_timeout; 
                    int recv_timeout;
                    int recv_bufsize;
                    int recv_avail;
                    s16_t linger;
                    u8_t flags;
                    size_t write_offset;
                    struct api_msg *current_msg;
                    netconn_callback callback;
                    };
</pre><p><a class="el" href="classLWIP.html">LWIP</a> selects the proper netif on IP layer using <b>ip_route</b>.</p>
<p>Currently it uses only ip address as input parameter so choice is based on ip address only. To extend choice ctiteria also to interface index <b>ip_route</b> must be modified and must take desired <b>interface_name</b> as second argument. Therefore new member with information about <b>netif interface_name</b> bound to current socket should be placed in the common part of all PCB types.</p>
<pre class="fragment">    #define IP_PCB \
    ip_addr_t local_ip; \
    ip_addr_t remote_ip; \
    u8_t so_options;     \
    u8_t tos;            \
    u8_t ttl             \
    IP_PCB_ADDRHINT      \
    const char* interface_name -new member     
</pre><p>New member <b>char* interface_name</b> should be add for binding socket to netif.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
DNS changes</h2>
<p>Currently in Nsapi_dns module there is only one array for 5 <a class="el" href="classDNS.html">DNS</a> server addresses. </p><pre class="fragment"> static nsapi_addr_t dns_servers[DNS_SERVERS_SIZE] = {
    {NSAPI_IPv4, {8, 8, 8, 8}},                             // Google
    {NSAPI_IPv4, {209, 244, 0, 3}},                         // Level 3
    {NSAPI_IPv4, {84, 200, 69, 80}},                        // DNS.WATCH
    {NSAPI_IPv6, {0x20,0x01, 0x48,0x60, 0x48,0x60, 0,0,     // Google
                  0,0, 0,0, 0,0, 0x88,0x88}},
    {NSAPI_IPv6, {0x20,0x01, 0x16,0x08, 0,0x10, 0,0x25,     // DNS.WATCH
                  0,0, 0,0, 0x1c,0x04, 0xb1,0x2f}},
};
</pre><p> It would be desirable to add storage for interface specific <a class="el" href="classDNS.html">DNS</a> server addresses.</p>
<p>It can be done as below. </p><pre class="fragment">static nsapi_addr_t dns_servers[NETIF_INDEX][DNS_SERVERS_SIZE]
</pre><p>Add interface name as option to <a class="el" href="classDNS.html">DNS</a> query</p>
<p>To resolve IP address Netsocket module uses following functions </p><pre class="fragment">gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)
nsapi_dns_query(NetworkStack *stack, const char *host, SocketAddress *address, nsapi_version_t version)
</pre><p>Query above uses only single dns_servers array described before. So it is also desired to add interface_name. </p><pre class="fragment">gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)
nsapi_dns_query(NetworkStack *stack, const char *host, SocketAddress *address, nsapi_version_t version)
</pre><p>Second one <b>nsapi_dns_query</b> finally calls <b>get_dns_server</b> descirbed before. It has new parameter <b>interface_name</b> for proper <b>netif</b> selecting. So it would be logical to add also <b>interface_name</b> also to:</p>
<pre class="fragment">DNS::gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version,const char* interface_name)
nsapi_dns_query(NetworkStack *stack, const char *host, SocketAddress *address, nsapi_version_t version, const char* interface_name)
</pre><p>If async <a class="el" href="classDNS.html">DNS</a> query is used therefore UDP socket created for this purpose must be assigned for proper interface. <br  />
</p>
<p>To perform this following <a class="el" href="classUDPSocket.html">UDPSocket</a> base class member </p><pre class="fragment">InternetSocket::setsockopt(int level, int optname, const void *optval, unsigned optlen) 
</pre><p>is used with parameters: </p><pre class="fragment">- optname  NSAPI_BIND_NETIF
- optval   netif name
</pre><p>It finally calls stack specific implementation for socket option setting. <br  />
</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Usage scenario</h1>
<p>Currently Mbed OS can construct only one <b>default</b> interface.</p>
<p>Its type depends on configuration file and <b>MBED_CONF_TARGET_NETWORK_DEFAULT_INTERFACE_TYPE</b> value.</p>
<p>Example of default network init code is shown below </p><pre class="fragment">NetworkInterface *net;
net = NetworkInterface::get_default_instance();
net-&gt;connect();
</pre><p>If it's set to ETHERNET following code constructs <b><a class="el" href="classEthInterface.html">EthInterface</a></b> for ethernet <a class="el" href="classEMAC.html">EMAC</a>.</p>
<p>If is set to WIFI <b><a class="el" href="classWiFiInterface.html">WiFiInterface</a></b> instance is constructed.</p>
<p>Similarly if type is CELLULAR <b>EasyCellularConnection</b> instance is created.</p>
<p>Second or third interface can be added manually </p><pre class="fragment">NetworkInterface *wifi_net;
wifi_net = WiFiInterface::get_target_default_instance();
wifi_net-&gt;connect();
</pre><p>or </p><pre class="fragment">NetworkInterface *cellular_net;
cellular_net = EasyCellularConnection::get_target_default_instance();
cellular_net-&gt;connect();
</pre><p>To construct network instance both Ethernet and WiFi uses <a class="el" href="classEMAC.html">EMAC</a> and <a class="el" href="classEMACInterface.html">EMACInterface</a> internally.</p>
<p>IP layer 3 interface can be created following way: <br  />
</p>
<p><a class="el" href="classNetworkInterface.html">NetworkInterface</a> *l3interface; l3interface =new <a class="el" href="classL3IPInterface.html">L3IPInterface</a>(<a class="el" href="classL3IP.html#aeb1d1003f68026ae2f6c18fb252c674d">L3IP::get_default_instance()</a>, <a class="el" href="classOnboardNetworkStack.html#acdbfd4a3dce5e74978eccb6090e0fe91">OnboardNetworkStack::get_default_instance()</a>); l3interface-&gt;connect(); </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
