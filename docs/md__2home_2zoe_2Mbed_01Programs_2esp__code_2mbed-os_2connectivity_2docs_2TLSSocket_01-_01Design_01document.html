<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: TLSSocket - design document</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2connectivity_2docs_2TLSSocket_01-_01Design_01document.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">TLSSocket - design document</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md54"></a></p>
<h1><a class="anchor" id="autotoc_md55"></a>
Overview and background</h1>
<p>This document describes the design of the TLSSocket and DTLSSocket classes, which provide an interface for an Mbed OS user to create TLS connections over a TCP socket or DTLS over a UDP socket.</p>
<p>Mbed OS provides two different implementations for TLS sockets; Mbed TLS based (default) or offloaded TLS socket when used network stack (for example, a cellular modem target driver) supports it.</p>
<p>This class greatly simplifies the use of TLS but limits itself to only one use case. This design limitation is accepted as other users can continue using Mbed TLS API directly. Mbed TLS based TLSSocket also exposes internal Mbed TLS structures allowing use of Mbed TLS API to configure the underlying library.</p>
<p>DTLSSocket shares most of its functionality with TLSSocket (via <code>TLSSocketWrapper</code> class), just using UDP instead of TCP as transport socket and handling connection differently.</p>
<p>The high-level goal is to demonstrate that secure connections are not hard to do.</p>
<h1><a class="anchor" id="autotoc_md56"></a>
Design limitations</h1>
<p>The following design limitations exist in the current design of TLSSocket:</p>
<p>Mbed TLS based TLSSocket:</p>
<ul>
<li><code>TLSSocket::connect()</code> is always blocking.</li>
<li>Can only use server and client certificates through <code>set_root_ca_cert()</code> and <code>set_client_cert_key()</code> methods. For other use cases, internal Mbed TLS structures are exposed.</li>
<li>No PSK mode.</li>
</ul>
<p>Offloaded vs. Mbed TLS based TLSSocket:</p>
<ul>
<li>For offloaded TLS socket, <code>set_root_ca_cert()</code> and <code>set_client_cert_key()</code> must be called after <code>TLSSocket::open()</code> and before <code>TLSSocket::connect()</code>.</li>
<li>Offloaded TLS socket API does not support all Mbed TLS based TLSSocket methods, but common ones (in other words, <code>open()</code>, <code>connect()</code>, <code>close()</code> and setting certficates) use the same API.</li>
</ul>
<h1><a class="anchor" id="autotoc_md57"></a>
System architecture and high-level design</h1>
<p>The Mbed TLS based secure socket consists of four classes:</p>
<ul>
<li><code>TLSSocketWrapper</code>, which handles initialization of TLS library, does the TLS handsake and takes any <a class="el" href="classSocket.html">Socket</a> as a transport.</li>
<li><code>TLSSocket</code>, which inherits TLSSocketWrapper, has TCP socket as a transport and adds <code>connect(char *hostname)</code> for initiating the TCP and TLS handshakes at one call.</li>
<li><code>DTLSSocketWrapper</code>, which inherits from TLSSocketWrapper and adds a few auxiliary functions.</li>
<li><code>DTLSSocket</code>, which inherits DTLSSocketWrapper, has UDP socket as a transport and adds <code>connect(char *hostname)</code> for initiating the UDP and DTLS handshakes at one call.</li>
</ul>
<div class="fragment"><div class="line">       ,--------------.</div>
<div class="line">       |Socket        |</div>
<div class="line">       |--------------|</div>
<div class="line">       |--------------|</div>
<div class="line">       |int connect();|</div>
<div class="line">       |int recv();   |</div>
<div class="line">       |int send();   |</div>
<div class="line">       `--------------&#39;</div>
<div class="line">               |</div>
<div class="line">               |</div>
<div class="line">,-----------------------------.</div>
<div class="line">|TLSSocketWrapper             |</div>
<div class="line">|-----------------------------|</div>
<div class="line">|Socket *transport;           |</div>
<div class="line">|-----------------------------|</div>
<div class="line">|TLSSocketWrapper(*transport);|</div>
<div class="line">|int set_root_ca_cert(...);   |</div>
<div class="line">|void set_hostname(...);      |</div>
<div class="line">|int do_handshake();          |</div>
<div class="line">`-----------------------------&#39;</div>
<div class="line">               |______________________________</div>
<div class="line">               |                              |</div>
<div class="line">               |               ,----------------------------.</div>
<div class="line">               |               |DTLSSocketWrapper           |</div>
<div class="line">               |               |----------------------------|</div>
<div class="line">               |               |timer-related functions     |</div>
<div class="line">               |               `----------------------------&#39;</div>
<div class="line">               |                               |</div>
<div class="line">,----------------------------. ,----------------------------.</div>
<div class="line">|TLSSocket                   | |DTLSSocket                  |</div>
<div class="line">|----------------------------| |----------------------------|</div>
<div class="line">|TCPSocket transport         | |UDPSocket transport         |</div>
<div class="line">|----------------------------| |----------------------------|</div>
<div class="line">|int connect(char *hostname);| |int connect(char *hostname);|</div>
<div class="line">`----------------------------&#39; `----------------------------&#39;</div>
</div><!-- fragment --><p>Offloaded TLS socket:</p>
<ul>
<li><code>TLSSocket</code> <br  />
 Extends the TCP socket with certicate and key setter methods and internally handles TLS socket control to network stack using offload TLS socket setsockopt() settings.</li>
</ul>
<div class="fragment"><div class="line">       ,--------------.</div>
<div class="line">       |TCPSocket     |</div>
<div class="line">       |--------------|</div>
<div class="line">       |--------------|</div>
<div class="line">       |int connect();|</div>
<div class="line">       |int recv();   |</div>
<div class="line">       |int send();   |</div>
<div class="line">       `--------------&#39;</div>
<div class="line">               |</div>
<div class="line">               |</div>
<div class="line">,----------------------------.        ,-----------------------------.</div>
<div class="line">|TLSSocket                   |        |NetworkStack implementation  |</div>
<div class="line">|----------------------------|        |-----------------------------|</div>
<div class="line">|----------------------------| -----&gt; |-----------------------------|</div>
<div class="line">|int set_root_ca_cert(...);  |        |nsapi_error_t setsockopt(...)|</div>
<div class="line">`----------------------------&#39;        `-----------------------------&#39;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md58"></a>
High-level design goal 1: Abstract Socket API</h2>
<p>Mbed TLS based secure socket both uses <code><a class="el" href="classSocket.html">Socket</a></code> interface as its transport layer and implements it. This makes it transport independent, and there is no direct dependency to the IP stack.</p>
<p>The offloaded secure socket shares the same API as Mbed TLS based TLSSocket as much as possible. This API has no dependency on Mbed TLS APIs.</p>
<p>When TLSSocket implements the <a class="el" href="classSocket.html">Socket</a> API, it can be used instead of TCP connection in any Mbed OS library. For example, the MQTT library is made secure without any code changes: <a href="https://github.com/coisme/Mbed-to-Azure-IoT-Hub/tree/new-TLSSocket">https://github.com/coisme/Mbed-to-Azure-IoT-Hub/tree/new-TLSSocket</a></p>
<p>The <code>DTLSSocket</code> class implements TLS handshake for <a class="el" href="classUDPSocket.html">UDPSocket</a>.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
High-level design goal 2: Only certificate-based authentication</h2>
<p>The aim is to first support only certificate-based authentication, so we implement only <code>set_root_ca_cert()</code> and <code>set_client_cert_key()</code> functions. Later on, different types of authentication methods can be added.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
High-level design goal 3: Support both blocking and nonblocking operations</h2>
<p>Because Mbed TLS already works with both socket types, we can create <code>TLSSocketWrapper</code>, which handles both types as well.</p>
<p>Functions <code>set_blocking()</code> and <code>set_timeout()</code> just pass the information for underlying transport socket. Extra handling on the TLS state machine is not required.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
High-level design goal 4: Expose Mbed TLS structures (Mbed TLS secure socket only)</h2>
<p>Exposing the Mbed TLS configuration structures allows you to configure the underlying TLS instance using Mbed TLS API. This allows greater usability because TLSSocket is not limited to only one use case.</p>
<p>Also, configuration structures can be shared between sockets, which leads to RAM savings. Then, two or more TLSSockets are used with the same parameters.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
System architecture and component interaction</h2>
<p><em>Description and diagrams showing overall architecture of how the above-mentioned components/resources interface with each other.</em></p>
<h1><a class="anchor" id="autotoc_md63"></a>
Detailed design</h1>
<p><em>This section provides detailed design on implementation of components/modules mentioned in the high-level design section.</em></p>
<h2><a class="anchor" id="autotoc_md64"></a>
Detailed design for abstract socket API</h2>
<p>The Mbed OS <a href="https://github.com/ARMmbed/mbed-os/blob/master/connectivity/netsocket/Socket.h">Socket interface</a> is an abstract C++ inteface that follows the POSIX socket API.</p>
<h3><a class="anchor" id="autotoc_md65"></a>
Receiving and sending data from Mbed TLS</h3>
<p>Mbed TLS based secure socket:</p>
<p><code>TLSSocketWrapper</code> contains static wrappers <code>ssl_recv()</code> and <code>ssl_send()</code> functions, which are registered to the Mbed TLS library in <code><a class="el" href="ssl_8h.html#a8b7442420aef7f1a76fa8c5336362f9e" title="Set the underlying BIO callbacks for write, read and read-with-timeout.">mbedtls_ssl_set_bio()</a></code> call.</p>
<p>These functions then call the transport socket's <code><a class="el" href="classSocket.html#aebb3503269cc3f83a4418d7086c30e9d">Socket::send()</a></code> and <code><a class="el" href="classSocket.html#a17523395673c60f20ac525efcb57548c">Socket::recv()</a></code> calls. Error codes pass through, except <code>NSAPI_ERROR_WOULD_BLOCK</code>, which is translated to <code>MBEDTLS_ERR_SSL_WANT_WRITE</code> or <code>MBEDTLS_ERR_SSL_WANT_READ</code>.</p>
<p>Offloaded secure socket:</p>
<p>When <code>TLSSocket::connect()</code> marks a socket as a secure socket in the network stack, the network stack must handle <code><a class="el" href="socket__api_8h.html#a8e8d6315f44d135a08ae9d7d2c7e6cd1" title="Send data via a connected socket by client.">socket_send()</a></code> and <code><a class="el" href="socket__api_8h.html#a214d3be1d867315bf7e144dc6a796f99" title="A function to read received data buffer from a socket,.">socket_recv()</a></code>. In other words, in external modem cases, these methods send secure socket specific send/receive commands to the modem.</p>
<h3><a class="anchor" id="autotoc_md66"></a>
Providing the Socket API</h3>
<p>Mbed TLS based secure socket:</p>
<div class="fragment"><div class="line">virtual nsapi_error_t close();</div>
</div><!-- fragment --><p>This destroys the memory allocated by the TLS library. It also closes the transport socket, unless <code>TLSSocketWrapper::keep_transport_open()</code> has been called earlier.</p>
<div class="fragment"><div class="line">virtual nsapi_error_t connect(const SocketAddress &amp;address);</div>
</div><!-- fragment --><p>This initiates the TCP/UDP connection and continues to the TLS hanshake.</p>
<p>This is currently forced to blocking mode.</p>
<div class="fragment"><div class="line">virtual nsapi_size_or_error_t send(const void *data, nsapi_size_t size);</div>
<div class="line">virtual nsapi_size_or_error_t recv(void *data, nsapi_size_t size);</div>
<div class="line">virtual nsapi_size_or_error_t sendto(const SocketAddress &amp;address, const void *data, nsapi_size_t size);</div>
<div class="line">virtual nsapi_size_or_error_t recvfrom(SocketAddress *address, void *data, nsapi_size_t size);</div>
</div><!-- fragment --><p>These work as expected, but <code><a class="el" href="classSocketAddress.html">SocketAddress</a></code> parameters are ignored. TLS connection can't change the peer. Also, <code>recvfrom()</code> call doesn't set the peer address.</p>
<p>Mbed TLS error codes <code>MBEDTLS_ERR_SSL_WANT_READ</code> and <code>MBEDTLS_ERR_SSL_WANT_WRITE</code> are translated to <code>NSAPI_ERROR_WOULD_BLOCK</code> before passing to the user.</p>
<p><code>MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY</code> is ignored, and zero is returned to the user (connection closed). Other error codes pass through.</p>
<div class="fragment"><div class="line">virtual nsapi_error_t bind(const SocketAddress &amp;address);</div>
<div class="line">virtual void set_blocking(bool blocking);</div>
<div class="line">virtual void set_timeout(int timeout);</div>
<div class="line">virtual void sigio(mbed::Callback&lt;void()&gt; func);</div>
<div class="line">virtual nsapi_error_t setsockopt(int level, int optname, const void *optval, unsigned optlen);</div>
<div class="line">virtual nsapi_error_t getsockopt(int level, int optname, void *optval, unsigned *optlen);</div>
</div><!-- fragment --><p>These are passed through to transport socket.</p>
<div class="fragment"><div class="line">virtual Socket *accept(nsapi_error_t *error = NULL);</div>
<div class="line">virtual nsapi_error_t listen(int backlog = 1);</div>
</div><!-- fragment --><p>These are returning <code>NSAPI_ERROR_UNSUPPORTED</code> because you can't set TLS socket to listening mode.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
Detailed design for certificate-based authentication</h2>
<p>TLSSocket API provides the following API to set server certificate. For Mbed TLS secure socket, the <code>TLSSocketWrapper</code> class implements this API. You can use either a BASE64 formatted PEM certificate, or binary DER certificates. The latter just assumes <code>root_ca_pem</code> or <code>client_cert_pem</code> to be standard C string and counts its length and passes to method, which takes just <code>void*</code> and <code>len</code>.</p>
<div class="fragment"><div class="line">/** Sets the certification of Root CA.</div>
<div class="line"> *</div>
<div class="line"> * @param root_ca Root CA Certificate in any mbed-TLS supported format.</div>
<div class="line"> * @param len     Length of certificate (including terminating 0 for PEM).</div>
<div class="line"> */</div>
<div class="line">nsapi_error_t TLSSocketWrapper::set_root_ca_cert(const void *root_ca, size_t len);</div>
<div class="line"> </div>
<div class="line">/** Sets the certification of Root CA.</div>
<div class="line"> *</div>
<div class="line"> * @param root_ca_pem Root CA Certificate in PEM format</div>
<div class="line"> */</div>
<div class="line">nsapi_error_t TLSSocketWrapper::set_root_ca_cert(const char *root_ca_pem);</div>
</div><!-- fragment --><p>If client authentication is required, the following API allows you to set the client certificate and private key:</p>
<div class="fragment"><div class="line">/** Sets client certificate, and client private key.</div>
<div class="line"> *</div>
<div class="line"> * @param client_cert Client certification in any mbed-TLS supported format.</div>
<div class="line"> * @param client_private_key Client private key in PEM format.</div>
<div class="line"> */</div>
<div class="line">nsapi_error_t TLSSocketWrapper::set_client_cert_key(const void *client_cert_pem, size_t client_cert_len,</div>
<div class="line">                                                    const void *client_private_key_pem, size_t client_private_key_len);</div>
<div class="line"> </div>
<div class="line">/** Sets client certificate, and client private key.</div>
<div class="line"> *</div>
<div class="line"> * @param client_cert_pem Client certification in PEM format.</div>
<div class="line"> * @param client_private_key Client private key in PEM format.</div>
<div class="line"> */</div>
<div class="line">nsapi_error_t TLSSocketWrapper::set_client_cert_key(const char *client_cert_pem, const char *client_private_key_pem);</div>
</div><!-- fragment --><p>Certificate is then passed unmodified to the <code>mbedtls_x509_crt_parse()</code> function.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
Detailed design for support of both blocking and nonblocking operations (Mbed TLS secure socket only)</h2>
<p><code>send()</code> and <code>receive()</code> methods do not need to know whether the underlying socket is in blocking mode because Mbed OS return values are enough to tell that.</p>
<p>Data path when the application sends data to the TLS socket:</p>
<ol type="1">
<li>The application calls <code>TLSSocketWrapper::send()</code> function.</li>
</ol>
<ol type="1">
<li>Which calls the <code><a class="el" href="ssl_8h.html#a5bbda87d484de82df730758b475f32e5" title="Try to write exactly &#39;len&#39; application data bytes.">mbedtls_ssl_write()</a></code> function</li>
</ol>
<ol type="1">
<li>Which calls the <code>TLSSocketWrapper::ssl_send()</code></li>
</ol>
<ol type="1">
<li>Which calls the transport socket's <code><a class="el" href="classSocket.html#aebb3503269cc3f83a4418d7086c30e9d">Socket::send()</a></code>, which either blocks or returns <code>NSAPI_ERROR_WOULD_BLOCK</code>.</li>
</ol>
<p>When this <code>NSAPI_ERROR_WOULD_BLOCK</code> is returned:</p>
<ol type="1">
<li><code>TLSSocketWrapper::ssl_send()</code> translates the error to <code>MBEDTLS_ERR_SSL_WANT_WRITE</code>.</li>
</ol>
<ol type="1">
<li>Returned to <code><a class="el" href="ssl_8h.html#a5bbda87d484de82df730758b475f32e5" title="Try to write exactly &#39;len&#39; application data bytes.">mbedtls_ssl_write()</a></code>, which returns the same error.</li>
</ol>
<ol type="1">
<li><code>TLSSocketWrapper::send()</code> gets the <code>MBEDTLS_ERR_SSL_WANT_WRITE</code> and translates that to <code>NSAPI_ERROR_WOULD_BLOCK</code>.</li>
</ol>
<ol type="1">
<li>Application gets <code>NSAPI_ERROR_WOULD_BLOCK</code> and turns back off.</li>
</ol>
<p>When transport socket is in blocking mode, it never returns <code>NSAPI_ERROR_WOULD_BLOCK</code> and therefore <code><a class="el" href="ssl_8h.html#a5bbda87d484de82df730758b475f32e5" title="Try to write exactly &#39;len&#39; application data bytes.">mbedtls_ssl_write()</a></code> never gets <code>MBEDTLS_ERR_SSL_WANT_WRITE</code>. Any translation does not happen, but code path stays unchanged.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Detailed design for exposing Mbed TLS structures (Mbed TLS secure socket only)</h2>
<p>TLSSocket exposes the following API to provide access to internal Mbed TLS data structures:</p>
<div class="fragment"><div class="line">mbedtls_x509_crt *get_own_cert();</div>
<div class="line">int set_own_cert(mbedtls_x509_crt *);</div>
<div class="line">mbedtls_x509_crt *get_ca_chain();</div>
<div class="line">void set_ca_chain(mbedtls_x509_crt *);</div>
<div class="line">mbedtls_ssl_config *get_ssl_config();</div>
<div class="line">void set_ssl_config(mbedtls_ssl_config *);</div>
</div><!-- fragment --><p>This allows sockets to share the same configuration and allow user to adjust the TLS configuration, for example:</p>
<div class="fragment"><div class="line">TLSSocket a;</div>
<div class="line">TLSSocket b;</div>
<div class="line">a.open(&lt;interface&gt;);</div>
<div class="line">b.open(&lt;interface&gt;);</div>
<div class="line">a.set_root_ca_cert(&lt;cert&gt;);</div>
<div class="line">b.set_ssl_config(a.get_ssl_config());</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md70"></a>
Detailed design for communication between TLSSocket and network stack (offloaded secure socket only)</h2>
<p>All TLSSocket control between TLSSocket and the network stack is handled through socket options. The network stack must implement at least the following options:</p>
<div class="fragment"><div class="line">typedef enum nsapi_tlssocket_level {</div>
<div class="line">    NSAPI_TLSSOCKET_LEVEL   = 7099, /*!&lt; TLSSocket option level - see nsapi_tlssocket_option_t for options*/</div>
<div class="line">} nsapi_tlssocket_level_t;</div>
<div class="line"> </div>
<div class="line">typedef enum nsapi_tlssocket_option {</div>
<div class="line">    NSAPI_TLSSOCKET_SET_HOSTNAME,   /*!&lt; Set host name */</div>
<div class="line">    NSAPI_TLSSOCKET_SET_CACERT,     /*!&lt; Set server CA certificate */</div>
<div class="line">    NSAPI_TLSSOCKET_SET_CLCERT,     /*!&lt; Set client certificate */</div>
<div class="line">    NSAPI_TLSSOCKET_SET_CLKEY,      /*!&lt; Set client key */</div>
<div class="line">    NSAPI_TLSSOCKET_ENABLE          /*!&lt; Enable TLSSocket */</div>
<div class="line">} nsapi_tlssocket_option_t;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md71"></a>
Usage scenarios and examples</h1>
<h2><a class="anchor" id="autotoc_md72"></a>
Scenario 1: Connecting to a secure server</h2>
<div class="fragment"><div class="line">NetworkInterface *net = NetworkInterface::get_default_instance();</div>
<div class="line"> </div>
<div class="line">TLSSocket sock(net);</div>
<div class="line">sock.add_root_CA(...);</div>
<div class="line"> </div>
<div class="line">sock.connect(&quot;my_server.mbed.com&quot;, 8080); // Connect &amp; handle TLS handshake</div>
<div class="line"> </div>
<div class="line">// Now Socket is connected and can be used as any socket</div>
<div class="line">sock.send(&quot;hello&quot;, 5);</div>
</div><!-- fragment --><p>Example user: <a href="https://github.com/coisme/Mbed-to-Azure-IoT-Hub/blob/new-TLSSocket/MQTTNetwork.h">https://github.com/coisme/Mbed-to-Azure-IoT-Hub/blob/new-TLSSocket/MQTTNetwork.h</a></p>
<h1><a class="anchor" id="autotoc_md73"></a>
Tools and configuration changes</h1>
<p>No tool changes required.</p>
<h1><a class="anchor" id="autotoc_md74"></a>
Other information</h1>
<h2><a class="anchor" id="autotoc_md75"></a>
Selecting Mbed TLS secure socket or offloaded TLS socket</h2>
<p>By default, the system is configured to use the Mbed TLS based secure socket because only a few network stacks support offloaded TLS socket. You can enable the offloaded TLS socket in the application json configuration file by setting: <code>"nsapi.offload-tlssocket": true</code>.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Assumptions</h2>
<p>We assume the server certificate is given from the application to <code>TLSSocket::set_root_ca_cert()</code> interface in a format that is understood by Mbed TLS or, in the case of the offloaded TLS socket, the implementation of TLS socket in the network stack.</p>
<h2><a class="anchor" id="autotoc_md77"></a>
Deprecations</h2>
<p>No deprecations.</p>
<h2><a class="anchor" id="autotoc_md78"></a>
Security</h2>
<p>The offloaded TLS socket has one major security difference compared to the Mbed TLS based secure socket. In Mbed TLS secure socket, the application processor has already encrypted the data. Therefore, all user data between MCU and network interface hardware is encrypted. But with offloaded TLS socket, encryption happens in the network stack, which can be implemented in network hardware and result in data between the MCU and network hardware being unencrypted (for example, in cellular, UART traffic between the MCU and cellular modem).</p>
<h2><a class="anchor" id="autotoc_md79"></a>
Memory consumption</h2>
<p>One of the main reasons to select the offloaded TLSSocket is memory consumption. In the offloaded TLSSocket, the TLS implementation can be in modem firmware, which results in a significantly smaller application size and RAM consumption if application does not need Mbed TLS functionality for other reasons. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
