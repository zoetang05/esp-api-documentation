<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: Near-field communication in Mbed OS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2connectivity_2nfc_2docs_2nfc__design.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Near-field communication in Mbed OS</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md465"></a></p>
<h1><a class="anchor" id="autotoc_md466"></a>
Table of contents</h1>
<ul>
<li>Near-field communication in Mbed OS<ul>
<li>Table of contents</li>
<li>Revision history</li>
</ul>
</li>
<li>Introduction<ul>
<li>Overview and background</li>
<li>Use cases<ul>
<li>Commissioning<ul>
<li>Identification</li>
<li>Transport</li>
</ul>
</li>
<li>BLE pairing</li>
</ul>
</li>
</ul>
</li>
<li>System architecture and high-level design<ul>
<li>Compliance with NFC forum specifications</li>
<li>User-facing API</li>
<li>Phase 1: MicroNFC stack integration</li>
<li>Phase 2: NFC host/controller split, NCI and NFC HAL API</li>
</ul>
</li>
<li>Detailed design<ul>
<li>User-facing APIs<ul>
<li>NFC controller</li>
<li>Endpoints<ul>
<li>NFC remote endpoint</li>
<li>NFC NDEF capable</li>
<li>NFC remote initiator</li>
<li>NFC target</li>
<li>NFC EEPROM</li>
<li>NFC remote target</li>
</ul>
</li>
</ul>
</li>
<li>NDEF API<ul>
<li>Common objects</li>
<li>Parsing<ul>
<li>ndef::MessageParser<ul>
<li>ndef::MessageParser::Delegate</li>
</ul>
</li>
<li>NDEF record parsing<ul>
<li>ndef::RecordParser</li>
<li>ndef::RecordParserChain</li>
<li>ndef::GenericRecordParser&lt;ParserImplementation, ParsingResult&gt;<ul>
<li>ndef::GenericRecordParser&lt;ParserImplementation, ParsingResult&gt;::Delegate</li>
</ul>
</li>
</ul>
</li>
<li>Common parsers</li>
<li>Simple parser<ul>
<li>Delegate</li>
</ul>
</li>
</ul>
</li>
<li>Serialization</li>
</ul>
</li>
<li>HAL APIs<ul>
<li>NFC EEPROM API</li>
<li>NCI driver APIs</li>
</ul>
</li>
</ul>
</li>
<li>Testing strategy<ul>
<li>NFC forum compliance</li>
<li>Interoperability</li>
<li>HAL testing</li>
</ul>
</li>
<li>Dependencies</li>
</ul>
<h1><a class="anchor" id="autotoc_md467"></a>
Revision history</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision   </th><th class="markdownTableHeadNone">Date   </th><th class="markdownTableHeadNone">Authors   </th><th class="markdownTableHeadNone">Mbed OS version   </th><th class="markdownTableHeadNone">Comments    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.0   </td><td class="markdownTableBodyNone">24 August 2018   </td><td class="markdownTableBodyNone">Donatien Garnier (<a href="https://github.com/donatieng/">@donatieng</a>); Vincent Coubard (<a href="https://github.com/pan-/">@pan-</a>)   </td><td class="markdownTableBodyNone">5.10+   </td><td class="markdownTableBodyNone">Initial revision   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md468"></a>
Introduction</h1>
<h2><a class="anchor" id="autotoc_md469"></a>
Overview and background</h2>
<p>NFC offers a straightforward and secure way of commissioning IoT devices in the field, and we are seeing increasing demand for this from prospective customers. We have a plan to introduce NFC into Mbed OS. This is the first phase to add a reference implementation of card emulation mode.</p>
<p>NFC offers three modes:</p>
<ol type="1">
<li>NFC card emulation.</li>
<li>NFC reader/writer.</li>
<li>NFC peer to peer.</li>
</ol>
<p>To support new use cases, such as commissioning, <a class="el" href="classBLE.html">BLE</a> pairing and identification and authentication of NFC-enabled IoT endpoints, Mbed OS should support the card emulation mode.</p>
<p>However, the architecture should be future-proofed and should also be extendable to support other NFC modes in the future.</p>
<h2><a class="anchor" id="autotoc_md470"></a>
Use cases</h2>
<h3><a class="anchor" id="autotoc_md471"></a>
Commissioning</h3>
<p>NFC is a medium that can support commissioning requirements.</p>
<h4><a class="anchor" id="autotoc_md472"></a>
Identification</h4>
<p>You can use an NDEF message to carry a device's unique identifier. This eases identification before handing over to another transport medium, such as <a class="el" href="classBLE.html">BLE</a>.</p>
<h4><a class="anchor" id="autotoc_md473"></a>
Transport</h4>
<p>If the NFC controller can emulate a smartcard, no handover is necessary, and the full commissioning flow can happen over NFC.</p>
<h3><a class="anchor" id="autotoc_md474"></a>
BLE pairing</h3>
<p>You can use a specifically crafted NDEF message to facilitate out-of-band pairing with man-in-the-middle protection as specified in the <a href="https://members.nfc-forum.org/apps/group_public/download.php/18688/NFCForum-AD-BTSSP_1_1.pdf">BluetoothÂ® Secure Simple Pairing Using NFC</a> document.</p>
<h1><a class="anchor" id="autotoc_md475"></a>
System architecture and high-level design</h1>
<h2><a class="anchor" id="autotoc_md476"></a>
Compliance with NFC forum specifications</h2>
<p>The NFC Forum is one the bodies producing NFC standards. Most smartphones supporting NFC today are compliant with the NFC Forum's specifications. In that consideration, the NFC component in Mbed OS should map with the relevant standards from the NFC Forum, and NFC Forum terminology should be used where possible.</p>
<h2><a class="anchor" id="autotoc_md477"></a>
User-facing API</h2>
<p>The NFC API exposed to the user should provide high-level, object-oriented C++ APIs for the following:</p>
<ul>
<li>Starting/Stopping a discovery loop.</li>
<li>Listing wired targets (NFC EEPROMs).</li>
<li>Exchanging NDEF messages with an initiator or a wired target.</li>
<li>Emulate ISO7816-4 applications if supported.</li>
</ul>
<h2><a class="anchor" id="autotoc_md478"></a>
Phase 1: MicroNFC stack integration</h2>
<p>The first step toward adding NFC to Mbed OS is the integration of the MicroNFC stack, which has drivers for the PN512 and derivatives.</p>
<p>Architecture:</p>
<p><img src="phase_1_architecture.png" alt="phase_1_architecture" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md479"></a>
Phase 2: NFC host/controller split, NCI and NFC HAL API</h2>
<p>At the moment, the MicroNFC stack is split into two components:</p>
<ul>
<li>Applications protocols and upper stack.</li>
<li>Transceiver-specific polling loop and drivers.</li>
</ul>
<p>To more closely match with the NFC Forum standard and add a well-defined way for Partners to add support for their transceivers, we will amend that split to be compliant with the NFC Forum's NFC Communication Interface (NCI) protocol.</p>
<p>The generic part of the controller stack will be clearly separated, so Partners can use it if they wish (approach 1).</p>
<p>For NFC controllers natively supporting the NCI protocol, Partners would only have to write a transport driver (approach 2).</p>
<p><img src="phase_2_architecture.png" alt="phase_2_architecture" class="inline"/></p>
<p>Examples of NCI-compliant controllers:</p>
<ul>
<li>ST ST21NFC.</li>
<li>NXP PN7120 and PN7150.</li>
</ul>
<p>Examples of transceivers that are <em>not</em> NCI-compliant:</p>
<ul>
<li>NXP PN512.</li>
<li>NXP PN5180.</li>
<li>AMS AS395x series.</li>
</ul>
<h1><a class="anchor" id="autotoc_md480"></a>
Detailed design</h1>
<h2><a class="anchor" id="autotoc_md481"></a>
User-facing APIs</h2>
<p>We designed the user-facing APIs with the following principles:</p>
<ul>
<li>Abstracting the underlying complexities of NFC from the user.</li>
<li>Offering a high-level C++ object-oriented API to the user.</li>
<li>Ensuring compliance with the NFC Forum's standards and terminology.</li>
<li>Ensuring consistency with the Mbed OS codebase.</li>
</ul>
<p>Class diagram:</p>
<h3><a class="anchor" id="autotoc_md482"></a>
Â NFC controller</h3>
<p><img src="uml_diagram_controller.png" alt="nfc_controller_diagram" class="inline"/></p>
<p>The <code>NFCController</code> class is the entrypoint into NFC for the user.</p>
<p>When NCI integration is complete (phase 2), this class will be able to drive a <code>NCIDriver</code> instance. For now, the one controller we support is the PN512, which implements the <code>NFCControllerDriver</code> class. This class is specific to the current MicroNFC release.</p>
<div class="fragment"><div class="line">NFCController(NFCControllerDriver *driver, <a class="code hl_class" href="classevents_1_1EventQueue.html">events::EventQueue</a> *queue, <span class="keyword">const</span> Span&lt;uint8_t&gt; &amp;ndef_buffer);</div>
<div class="ttc" id="aclassevents_1_1EventQueue_html"><div class="ttname"><a href="classevents_1_1EventQueue.html">events::EventQueue</a></div><div class="ttdef"><b>Definition</b> EventQueue.h:62</div></div>
</div><!-- fragment --><p>The user instantiates the <code>NFCController</code> class using a driver, an event queue used for asynchronous operations and a scratch buffer used for NDEF processing.</p>
<p>It offers the following methods:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_delegate(Delegate *delegate);</div>
</div><!-- fragment --><p>Set the instance's delegate.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>nfc_rf_protocols_bitmask_t</div>
<div class="line">{</div>
<div class="line">    uint8_t initiator_t1t : 1;</div>
<div class="line">    uint8_t initiator_t2t : 1;</div>
<div class="line">    uint8_t initiator_t3t : 1;</div>
<div class="line">    uint8_t initiator_iso_dep : 1;</div>
<div class="line">    uint8_t initiator_nfc_dep : 1;</div>
<div class="line">    uint8_t initiator_t5t : 1;</div>
<div class="line"> </div>
<div class="line">    uint8_t target_t1t : 1;</div>
<div class="line">    uint8_t target_t2t : 1;</div>
<div class="line">    uint8_t target_t3t : 1;</div>
<div class="line">    uint8_t target_iso_dep : 1;</div>
<div class="line">    uint8_t target_nfc_dep : 1;</div>
<div class="line">    uint8_t target_t5t : 1;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">nfc_rf_protocols_bitmask_t get_supported_rf_protocols() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>Retrieve the list of supported RF protocols. These are mapped against NFC Forum-defined protocols.</p>
<ul>
<li>T1T is based on ISO/IEC 14443A-3 and commonly known as Topaz (Innovision).</li>
<li>T2T is based on ISO/IEC 14443A-3 and commonly known as Mifare Ultralight/NTAG (NXP).</li>
<li>T3T is based on JIS X6319-4, also known as Felica (Sony).</li>
<li>ISO-DEP is based on ISO/IEC 14443-4 and is the common interface for contactless smartcards. The underlying radio protocol can either be ISO/IEC 14443A or ISO/IEC 14443B.</li>
<li>NFC-DEP is based on ISO/IEC 18092/FIXME and is the basis for NFC peer-to-peer communication.</li>
<li>T5T is also known as ISO/IEC 15963.</li>
</ul>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a> initialize();</div>
<div class="ttc" id="agroup__Core_html_ga06e97468c14ad76f3de6810fb049b451"><div class="ttname"><a href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a></div><div class="ttdeci">int nfc_err_t</div><div class="ttdef"><b>Definition</b> nfc_errors.h:59</div></div>
</div><!-- fragment --><p>Initialize the NFC controller.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a> configure_rf_protocols(nfc_rf_protocols_bitmask_t rf_protocols);</div>
</div><!-- fragment --><p>Configure which protocols should be enabled during the discovery process.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a> start_discovery();</div>
</div><!-- fragment --><p>Start the discovery process.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a> cancel_discovery();</div>
</div><!-- fragment --><p>Cancel the discovery process (if running).</p>
<p><b>Delegate</b></p>
<p>A <code>NFCController</code> instance needs to be configured with a delegate to receive events.</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> nfc_discovery_terminated_reason_t {</div>
<div class="line">    nfc_discovery_terminated_completed = 0</div>
<div class="line">    nfc_discovery_terminated_canceled,</div>
<div class="line">    nfc_discovery_terminated_rf_error</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> on_discovery_terminated(nfc_discovery_terminated_reason_t reason);</div>
</div><!-- fragment --><p>Let the user know when a discovery loop has been terminated (either because endpoints have been found, the user canceled it or an error occurred).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> on_nfc_initiator_discovered(<span class="keyword">const</span> <a class="code hl_class" href="classmbed_1_1SharedPtr.html">mbed::SharedPtr&lt;NFCRemoteInitiator&gt;</a> &amp;nfc_initiator);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> on_nfc_target_discovered(<span class="keyword">const</span> <a class="code hl_class" href="classmbed_1_1SharedPtr.html">mbed::SharedPtr&lt;NFCRemoteTarget&gt;</a> &amp;nfc_target);</div>
<div class="ttc" id="aclassmbed_1_1SharedPtr_html"><div class="ttname"><a href="classmbed_1_1SharedPtr.html">mbed::SharedPtr</a></div><div class="ttdef"><b>Definition</b> SharedPtr.h:68</div></div>
</div><!-- fragment --><p>These methods called when a remote initiator (the local controller is acting as a target) or a remote target (the local controller is acting as an initiator) is detected.</p>
<p>These methods use shared pointers, so the user does not have to maintain the lifetime of these objects. The <code>NFCController</code> instance releases its reference when the endpoint is lost (see below).</p>
<h3><a class="anchor" id="autotoc_md483"></a>
Endpoints</h3>
<p><img src="uml_diagram_endpoints.png" alt="nfc_endpoints_diagram" class="inline"/></p>
<h4><a class="anchor" id="autotoc_md484"></a>
NFC remote endpoint</h4>
<p>A remote endpoint is a generic NFC-enabled device with which the controller is communicating over the air interface:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a> connect();</div>
</div><!-- fragment --><p>Establish a connection with the remote endpoint.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a> disconnect();</div>
</div><!-- fragment --><p>Drop the connection with the remote endpoint.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_connected() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>Set to true when the remote endpoint activates the connection and selects it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_disconnected() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>Set to true when the remote endpoint is lost and the <code>NFCController</code> instance releases its reference to the shared pointer.</p>
<div class="fragment"><div class="line">nfc_rf_protocols_bitmask_t rf_protocols() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>List the RF protocols that have been activated to communicate with that endpoint.</p>
<p><b>Delegate</b></p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_connected();</div>
</div><!-- fragment --><p>This is called when a connection to this endpoint is successfully established.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_disconnected();</div>
</div><!-- fragment --><p>This is called when this endpoint is lost and the controller instance is about to release the reference to the shared pointer.</p>
<h4><a class="anchor" id="autotoc_md485"></a>
NFC NDEF capable</h4>
<p>This class is the ancestor class for all endpoints which have the capability of handling NDEF data.</p>
<p>User-facing API:</p>
<div class="fragment"><div class="line">NFCNDEFCapable(<span class="keyword">const</span> Span&lt;uint8_t&gt; &amp;<a class="code hl_struct" href="structbuffer.html">buffer</a>);</div>
<div class="ttc" id="astructbuffer_html"><div class="ttname"><a href="structbuffer.html">buffer</a></div><div class="ttdef"><b>Definition</b> ns_buffer.h:201</div></div>
</div><!-- fragment --><p>The class is constructed using a scratch buffer which is used to encode and/or decode NDEF messages.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_ndef_supported() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>API used by descendant classes:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> parse_ndef_message(<span class="keyword">const</span> ac_buffer_t &amp;<a class="code hl_struct" href="structbuffer.html">buffer</a>);</div>
<div class="line"><span class="keywordtype">void</span> build_ndef_message(ac_buffer_builder_t &amp;buffer_builder);</div>
<div class="line">ndef_msg_t *ndef_message();</div>
</div><!-- fragment --><p>API implemented by descendant classes: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> NFCNDEFCapable::Delegate *ndef_capable_delegate();</div>
</div><!-- fragment --><p><b>Delegate</b></p>
<p>The instance receives requests to encode and decode NDEF messages, and the user can choose how to handle them using the relevant builders and parsers.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> parse_ndef_message(<span class="keyword">const</span> Span&lt;const uint8_t&gt; &amp;<a class="code hl_struct" href="structbuffer.html">buffer</a>);</div>
</div><!-- fragment --><p>The user receives the encoded NDEF message for processing.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> build_ndef_message(<span class="keyword">const</span> Span&lt;uint8_t&gt; &amp;<a class="code hl_struct" href="structbuffer.html">buffer</a>);</div>
</div><!-- fragment --><p>The user can encode a NDEF message in the buffer provided and return its size (or 0).</p>
<h4><a class="anchor" id="autotoc_md486"></a>
NFC remote initiator</h4>
<p>This class derives from the base <code>NFCRemoteEndpoint</code> and <code>NFCNDEFCapable</code> classes.</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> nfc_tag_type_t {</div>
<div class="line">    nfc_tag_type_1,</div>
<div class="line">    nfc_tag_type_2,</div>
<div class="line">    nfc_tag_type_3,</div>
<div class="line">    nfc_tag_type_4a,</div>
<div class="line">    nfc_tag_type_4b,</div>
<div class="line">    nfc_tag_type_5</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line">nfc_tag_type_t nfc_tag_type();</div>
</div><!-- fragment --><p>Additionally, the user can recover the type of NFC tag (1 to 5) being emulated. Type 4 is implemented on either one of two technologies; therefore, this enum both includes type 4a and type 4b to identify the underlying technology.</p>
<p><em>Note: ISO7816 is only used internally for the initial release</em></p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_iso7816_supported();</div>
<div class="line"><span class="keywordtype">void</span> add_iso7816_application(nfc_tech_iso7816_app_t *application);</div>
</div><!-- fragment --><p>If the underlying technology supports it (ISO-DEP), the user can emulate a contactless smartcard and register ISO7816-4 applications using this API.</p>
<p><b>Delegate</b></p>
<p>The delegate derives from delegates of <code>NFCRemoteEndpoint</code> and <code>NFCNDEFCapable</code>.</p>
<h4><a class="anchor" id="autotoc_md487"></a>
NFC target</h4>
<p>This is the base class for NFC targets that can be of two types:</p>
<ul>
<li>NFC EEPROMs (Dual-interface wired devices).</li>
<li>Remote NFC targets (NFC devices over NFC RF interface).</li>
</ul>
<p>Apart from the actual transport (wired or NFC), the use is similar, which explains why these methods are shared across these devices types.</p>
<p>This class derives from <code>NFCNDEFCapable</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> write_ndef_message();</div>
<div class="line"><span class="keywordtype">void</span> erase_ndef_message();</div>
<div class="line"><span class="keywordtype">void</span> read_ndef_message();</div>
</div><!-- fragment --><p>The user can trigger the appropriate NDEF parsing/building process using these methods if handlers are registered in the <code>NFCNDEFCapable</code> instance.</p>
<p><b>Delegate</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> on_ndef_message_erased(<a class="code hl_typedef" href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a> result);</div>
<div class="line"><span class="keywordtype">void</span> on_ndef_message_written(<a class="code hl_typedef" href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a> result);</div>
<div class="line"><span class="keywordtype">void</span> on_ndef_message_read(<a class="code hl_typedef" href="group__Core.html#ga06e97468c14ad76f3de6810fb049b451">nfc_err_t</a> result);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md488"></a>
NFC EEPROM</h4>
<p>The <code>NFCEEPROM</code> class derives from <code>NFCTarget</code> and shares the same API. The user must pass a pointer to a <code>NFCEEPROMDriver</code> instance (see below) in the constructor.</p>
<h4><a class="anchor" id="autotoc_md489"></a>
NFC remote target</h4>
<p><em>Note: This is out of scope for the initial release</em></p>
<p>The <code>NFCRemoteTarget</code> class derives from <code>NFCTarget</code> and additionally from <code>NFCRemoteEndpoint</code>.</p>
<h2><a class="anchor" id="autotoc_md490"></a>
NDEF API</h2>
<p>The NDEF API is constructed with these requirements:</p>
<ul>
<li>Minimizing memory allocation and copies.</li>
<li>NFC Forum compliance.</li>
<li>Ease of use.</li>
<li>Extensibility.</li>
</ul>
<h3><a class="anchor" id="autotoc_md491"></a>
Common objects</h3>
<p>We will provide multiple helpers to make it easy to create and parse common record types:</p>
<ul>
<li>URI.</li>
<li>Text.</li>
<li>Smart poster.</li>
<li>MIME data.</li>
</ul>
<p>For instance, the <code>URI</code>'s class API is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_uri(uri_identifier_code_t <span class="keywordtype">id</span>, <span class="keyword">const</span> Span&lt;const uint8_t&gt; &amp;uri_field)</div>
<div class="line"> </div>
<div class="line">uri_identifier_code_t get_id() <span class="keyword">const</span>;</div>
<div class="line">Span&lt;const uint8_t&gt; get_uri_field() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p><b>Note:</b> These types can be replaced by user defined ones if parsing and serialization logic is provided.</p>
<h3><a class="anchor" id="autotoc_md492"></a>
Parsing</h3>
<h4><a class="anchor" id="autotoc_md493"></a>
ndef::MessageParser</h4>
<p><img src="uml_diagram_ndef_message_parser.png" alt="ndef_message_parser_diagram" class="inline"/></p>
<p>A <code>MessageParser</code>, which produces <code>Record</code> instances to its client, parses messages incoming from the peer. The parsing operation is event-driven: A message parser client registers a delegate inside the message parser. This delegate is notified whenever an interesting event happens during the parsing.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_delegate(Delegate *delegate);</div>
<div class="line"><span class="keywordtype">void</span> parse(<span class="keyword">const</span> Span&lt;const uint8_t&gt; &amp;data_buffer);</div>
</div><!-- fragment --><p>It is important to note that the data_buffer in the entry of the parse function must contain the entire NDEF message.</p>
<h5><a class="anchor" id="autotoc_md494"></a>
ndef::MessageParser::Delegate</h5>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_parsing_started() { }</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_record_parsed(<span class="keyword">const</span> Record &amp;record) { }</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_parsing_terminated() { }</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_parsing_error(MessageParser::error_t <a class="code hl_function" href="group__platform__error.html#gabc561ef2adcee0d1aef1917f40828a42">error</a>) { }</div>
<div class="ttc" id="agroup__platform__error_html_gabc561ef2adcee0d1aef1917f40828a42"><div class="ttname"><a href="group__platform__error.html#gabc561ef2adcee0d1aef1917f40828a42">error</a></div><div class="ttdeci">MBED_NORETURN void error(const char *format,...) MBED_PRINTF(1</div></div>
</div><!-- fragment --><p>The delegate is notified by the parser when the parsing starts or ends, when an error is encountered or when an NDEF <code>Record</code> has been parsed.</p>
<p>To reduce memory consumption, <code>Record</code> instances generated by the parser are short lived. They are only valid during the callback invocation. If a client is interested in the content of a message parsed and wants to use it after the parsing callback, then it must make a copy of the record object.</p>
<h4><a class="anchor" id="autotoc_md495"></a>
NDEF record parsing</h4>
<p><img src="uml_diagram_ndef_record_parser.png" alt="ndef_record_parser_diagram" class="inline"/></p>
<p>NDEF records can contain any type of content. Therefore, parsing of records is specific to the application. To help the developer, an optional NDEF record parsing framework is included. It follows the <em>chain-of-responsibility</em> design pattern that facilitates the integration of record parsers defined by client code.</p>
<h5><a class="anchor" id="autotoc_md496"></a>
ndef::RecordParser</h5>
<p>It is the base building block of the record parsing frame working. It parses a record then returns true if the record has been parsed or false otherwise.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> parse(<span class="keyword">const</span> Record&amp;);</div>
</div><!-- fragment --><h5><a class="anchor" id="autotoc_md497"></a>
ndef::RecordParserChain</h5>
<p>It aggregates <code>RecordParser</code> instances and defers parsing to the instances it contains.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> parse(<span class="keyword">const</span> Record &amp;record);</div>
<div class="line"><span class="keywordtype">void</span> set_next_parser(RecordParser *parser);</div>
</div><!-- fragment --><h5><a class="anchor" id="autotoc_md498"></a>
ndef::GenericRecordParser&lt;ParserImplementation, ParsingResult&gt;</h5>
<p>This is a partial implementation of the <code>RecordParser</code> interface. It exposes a delegate type that clients of this parser can implement and register. This delegate expects objects of the parsing result type.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> parse(<span class="keyword">const</span> Record&amp;)</div>
<div class="line"><span class="keywordtype">void</span> set_delegate(Delegate *delegate)</div>
</div><!-- fragment --><p>Implementation of this class must expose the following nonvirtual function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> do_parse(<span class="keyword">const</span> Record &amp;record, ParsingResult &amp;parsing_result);</div>
</div><!-- fragment --><p>If the parsing is successful, then it should return true and fill <code>parsing_result</code>; otherwise, it should return false and leave <code>parsing_result</code> untouched.</p>
<p><b>Note:</b> The Curiously recurring template pattern (CRTP) is used to implement the delegation mechanism in a type-safe fashion. This is not achievable with <em>regular</em> polymorphism.</p>
<h6><a class="anchor" id="autotoc_md499"></a>
ndef::GenericRecordParser&lt;ParserImplementation, ParsingResult&gt;::Delegate</h6>
<p>Clients of this class must implement this delegate. It receives the objects parsed.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_record_parsed(<span class="keyword">const</span> ParsingResult &amp;record, <span class="keyword">const</span> RecordID *<span class="keywordtype">id</span>);</div>
</div><!-- fragment --><p><b>Note:</b> Usually, clients are client of an implementation of an ndef::GenericRecordParser&lt;ParserImplementation, ParsingResult&gt; . They can refer to the delegate as <code>ImplementationName::Delegate</code>.</p>
<h4><a class="anchor" id="autotoc_md500"></a>
Common parsers</h4>
<p><img src="uml_diagram_ndef_common_parsers.png" alt="ndef_common_parsers_diagram" class="inline"/></p>
<p>Parsers for each common record type exist. They inherit from the <code>GenericRecordParser</code> to exposes a common delegate interface:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_record_parsed(const &lt;ParsedType&gt; &amp;result, <span class="keyword">const</span> ndef::RecordID *<span class="keywordtype">id</span>)</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md501"></a>
Simple parser</h4>
<p>The APIs provide a class named <code>SimpleMessageParser</code> that glues together a <code>MessageParser</code> and a chain <code>RecordParser</code> containing the parsers for the common types.</p>
<p><img src="uml_diagram_ndef_simple_parser.png" alt="ndef_simple_parser_diagram" class="inline"/></p>
<p>Clients of the class can register a delegate, parse a message or add a new <code>RecordParser</code> in the parsing chain.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_delegate(Delegate *delegate);</div>
<div class="line"><span class="keywordtype">void</span> parse(<span class="keyword">const</span> Span&lt;const uint8_t&gt; &amp;data_buffer);</div>
<div class="line"><span class="keywordtype">void</span> add_record_parser(ndef::RecordParser *parser);</div>
</div><!-- fragment --><h5><a class="anchor" id="autotoc_md502"></a>
Delegate</h5>
<p>Clients of this class must implement this delegate. It receives events from the parsing process:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_parsing_error(ndef::MessageParser::error_t <a class="code hl_function" href="group__platform__error.html#gabc561ef2adcee0d1aef1917f40828a42">error</a>);</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_parsing_started();</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_text_parsed(<span class="keyword">const</span> Text&amp; text, <span class="keyword">const</span> ndef::RecordID &amp;<span class="keywordtype">id</span>);</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_mime_parsed(<span class="keyword">const</span> Mime&amp; text, <span class="keyword">const</span> ndef::RecordID &amp;<span class="keywordtype">id</span>);</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_uri_parsed(<span class="keyword">const</span> URI&amp; uri, <span class="keyword">const</span> ndef::RecordID &amp;<span class="keywordtype">id</span>);</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_unknown_record_parsed(<span class="keyword">const</span> ndef::Record &amp;record);</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> on_parsing_terminated();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md503"></a>
Serialization</h3>
<p>The class <code>MessageBuilder</code> is used to map a record into an NDEF message. It includes a data buffer that contains the <em>raw</em> message. Client code uses the function <code>append_record</code> to append a new record into the message being built.</p>
<p><img src="uml_diagram_ndef_message_builder_diagram.png" alt="ndef_message_builder_diagram" class="inline"/></p>
<p>For convenience, serialization functions for common types are provided in the common types we provide.</p>
<h2><a class="anchor" id="autotoc_md504"></a>
HAL APIs</h2>
<h3><a class="anchor" id="autotoc_md505"></a>
NFC EEPROM API</h3>
<p>To create the hardware-specific APIs to add support for a new NFC EEPROM, vendors need to derive from <code>NFCEEPROMDriver</code> and implement its virtual methods.</p>
<p>From the upper layer's point of view, the EEPROM is a byte array that can be read from or written to. Long operations (reads, writes, erasures) must happen asynchronously. Booleans indicate whether a particular operation was succesful.</p>
<p>Address 0 means the start of the NDEF buffer (not necessarily at address 0 in the EEPROM).</p>
<p>When a buffer is passed to the backend, the reference remains valid until the corresponding event is called.</p>
<p>The <code>set_size()</code> command is called to change the size of the NDEF buffer (within the limits set by <code>get_max_size()</code>). Inversely, that buffer size can be read using <code>get_size()</code>.</p>
<p><code>start_session()</code> and <code>end_session()</code> are used before a series of memory operations to allow the driver to lock or unlock the RF interface during these operations to avoid having concurrent access to the memory.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> reset();</div>
<div class="line"><span class="keywordtype">size_t</span> get_max_size();</div>
<div class="line"><span class="keywordtype">void</span> start_session(<span class="keywordtype">bool</span> force = <span class="keyword">true</span>);</div>
<div class="line"><span class="keywordtype">void</span> end_session();</div>
<div class="line"><span class="keywordtype">void</span> read_bytes(uint32_t address, <span class="keywordtype">size_t</span> count);</div>
<div class="line"><span class="keywordtype">void</span> write_bytes(uint32_t address, <span class="keyword">const</span> uint8_t *bytes, <span class="keywordtype">size_t</span> count);</div>
<div class="line"><span class="keywordtype">void</span> read_size(<span class="keywordtype">size_t</span> count);</div>
<div class="line"><span class="keywordtype">void</span> write_size();</div>
<div class="line"><span class="keywordtype">void</span> erase_bytes(uint32_t address, <span class="keywordtype">size_t</span> size)</div>
</div><!-- fragment --><p>The following events must be called to signal completion of long operations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> on_session_started(<span class="keywordtype">bool</span> success);</div>
<div class="line"><span class="keywordtype">void</span> on_session_ended(<span class="keywordtype">bool</span> success);</div>
<div class="line"><span class="keywordtype">void</span> on_bytes_read(<span class="keywordtype">size_t</span> count);</div>
<div class="line"><span class="keywordtype">void</span> on_bytes_written(<span class="keywordtype">size_t</span> count);</div>
<div class="line"><span class="keywordtype">void</span> on_size_read(<span class="keywordtype">bool</span> success, <span class="keywordtype">size_t</span> size);</div>
<div class="line"><span class="keywordtype">void</span> on_size_written(<span class="keywordtype">bool</span> success);</div>
<div class="line"><span class="keywordtype">void</span> on_bytes_erased(<span class="keywordtype">size_t</span> count);</div>
</div><!-- fragment --><p>The implementation also has access to an event queue in case asynchronous operations need to be run:</p>
<div class="fragment"><div class="line">Delegate *delegate();</div>
<div class="line"><a class="code hl_class" href="classevents_1_1EventQueue.html">events::EventQueue</a> *event_queue();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md506"></a>
NCI driver APIs</h3>
<p>This API will be defined in phase 2.</p>
<h1><a class="anchor" id="autotoc_md507"></a>
Testing strategy</h1>
<h2><a class="anchor" id="autotoc_md508"></a>
NFC forum compliance</h2>
<p>A dongle driven by <a href="https://nfcpy.readthedocs.io/en/latest/index.html">PyNFC</a> will be used to run Greentea-based tests to ensure that the implementation behaves correctly for a range of system tests.</p>
<p>Unit tests will cover all internal logic and NFC endpoints can be mocked/emulated where possible.</p>
<p>In the future, we could run NFC Forum test suites using approved testing equipment.</p>
<h2><a class="anchor" id="autotoc_md509"></a>
Interoperability</h2>
<p>Interoperability is important with a technology such as NFC. Therefore, our testing rig will include a selection of smartphones and NFC tags that can be connected using analog switches to the relevant NFC-enabled platform running Mbed OS.</p>
<p><img src="interop_test_rig.png" alt="interop_test_rig" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md510"></a>
HAL testing</h2>
<p>Greentea tests will be provided to Partners to ensure compliance with the NFC EEPROM backend API.</p>
<h1><a class="anchor" id="autotoc_md511"></a>
Dependencies</h1>
<ul>
<li>Event Queue</li>
</ul>
<p>There are currently at least four event queues (Plaftorm, <a class="el" href="classBLE.html">BLE</a>, USB and IP) in Mbed OS, and NFC will also require an event queing mechanism. We should try to reuse one of these existing queues with the longterm goal of unifying these code bases. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
