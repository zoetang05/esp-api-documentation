<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: HAL Static PinMap Extension Design Document</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2hal_2docs_20003-static-pinmap-extension.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">HAL Static PinMap Extension Design Document</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md738"></a></p>
<h1><a class="anchor" id="autotoc_md739"></a>
Table of contents</h1>
<ol type="1">
<li>HAL Static PinMap Extension Design Document.</li>
</ol>
<ol type="1">
<li>Table of contents.</li>
</ol>
<ol type="1">
<li>Introduction.<ol type="a">
<li>Overview and background.</li>
</ol>
<ol type="a">
<li>Requirements and assumptions.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>System architecture and high-level design.<ol type="a">
<li>Static pinmap mechanism.</li>
</ol>
<ol type="a">
<li>How much we can save.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Detailed design.<ol type="a">
<li>Pinmap types.</li>
</ol>
<ol type="a">
<li>HAL API changes.</li>
</ol>
<ol type="a">
<li>Drivers API changes.</li>
</ol>
<ol type="a">
<li>`constexpr` utility functions.</li>
</ol>
<ol type="a">
<li>Example usage.</li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md740"></a>
Introduction</h1>
<p>Making use of the pinmap tables optional by allowing the peripheral configuration (pin/periheral/function) to be statically specified in the HAL API function.</p>
<h3><a class="anchor" id="autotoc_md741"></a>
Overview and background</h3>
<p>In modern MCUs peripherals often can be mapped to different pins and each pin can have multiple functions. Mbed supports dynamic pin mapping, meaning that pins can be reconfigured at run time to be used by different driver. That provides great flexibility, but it's not free. There's non trivial ROM cost to maintain the pinmap tables and infrastructure to parse it. In some use cases this flexibility is worth the cost. Quite often pin configuration is frozen at hw design stage and doesn't require runtime modification. Shifting this configuration to compile time will allow us free memory associated with the dynamic approach.</p>
<p>HAL APIs making use of pins take these pins in their constructor and use those pins to lookup which peripheral/function to use. The process of looking up the peripheral/function requires there to be a pinmap table which maps pins to peripherals/functions. This pinmap table takes up ROM which could be saved if the pinmap wasn't used. The goal is to provide additional HAL API/constructors which takes pinmap as a parameter where pin/peripheral/function is specified statically and there is no need to use the pinmap tables. Also add the constant expression utility functions to find pin mappings in compile time. This extension should give the following savings:</p><ul>
<li>removed pinmap tables,</li>
<li>removed <code>hal\mbed_pinmap_common library</code> (required for pin lookup mechanism),</li>
<li>reduced HAL driver code.</li>
</ul>
<h3><a class="anchor" id="autotoc_md742"></a>
Requirements and assumptions</h3>
<ol type="1">
<li>Provide types which will hold static pinmaps for peripherals(<code>PWM</code>, <code>AnalogIn</code>, <code>AnalogOut</code>, <code>SPI</code>, <code>I2C</code>, <code>UART</code>, <code>QSPI</code>, <code>CAN</code>).</li>
<li>Provide <code>xxx_init_direct(xxx_t *obj, static_pinmap_t *)</code> functions to HAL API (these functions will not use pinmap tables).</li>
<li>Provide additional constructors in drivers layer which will use the <code>xxx_init_direct(xxx_t *obj, static_pinmap_t*)</code> HAL functions.</li>
<li>Provide default weak implementations of <code>xxx_init_direct(static_pinmap_t *)</code> functions. These functions will call standard <code>xxx_init(xxx_t *obj, PinName, ...)</code> function (backward compatibility for targets which do not support static pinmap mechanism).</li>
<li>Provide <code>constexpr</code> utility functions to lookup for pin mapping in compile time (requires C++14).</li>
<li>Initialize console using static pinmap mechanism, so <code>hal\mbed_pinmap_common library</code> is not needed and can be removed.</li>
<li>Modify FPGA tests to verify <code>xxx_init_direct(xxx_t *obj, static_pinmap_t*)</code> APIs.</li>
</ol>
<h1><a class="anchor" id="autotoc_md743"></a>
System architecture and high-level design</h1>
<h3><a class="anchor" id="autotoc_md744"></a>
Static pinmap mechanism</h3>
<p>The static pinmap mechanism with backward compatibility is shown below on PWM peripheral example.</p>
<p><img src="img/static_pinmap.png" alt="Static pinmap model" class="inline"/></p>
<p>For targets which do not provide static pinmap support standard initialization will be performed (which uses pinmap tables) even if direct API is selected.</p>
<h3><a class="anchor" id="autotoc_md745"></a>
How much we can save</h3>
<p>Example code used to test memory usage for peripheral with and without static pinmap extension can be found below:</p>
<div class="fragment"><div class="line">#ifndef USE_STATIC_PINMAP</div>
<div class="line">#define USE_STATIC_PINMAP 1</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">// SPI app for build test</div>
<div class="line">static void test_spi()</div>
<div class="line">{</div>
<div class="line">#if !USE_STATIC_PINMAP</div>
<div class="line">    /* Regular use (master) */</div>
<div class="line">    SPI spi(D1, D2, D3, D4);</div>
<div class="line">#else</div>
<div class="line">    /* Static pinmap */</div>
<div class="line">    constexpr spi_pinmap_t static_spi_pinmap = get_spi_pinmap(D1, D2, D3, D4);</div>
<div class="line">    SPI spi(static_spi_pinmap);</div>
<div class="line">#endif</div>
<div class="line">    spi.format(8,0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// PWM app for build test</div>
<div class="line">static void test_pwm()</div>
<div class="line">{</div>
<div class="line">#if !USE_STATIC_PINMAP</div>
<div class="line">    PwmOut led(LED1);</div>
<div class="line">#else</div>
<div class="line">    constexpr PinMap static_pinmap = get_pwm_pinmap(LED1);</div>
<div class="line">    PwmOut led(static_pinmap);</div>
<div class="line">#endif</div>
<div class="line">    led.period(4.0f);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// ANALOGIN app for build test</div>
<div class="line">static void test_analogin()</div>
<div class="line">{</div>
<div class="line">#if !USE_STATIC_PINMAP</div>
<div class="line">    AnalogIn ain(A0);</div>
<div class="line">#else</div>
<div class="line">    constexpr PinMap static_pinmap = get_analogin_pinmap(A0);</div>
<div class="line">    AnalogIn ain(static_pinmap);</div>
<div class="line">#endif</div>
<div class="line">    if(ain &gt; 0.3f) {</div>
<div class="line">        while(1);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// ANALOGOUT app for build test</div>
<div class="line">static void test_analogout()</div>
<div class="line">{</div>
<div class="line">#if !USE_STATIC_PINMAP</div>
<div class="line">    AnalogOut  aout(D1);</div>
<div class="line">#else</div>
<div class="line">    constexpr PinMap static_pinmap = get_analogout_pinmap(D1);</div>
<div class="line">    AnalogOut aout(static_pinmap);</div>
<div class="line">#endif</div>
<div class="line">    aout = 0.1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// I2C app for build test</div>
<div class="line">static void test_i2c()</div>
<div class="line">{</div>
<div class="line">#if !USE_STATIC_PINMAP</div>
<div class="line">    I2C i2c(D1, D2);</div>
<div class="line">#else</div>
<div class="line">    constexpr i2c_pinmap_t static_pinmap = get_i2c_pinmap(D1, D2);</div>
<div class="line">    I2C i2c(static_pinmap);</div>
<div class="line">#endif</div>
<div class="line">    i2c.frequency(1000000);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// SERIAL app for build test</div>
<div class="line">static void test_serial()</div>
<div class="line">{</div>
<div class="line">#if !USE_STATIC_PINMAP</div>
<div class="line">    Serial serial(D0, D1);</div>
<div class="line">    serial.set_flow_control(Serial::RTSCTS, D2, D3);</div>
<div class="line">#else</div>
<div class="line">    constexpr serial_pinmap_t static_pinmap = get_uart_pinmap(D0, D1);</div>
<div class="line">    constexpr serial_fc_pinmap_t static_pinmap_fc = get_uart_fc_pinmap(D2, D3);</div>
<div class="line">    Serial serial(static_pinmap);</div>
<div class="line">    serial.set_flow_control(Serial::RTSCTS, static_pinmap_fc);</div>
<div class="line">#endif</div>
<div class="line">    if (serial.readable()) {</div>
<div class="line">        while(1);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// QSPI app for build test</div>
<div class="line">static void test_qspi()</div>
<div class="line">{</div>
<div class="line">#if !USE_STATIC_PINMAP</div>
<div class="line">    QSPI qspi_device(D1, D2, D3, D4, D5, D6);</div>
<div class="line">#else</div>
<div class="line">    constexpr qspi_pinmap_t static_pinmap = get_qspi_pinmap(D1, D2, D3, D4, D5, D6);</div>
<div class="line">    QSPI qspi_device(static_pinmap);</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">    qspi_device.configure_format(QSPI_CFG_BUS_SINGLE, QSPI_CFG_BUS_SINGLE,</div>
<div class="line">                                QSPI_CFG_ADDR_SIZE_24, QSPI_CFG_BUS_SINGLE,</div>
<div class="line">                                QSPI_CFG_ALT_SIZE_8, QSPI_CFG_BUS_SINGLE, 0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// CAN app for build test</div>
<div class="line">static void test_can()</div>
<div class="line">{</div>
<div class="line">    char counter;</div>
<div class="line"> </div>
<div class="line">#if !USE_STATIC_PINMAP</div>
<div class="line">    CAN can(D0, D1);</div>
<div class="line">#else</div>
<div class="line">    constexpr can_pinmap_t static_pinmap = get_can_pinmap(D0, D1);</div>
<div class="line">    CAN can(static_pinmap, 10000);</div>
<div class="line">#endif</div>
<div class="line">    can.write(CANMessage(1337, &amp;counter, 1));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Detailed information about the memory savings for K64F and all compilers can be found below:</p>
<table class="doxtable">
<tr>
<th colspan="7">GCC_ARM/K64F [bytes] </th></tr>
<tr>
<th>Peripheral</th><th>Pinmap size</th><th>Master</th><th>Static pinmap</th><th>Static pinmap constexpr</th><th>constexpr diff</th><th>Saved ROM </th></tr>
<tr>
<th>PWM</th><td>468</td><td>54743</td><td>53810</td><td>53810</td><td>0</td><td>933 </td></tr>
<tr>
<th>Analogin</th><td>288</td><td>59967</td><td>59202</td><td>59202</td><td>0</td><td>765 </td></tr>
<tr>
<th>Analogout</th><td>24</td><td>53619</td><td>53094</td><td>53094</td><td>0</td><td>525 </td></tr>
<tr>
<th>SPI</th><td>408</td><td>57216</td><td>56227</td><td>56227</td><td>0</td><td>989 </td></tr>
<tr>
<th>I2C</th><td>204</td><td>54600</td><td>53915</td><td>53915</td><td>0</td><td>685 </td></tr>
<tr>
<th>Serial</th><td>288</td><td>59824</td><td>59371</td><td>59355</td><td>-16</td><td>453 </td></tr>
</table>
<table class="doxtable">
<tr>
<th colspan="7">ARM/K64F [bytes] </th></tr>
<tr>
<th>Peripheral</th><th>Pinmap size</th><th>Master</th><th>Static pinmap</th><th>Static pinmap constexpr</th><th>constexpr diff</th><th>Saved ROM </th></tr>
<tr>
<th>PWM</th><td>468</td><td>45564</td><td>44554</td><td>44554</td><td>0</td><td>1010 </td></tr>
<tr>
<th>Analogin</th><td>288</td><td>44469</td><td>43643</td><td>43643</td><td>0</td><td>826 </td></tr>
<tr>
<th>Analogout</th><td>24</td><td>43840</td><td>43274</td><td>43274</td><td>0</td><td>566 </td></tr>
<tr>
<th>SPI</th><td>408</td><td>47535</td><td>46471</td><td>46471</td><td>0</td><td>1064 </td></tr>
<tr>
<th>I2C</th><td>204</td><td>44876</td><td>44110</td><td>44110</td><td>0</td><td>766 </td></tr>
<tr>
<th>Serial</th><td>288</td><td>46554</td><td>46034</td><td>46034</td><td>0</td><td>520 </td></tr>
</table>
<table class="doxtable">
<tr>
<th colspan="7">IAR/K64F [bytes] </th></tr>
<tr>
<th>Peripheral</th><th>Pinmap size</th><th>Master</th><th>Static pinmap</th><th>Static pinmap constexpr</th><th>constexpr diff</th><th>Saved ROM </th></tr>
<tr>
<th>PWM</th><td>468</td><td>41125</td><td>40114</td><td>40103</td><td>-11</td><td>1011 </td></tr>
<tr>
<th>Analogin</th><td>288</td><td>39913</td><td>39073</td><td>39061</td><td>-12</td><td>840 </td></tr>
<tr>
<th>Analogout</th><td>24</td><td>39913</td><td>38645</td><td>38633</td><td>-12</td><td>1268 </td></tr>
<tr>
<th>SPI</th><td>408</td><td>41759</td><td>40685</td><td>40685</td><td>0</td><td>1074 </td></tr>
<tr>
<th>I2C</th><td>204</td><td>40480</td><td>39713</td><td>39713</td><td>0</td><td>767 </td></tr>
<tr>
<th>Serial</th><td>288</td><td>41427</td><td>40883</td><td>40883</td><td>0</td><td>544 </td></tr>
</table>
<p>The tables contain two columns for static pinmap case: <code>Static pinmap</code> (pinmap specified manually), <code>Static pinmap constexpr</code> (<code>constexpr</code> utility function used to create pinmap table). We expect that in both cases memory usage should be the same. Above results proves this assumption. In some cases we can get few bytes of extra savings when <code>constexpr</code> utility function is used. For more details about <code>constexpr</code> utility functions please check constexpr utility functions, example usage.</p>
<p>Note that on the master pinmap tables are used by the: serial console and tested peripheral. So in case of static pinmap we have savings from removing pinmap tables used by serial console and tested peripheral.</p>
<p>Example memory usage change for ARM/PWM example: master vs constexpr static pinmap:</p>
<div class="fragment"><div class="line">| Module                          |        .text |   .data |       .bss |</div>
<div class="line">|---------------------------------|--------------|---------|------------|</div>
<div class="line">| [lib]\c_w.l                     |    11175(+0) |  16(+0) |    348(+0) |</div>
<div class="line">| [lib]\fz_wm.l                   |       34(+0) |   0(+0) |      0(+0) |</div>
<div class="line">| [lib]\m_wm.l                    |       48(+0) |   0(+0) |      0(+0) |</div>
<div class="line">| anon$$obj.o                     |       32(+0) |   0(+0) | 197888(+0) |</div>
<div class="line">| drivers\source                  |      192(+0) |   0(+0) |      0(+0) |</div>
<div class="line">| features\netsocket              |      143(+0) |   0(+0) |      0(+0) |</div>
<div class="line">| hal\mbed_critical_section_api.o |      154(+0) |   0(+0) |      2(+0) |</div>
<div class="line">| hal\mbed_gpio.o                 |       96(+0) |   0(+0) |      0(+0) |</div>
<div class="line">| hal\mbed_pinmap_common.o        |      0(-272) |   0(+0) |      0(+0) |  // removed pinmap lib (this is common for all peripherals)</div>
<div class="line">| hal\mbed_ticker_api.o           |      978(+0) |   0(+0) |      0(+0) |</div>
<div class="line">| hal\mbed_us_ticker_api.o        |      114(+0) |   4(+0) |     65(+0) |</div>
<div class="line">| main.o                          |      70(+32) |   0(+0) |      0(+0) |  // extra space for static pinmap structure in application</div>
<div class="line">| platform\source                 |    5683(+46) |  64(+0) |    249(+0) |  // extra space for UART static pinmap structure to initialize the console</div>
<div class="line">| rtos\source                     |     8990(+0) | 168(+0) |   6626(+0) |</div>
<div class="line">| targets\TARGET_Freescale        |  16581(-816) |  12(+0) |    340(+0) |  // removed pinmaps + driver code reduction</div>
<div class="line">| Subtotals                       | 44290(-1010) | 264(+0) | 205518(+0) |</div>
<div class="line">Total Static RAM memory (data + bss): 205782(+0) bytes</div>
<div class="line">Total Flash memory (text + data): 44554(-1010) bytes</div>
</div><!-- fragment --><p>Below table contains memory savings when static pinmap is used for supported targets (ARM compiler):</p>
<table class="doxtable">
<tr>
<th colspan="9">ARM/supported Targets [bytes] </th></tr>
<tr>
<th>BOARD/PERIPHERAL</th><th>PWM</th><th>AnalogIn</th><th>AnalogOut</th><th>SPI</th><th>I2C</th><th>Serial</th><th>CAN</th><th>QSPI </th></tr>
<tr>
<th>NUCLEO_F429ZI</th><th>-1720</th><th>-1544</th><th>-928</th><th>-1464</th><th>-948</th><th>-976</th><th>-924</th><th>- </th></tr>
<tr>
<th>NUCLEO_F411RE</th><th>-1060</th><th>-908</th><th>-</th><th>-1140</th><th>-732</th><th>-628</th><th>-</th><th>- </th></tr>
<tr>
<th>DISCO_L475VG_IOT01A</th><th>-1644</th><th>-1324</th><th>-852</th><th>-1256</th><th>-848</th><th>-988</th><th>-788</th><th>-904 </th></tr>
<tr>
<th>NRF52840_DK</th><th>-</th><th>-160</th><th>-</th><th>-</th><th>-</th><th>-</th><th>-</th><th>- </th></tr>
<tr>
<th>NUCLEO_F303RE</th><th>-1620</th><th>-1256</th><th>-820</th><th>-1120</th><th>-860</th><th>-792</th><th>-740</th><th>- </th></tr>
<tr>
<th>LPC55S69_NS</th><th>-</th><th>-460</th><th>-</th><th>-718</th><th>-452</th><th>-400</th><th>-</th><th>- </th></tr>
<tr>
<th>NUCLEO_L073RZ</th><th>-1116</th><th>-1088</th><th>-864</th><th>-1092</th><th>-952</th><th>-958</th><th>-</th><th>- </th></tr>
</table>
<p>The memory savings are very target specific, but always proportional to size of the pinmap table.</p>
<h1><a class="anchor" id="autotoc_md746"></a>
Detailed design</h1>
<h3><a class="anchor" id="autotoc_md747"></a>
Pinmap types</h3>
<p>For peripherals which require only one pin (<code>AnalogIn</code>, <code>AnalogOut</code>, <code>PWM</code>) standard <code><a class="el" href="structPinMap.html">PinMap</a></code> type will be used and for peripherals which use more than one pin (<code>SPI</code>, <code>I2C</code>, <code>Serial</code>, <code>QSPI</code>, <code>CAN</code>) new types will be added:</p>
<div class="fragment"><div class="line">typedef struct {</div>
<div class="line">    PinName pin;     // selected pin name</div>
<div class="line">    int peripheral;  // peripheral that we want to use</div>
<div class="line">    int function;    // pin alternative function associated with the peripheral</div>
<div class="line">} PinMap;</div>
</div><!-- fragment --><p>Example pinmap type for SPI:</p>
<div class="fragment"><div class="line">typedef struct {</div>
<div class="line">    int peripheral;      // peripheral that we want to use</div>
<div class="line">    PinName mosi_pin;    // mosi pin name</div>
<div class="line">    int mosi_function;   // mosi pin alternative function</div>
<div class="line">    PinName miso_pin;    // miso pin name</div>
<div class="line">    int miso_function;   // miso pin alternative function</div>
<div class="line">    PinName sclk_pin;    // sclk pin name</div>
<div class="line">    int sclk_function;   // slck pin alternative function</div>
<div class="line">    PinName ssel_pin;    // ssel pin name</div>
<div class="line">    int ssel_function;   // ssel pin alternative function</div>
<div class="line">} spi_pinmap_t;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md748"></a>
HAL API changes</h3>
<p>Below example changes for the HAL API (K64F).</p>
<p>Master:</p>
<div class="fragment"><div class="line">void spi_init(spi_t *obj, PinName mosi, PinName miso, PinName sclk, PinName ssel)</div>
<div class="line">{</div>
<div class="line">    // determine the SPI to use</div>
<div class="line">    uint32_t spi_mosi = pinmap_peripheral(mosi, PinMap_SPI_MOSI);</div>
<div class="line">    uint32_t spi_miso = pinmap_peripheral(miso, PinMap_SPI_MISO);</div>
<div class="line">    uint32_t spi_sclk = pinmap_peripheral(sclk, PinMap_SPI_SCLK);</div>
<div class="line">    uint32_t spi_ssel = pinmap_peripheral(ssel, PinMap_SPI_SSEL);</div>
<div class="line">    uint32_t spi_data = pinmap_merge(spi_mosi, spi_miso);</div>
<div class="line">    uint32_t spi_cntl = pinmap_merge(spi_sclk, spi_ssel);</div>
<div class="line"> </div>
<div class="line">    obj-&gt;spi.instance = pinmap_merge(spi_data, spi_cntl);</div>
<div class="line">    MBED_ASSERT((int)obj-&gt;spi.instance != NC);</div>
<div class="line"> </div>
<div class="line">    // pin out the spi pins</div>
<div class="line">    pinmap_pinout(mosi, PinMap_SPI_MOSI);</div>
<div class="line">    pinmap_pinout(miso, PinMap_SPI_MISO);</div>
<div class="line">    pinmap_pinout(sclk, PinMap_SPI_SCLK);</div>
<div class="line">    if (ssel != NC) {</div>
<div class="line">        pinmap_pinout(ssel, PinMap_SPI_SSEL);</div>
<div class="line">    }</div>
<div class="line">    /* Set the transfer status to idle */</div>
<div class="line">    obj-&gt;spi.status = kDSPI_Idle;</div>
<div class="line"> </div>
<div class="line">    obj-&gt;spi.spiDmaMasterRx.dmaUsageState = DMA_USAGE_OPPORTUNISTIC;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Static pinmap:</p>
<div class="fragment"><div class="line">void spi_init_direct(spi_t *obj, const spi_pinmap_t *pinmap)</div>
<div class="line">{</div>
<div class="line">    obj-&gt;spi.instance = pinmap-&gt;peripheral;</div>
<div class="line">    MBED_ASSERT((int)obj-&gt;spi.instance != NC);</div>
<div class="line"> </div>
<div class="line">    // pin out the spi pins</div>
<div class="line">    pin_function(pinmap-&gt;mosi_pin, pinmap-&gt;mosi_function);</div>
<div class="line">    pin_mode(pinmap-&gt;mosi_pin, PullNone);</div>
<div class="line">    pin_function(pinmap-&gt;miso_pin, pinmap-&gt;miso_function);</div>
<div class="line">    pin_mode(pinmap-&gt;miso_pin, PullNone);</div>
<div class="line">    pin_function(pinmap-&gt;sclk_pin, pinmap-&gt;sclk_function);</div>
<div class="line">    pin_mode(pinmap-&gt;sclk_pin, PullNone);</div>
<div class="line">    if (pinmap-&gt;ssel_pin != NC) {</div>
<div class="line">        pin_function(pinmap-&gt;ssel_pin, pinmap-&gt;ssel_function);</div>
<div class="line">        pin_mode(pinmap-&gt;ssel_pin, PullNone);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    /* Set the transfer status to idle */</div>
<div class="line">    obj-&gt;spi.status = kDSPI_Idle;</div>
<div class="line"> </div>
<div class="line">    obj-&gt;spi.spiDmaMasterRx.dmaUsageState = DMA_USAGE_OPPORTUNISTIC;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void spi_init(spi_t *obj, PinName mosi, PinName miso, PinName sclk, PinName ssel)</div>
<div class="line">{</div>
<div class="line">    // determine the SPI to use</div>
<div class="line">    uint32_t spi_mosi = pinmap_peripheral(mosi, PinMap_SPI_MOSI);</div>
<div class="line">    uint32_t spi_miso = pinmap_peripheral(miso, PinMap_SPI_MISO);</div>
<div class="line">    uint32_t spi_sclk = pinmap_peripheral(sclk, PinMap_SPI_SCLK);</div>
<div class="line">    uint32_t spi_ssel = pinmap_peripheral(ssel, PinMap_SPI_SSEL);</div>
<div class="line">    uint32_t spi_data = pinmap_merge(spi_mosi, spi_miso);</div>
<div class="line">    uint32_t spi_cntl = pinmap_merge(spi_sclk, spi_ssel);</div>
<div class="line"> </div>
<div class="line">    int peripheral = (int)pinmap_merge(spi_data, spi_cntl);</div>
<div class="line"> </div>
<div class="line">    // pin out the spi pins</div>
<div class="line">    int mosi_function = (int)pinmap_find_function(mosi, PinMap_SPI_MOSI);</div>
<div class="line">    int miso_function = (int)pinmap_find_function(miso, PinMap_SPI_MISO);</div>
<div class="line">    int sclk_function = (int)pinmap_find_function(sclk, PinMap_SPI_SCLK);</div>
<div class="line">    int ssel_function = (int)pinmap_find_function(ssel, PinMap_SPI_SSEL);</div>
<div class="line"> </div>
<div class="line">    const spi_pinmap_t static_spi_pinmap = {peripheral, mosi, mosi_function, miso, miso_function, sclk, sclk_function, ssel, ssel_function};</div>
<div class="line"> </div>
<div class="line">    spi_init_direct(obj, &amp;static_spi_pinmap);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the version <code>v5.14.0</code> we have one init function: <code>spi_init(spi_t *obj, PinName mosi, PinName miso, PinName sclk, PinName ssel)</code> which uses pinmap tables to determine associated peripheral/function with the given pins and then initializes the peripheral.</p>
<p>In the new version(<code>feature-hal-spec-static-pinmap</code>) we will have two init functions:</p><ul>
<li><code>void spi_init(spi_t *obj, PinName mosi, PinName miso, PinName sclk, PinName ssel)</code>   This function will use pinmap tables to determine associated peripheral/function with the given pins, populate the pinmap structure and call <code>void spi_init_direct()</code> using created pinmap.</li>
<li><code>void spi_init_direct(spi_t *obj, const spi_pinmap_t *pinmap)</code>   This function will perform peripheral initialization using given static pinmap.</li>
</ul>
<p>This way we will give user the option to use comfortable, but expensive for ROM traditional peripheral init or to provide pin mappings manually and use the direct API which should give some ROM savings.</p>
<p>Below you can find weak implementation of <code>void spi_init_direct(spi_t *obj, const spi_pinmap_t *pinmap)</code> for targets which does not support static pinmap:</p>
<div class="fragment"><div class="line">#if DEVICE_SPI</div>
<div class="line">MBED_WEAK void spi_init_direct(spi_t *obj, const spi_pinmap_t *pinmap)</div>
<div class="line">{</div>
<div class="line">    spi_init(obj, pinmap-&gt;mosi_pin, pinmap-&gt;miso_pin, pinmap-&gt;sclk_pin, pinmap-&gt;ssel_pin);</div>
<div class="line">}</div>
<div class="line">#endif</div>
</div><!-- fragment --><p>If direct API is used for the target which does not support the static pinmap mechanism, then traditional API will be invoked to initialize the peripheral (no ROM savings).</p>
<h3><a class="anchor" id="autotoc_md749"></a>
Drivers API changes</h3>
<p>In the current version (master), all peripheral constructors in drivers layer take pins as parameters and then call <code>xxx_init(xxx_t *obj, PinName, ...)</code> HAL function to initialize the peripheral (and find peripheral/function associated with given pin). Now we will add an extra constructor which will take reference to the static pinmap structure and call <code>void spi_init_direct(spi_t *obj, const spi_pinmap_t *pinmap)</code> HAL function (in this case pinmap tables are not needed).</p>
<p>Below example changes for the SPI Driver API.</p>
<p>Master:</p>
<div class="fragment"><div class="line">SPI(PinName mosi, PinName miso, PinName sclk, PinName ssel = NC);</div>
<div class="line">SPI(PinName mosi, PinName miso, PinName sclk, PinName ssel, use_gpio_ssel_t);</div>
</div><!-- fragment --><p>Static pinmap:</p>
<div class="fragment"><div class="line">SPI(PinName mosi, PinName miso, PinName sclk, PinName ssel = NC);</div>
<div class="line">SPI(PinName mosi, PinName miso, PinName sclk, PinName ssel, use_gpio_ssel_t);</div>
<div class="line"> </div>
<div class="line">SPI(const spi_pinmap_t &amp;static_pinmap);</div>
<div class="line">SPI(const spi_pinmap_t &amp;static_pinmap, PinName ssel);</div>
</div><!-- fragment --><p>Note that for SPI class currently, we have 2 constructors. One is used when <code>ssel</code> is to be driven by hardware and the other one if <code>ssel</code> is controlled manually. In the new version, the second constructor is a bit different. Does not provide <code>use_gpio_ssel_t</code>, but has <code>PinName ssel</code> instead. This is because in the case when we want to manually handle the <code>ssel</code> pin, then <code>ssel</code> pin in the given <code>static_pinmap</code> will be undefined (<code>NC</code>) and <code>ssel</code> pin must be provided separately. In this case we don't need additional <code>use_gpio_ssel_t</code> any more.</p>
<h3><a class="anchor" id="autotoc_md750"></a>
<code>constexpr</code> utility functions</h3>
<p>C++ 14 provides <code>constexpr</code> specifier which can be used to create utility functions to lookup the pinmap tables in compile-time and create the pin-mapping without adding pinmap tables to the image.</p>
<p>Example pinmap lookup function below:</p>
<div class="fragment"><div class="line">constexpr PinMap get_pwm_pinmap(const PinName pin)</div>
<div class="line">{</div>
<div class="line">    for (const PinMap &amp;pinmap : PINMAP_PWM) {</div>
<div class="line">        if (pinmap.pin == pin) {</div>
<div class="line">            return {pin, pinmap.peripheral, pinmap.function};</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    return {NC, NC, NC};</div>
<div class="line">}</div>
</div><!-- fragment --><p>For targets which do not support static pinmap the utility functions will populate the pinmap structure only with given pins (backward compatibility):</p>
<div class="fragment"><div class="line">constexpr spi_pinmap_t get_spi_pinmap(const PinName mosi, const PinName miso, const PinName sclk, const PinName ssel)</div>
<div class="line">{</div>
<div class="line">    return {NC, mosi, NC, miso, NC, sclk, NC, ssel, NC};</div>
<div class="line">}</div>
</div><!-- fragment --><p>C++ 14 is not available on ARM C5, so for backward compatibility when ARM C5 is used the utility functions will be defined as follows: <code>const <a class="el" href="structPinMap.html">PinMap</a> get_pwm_pinmap(const PinName pin)</code>. Using <code>const</code> instead <code>constexpr</code> will add pinmap tables to the image (no ROM savings).</p>
<h3><a class="anchor" id="autotoc_md751"></a>
Example usage</h3>
<div class="fragment"><div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    /* Regular use (master) */</div>
<div class="line">    SPI spi(D1, D2, D3, D4);</div>
<div class="line"> </div>
<div class="line">    /* Static pinmap */</div>
<div class="line">    const spi_pinmap_t static_spi_pinmap = {SPI_1, D1, 2, D2, 2, D3, 2, D4, 2};</div>
<div class="line">    SPI spi(static_spi_pinmap);</div>
<div class="line"> </div>
<div class="line">    /* Static pinmap with constexpr */</div>
<div class="line">    constexpr spi_pinmap_t static_spi_pinmap = get_spi_pinmap(D1, D2, D3, D4);</div>
<div class="line">    SPI spi(static_spi_pinmap);</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the following use of the pinmap utility function: <code>SPI spi(get_spi_pinmap_t(D1, D2, D3, D4));</code> on ARM compiler leads to unexpected behavior. In the mentioned case, the pinmap table will be added to the image (no ROM savings). Details below:</p>
<p><img src="img/arm_constexpr_issue.png" alt="ARM constexpr issue" class="inline"/></p>
<p>Passing temporary pinmap objects to constructors (which lifetime is limited to constructor call) will be forbidden and we will get compilator error in the following case:</p>
<div class="fragment"><div class="line">SPI spi(get_spi_pinmap(PA_7, PA_6, PA_5, PA_4));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">[Error] main.cpp@41,9: call to deleted constructor of &#39;mbed::SPI&#39;</div>
<div class="line">[ERROR] .\main.cpp:41:9: error: call to deleted constructor of &#39;mbed::SPI&#39;</div>
<div class="line">    SPI spi(get_spi_pinmap(PA_7, PA_6, PA_5, PA_4));</div>
<div class="line">        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div>
<div class="line">./drivers/SPI.h:146:5: note: &#39;SPI&#39; has been explicitly marked deleted here</div>
<div class="line">    SPI(const spi_pinmap_t &amp;&amp;) = delete;</div>
<div class="line">    ^</div>
<div class="line">1 error generated.</div>
</div><!-- fragment --><p>This will solve above issue and additionally solve the problem with the classes which require access to pinmap structure beyond the constructor call. This will prevents the bad code generation possibility. Currently some classes provide <code>suspend/resume</code> API which requires access to pinmap structure beyond the constructor call and maybe such API will be added to the other classes later. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
