<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: Crash Reporting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2platform_2docs_2crash-reporting_2crash__reporting.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Crash Reporting</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md794"></a></p>
<h1><a class="anchor" id="autotoc_md795"></a>
Table of contents</h1>
<ul>
<li>Crash Reporting</li>
<li>Table of contents<ul>
<li>Revision history</li>
</ul>
</li>
<li>Introduction<ul>
<li>Overview and background</li>
<li>Requirements and assumptions</li>
</ul>
</li>
<li>System architecture and high-level design<ul>
<li>System architecture and component interaction</li>
</ul>
</li>
<li>Detailed design</li>
<li>Usage scenarios and examples</li>
<li>Tools and configuration changes</li>
<li>Other information<ul>
<li>Reusability</li>
<li>Deprecations</li>
<li>References</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md796"></a>
Revision history</h3>
<p>1.0 - Initial version - Senthil Ramakrishnan - 10/22/2018</p>
<h1><a class="anchor" id="autotoc_md797"></a>
Introduction</h1>
<h3><a class="anchor" id="autotoc_md798"></a>
Overview and background</h3>
<p>MbedOS currently implements error/exception handlers which gets invoked when the system encounters a fatal error or processor exceptions. The error and exception handlers capture information such as type of error, location of error, register context, thread info etc and these are valuable information required to debug the problem later. This information is currently printed over the serial port, but in many cases the serial port is not accessible and the serial terminal log is not captured, particularly in the case of field deployed devices. We cannot save this information by sending it over network or writing to a file, as the state of the system might be unstable after the fatal error. And thus a different mechanism is needed to record and report this data. The idea here is to auto-reboot the system after a fatal error has occurred to bring the system back in stable state, without losing the RAM contents where we have the error information collected, and we can then save this information reliably to be logged externally(E.g:- ARM Pelion cloud) or can be written to file system.</p>
<h3><a class="anchor" id="autotoc_md799"></a>
Requirements and assumptions</h3>
<p>This feature requires 256 bytes of dedicated RAM allocated for storing the error and fault context information.</p>
<p>Following are some common terminologies used in this document: Fault exception - This refers to processor exceptions such as HardFault, BusFault, MemManage fault or Usage fault. Fatal error - This refers to any error reported by calling <a class="el" href="group__platform__error.html#ga14636cd8b11abefffad1a1f50df6ffc5">mbed_error()</a>. Crash - This refers to the scenario where a fault exception or fatal error leading to system error handler(mbed_error()) being invoked.</p>
<h1><a class="anchor" id="autotoc_md800"></a>
System architecture and high-level design</h1>
<p>Below are the high-level goals for "Crash Reporting" feature:</p>
<p><b>Error information collection including fault exception context</b></p>
<p>The current error handling implementation in MbedOS already collects error and fault exception context. With this feature the above mentioned data structures should be placed in an uninitialized RAM region so that the data is retained after an auto-reboot(warm-reset).</p>
<p><b>Mechanism to auto reboot(also called warm-reset) the system without losing RAM contents where error info is stored</b></p>
<p>Implement auto-reboot functionality to reboot the system automatically after a fatal error. Note that the auto-reboot feature should be configurable.</p>
<p><b>Mechanism to retrieve the error data after reboot</b></p>
<p>Provide platform APIs to read the saved error information after reboot.</p>
<p><b>Mechanism to report the error data after reboot</b></p>
<p>During reboot the system should check if the reboot is caused by a fatal error and report the same using callback mechanism.</p>
<p><b>Implementation should provide a mechanism to prevent constant reboot loop by limiting the number of auto-reboots</b></p>
<p>System should implement mechanism to track number of times the system has auto-rebooted and be able to stop auto-reboot when a configurable limit is reached. That is, once the limit is reached the application main() will not be entered and the system will halt execution.</p>
<p><b>Implementation should provide following configuration options</b></p>
<ol type="1">
<li>Configuration option to enable or disable this feature</li>
</ol>
<ol type="1">
<li>Configuration option to enable or disable auto-reboot when the system enters a fatal error scenario</li>
</ol>
<ol type="1">
<li>Configuration option to limit the number of auto-reboots</li>
</ol>
<h3><a class="anchor" id="autotoc_md801"></a>
System architecture and component interaction</h3>
<p>The below diagram shows overall architecture of crash-reporting implementation.</p>
<p><img src="./diagrams/crash-report-seq.jpg" alt="System architecture and component interaction" class="inline"/></p>
<p>As depicted in the above diagram, when the system gets into fatal error state the information collected by error and fault handlers are saved into RAM space allocated for Crash-Report. This is followed by a auto-reboot triggered from error handler. On reboot the the initialization routine validates the contents of Crash-Report space in RAM. This validation serves two purposes - to validate the captured content itself and also it tells the system if the previous reboot was caused by a fatal error. It then reads this information and calls an application defined callback function passing the crash-report information. The callback is invoked just before the entry to main() and thus the callback implementation may access libraries and other resources as other parts of the system have already <a class="el" href="wsf__bufio_8c.html#a8d0bd049d090e9ac0069e38880bd5d0b">initialized(like SDK, HAL etc)</a> or can just capture the error information in application space to be acted upon later.</p>
<h1><a class="anchor" id="autotoc_md802"></a>
Detailed design</h1>
<h3><a class="anchor" id="autotoc_md803"></a>
Error information collection including fault exception context</h3>
<p>Current error and fault-exception handling implementation in Mbed OS already collects error and fault-exception context. But currently these data structures are implemented as statically allocated memory locations. With this feature these data structures should be placed in an uninitialized RAM region so that the data is retained after auto-reboot(warm-reset). So, this should be allocated as a dedicated region using linker command file(or in scatter file) for the corresponding target for each toolchain. Also note that this region should be marked as uninitialized region(not zero initialized) using the right toolchain attributes. For example, for ARM compiler we can define a new section as below: </p><div class="fragment"><div class="line">RW_m_crash_data m_crash_report_ram_start EMPTY m_crash_report_ram_size { ; Dedicated Region to store crash report data m_crash_report_ram_size = 256 bytes</div>
<div class="line">} </div>
</div><!-- fragment --><p> Note that the actual location of the data should be carefully chosen without affecting the current usage of other regions such as interrupt table region, flash configuration area etc. The absolute location of this Crash-Report RAM region may also differ for each target. The size of this RAM region should be 256 bytes. And internally the implementation would use the 256 byte region as two sub-areas with 128 bytes each. The upper 128 bytes will be used to store the fault context and the lower 128 bytes for error context, as shown in the diagram below.</p>
<p><img src="./diagrams/crash-report-region.jpg" alt="Crash report region" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md804"></a>
Mechanism to auto reboot(also called warm-reset) the system without losing RAM contents where error info is stored</h3>
<p>The current <a class="el" href="group__platform__error.html#ga14636cd8b11abefffad1a1f50df6ffc5">mbed_error()</a> implementation should be modified to cause an auto-reboot at the end of error handling if this feature is enabled. The mechanism used for rebooting should make sure it doesn't cause a reset of RAM contents. This can be done by calling <a class="el" href="namespacesystem__reset.html">system_reset()</a> function already implemented by MbedOS which cause the system to warm-reset without resetting the RAM. The <a class="el" href="group__platform__error.html#ga14636cd8b11abefffad1a1f50df6ffc5">mbed_error()</a> implementation also should make sure it updates the error context stored in Crash-Report RAM with the right CRC value. The CRC value is calculated across all the members of <a class="el" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a> structure and the CRC is appended at the end of that structure. <a class="el" href="group__platform__error.html#ga14636cd8b11abefffad1a1f50df6ffc5">mbed_error()</a> should also update the reboot count on every auto-reboot caused by fatal errors. The current mbed error context structure should be updated as below to capture reboot count, error processed status and the CRC value. The CRC value should be the last word in the struture.</p>
<div class="fragment"><div class="line">typedef struct _mbed_error_ctx {</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    //Below are the new struct members   </div>
<div class="line">    int32_t error_reboot_count; //every time we write this struct we increment this value by 1, irrespective of time between reboots. Note that the data itself might change, but every time we reboot due to error we update this count by 1</div>
<div class="line">    int32_t is_error_processed; //once this error is processed set this value to 1</div>
<div class="line">    uint32_t crc_error_ctx; //crc_error_ctx should always be the last member in this struct</div>
<div class="line">} mbed_error_ctx;</div>
</div><!-- fragment --><p>The below pueudo-code shows how the <a class="el" href="group__platform__error.html#ga14636cd8b11abefffad1a1f50df6ffc5">mbed_error()</a> implementation should be modified.</p>
<div class="fragment"><div class="line">mbed_error_status_t mbed_error( ... )</div>
<div class="line">{</div>
<div class="line">    //Handle the error just as we do now and then do the following to save the context into Crash-Report RAM and reset</div>
<div class="line">    </div>
<div class="line">    Read the current Crash Report and calculate CRC</div>
<div class="line">    If CRC matches what&#39;s in Crash-Report RAM: </div>
<div class="line">        Update the location with new error information</div>
<div class="line">        Update Reboot Count</div>
<div class="line">        Calculate new CRC</div>
<div class="line">        Update with new CRC value</div>
<div class="line">    Else (if CRC doesn&#39;t match) </div>
<div class="line">        //This is the case when we dont have a crash report already stored.</div>
<div class="line">        Update the location with new error information</div>
<div class="line">        Set Reboot count to 1</div>
<div class="line">        Calculate new CRC</div>
<div class="line">        Update with new CRC value</div>
<div class="line"> </div>
<div class="line">    Do a system reset //using system_reset() function</div>
<div class="line">}</div>
</div><!-- fragment --><p> The Crash-Report RAM region should also be used for tracking other pieces of information such as the CRC value and the auto-reboot count.</p>
<h3><a class="anchor" id="autotoc_md805"></a>
Mechanism to retrieve and reset the error data after reboot</h3>
<p>MbedOS error handling system should implement necessary APIs for application to retrieve and reset the error and/or fault context of the previous fatal error after auto-reboot. The below APIs should be implemented.</p>
<p>The below API can be called by application to retrieve the error context captured in the Crash-Report RAM. The error context is copied into the location pointed by <em>error_info</em>. Note that the caller should allocate the memory for this location. The function should return MBED_ERROR_NOT_FOUND if there is no error context currently stored. </p><div class="fragment"><div class="line"><span class="comment">//Retrieve the reboot error context</span></div>
<div class="line"><a class="code hl_typedef" href="group__platform__error.html#ga59a8e4f484a02c888997744d20b2fcd9">mbed_error_status_t</a> <a class="code hl_function" href="group__platform__error.html#gaf2e5bd0f2140b4d0d1bebf8f4497fba7">mbed_get_reboot_error_info</a>(<a class="code hl_typedef" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a> *error_info)</div>
<div class="ttc" id="agroup__platform__error_html_ga59a8e4f484a02c888997744d20b2fcd9"><div class="ttname"><a href="group__platform__error.html#ga59a8e4f484a02c888997744d20b2fcd9">mbed_error_status_t</a></div><div class="ttdeci">int mbed_error_status_t</div><div class="ttdef"><b>Definition</b> mbed_error.h:110</div></div>
<div class="ttc" id="agroup__platform__error_html_gae8ba9417e839754566bab426aa6aa0a0"><div class="ttname"><a href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a></div><div class="ttdeci">struct _mbed_error_ctx mbed_error_ctx</div></div>
<div class="ttc" id="agroup__platform__error_html_gaf2e5bd0f2140b4d0d1bebf8f4497fba7"><div class="ttname"><a href="group__platform__error.html#gaf2e5bd0f2140b4d0d1bebf8f4497fba7">mbed_get_reboot_error_info</a></div><div class="ttdeci">mbed_error_status_t mbed_get_reboot_error_info(mbed_error_ctx *error_info)</div><div class="ttdef"><b>Definition</b> mbed_error.c:384</div></div>
</div><!-- fragment --><p>The below API can be called by application to retrieve the fault context captured in the Crash-Report RAM. The error context is copied into the location pointed by <em>fault_context</em>. Note that the caller should allocate the memory for this location. Note that the fault context is valid only if the previous reboot was caused by a fault exception. Whether the previous reboot was caused by a fault exception can be determined from the error code stored in error context information retrieved using <a class="el" href="group__platform__error.html#gaf2e5bd0f2140b4d0d1bebf8f4497fba7">mbed_get_reboot_error_info()</a> API above. The function should return MBED_ERROR_NOT_FOUND if there is no fault context currently stored. </p><div class="fragment"><div class="line"><span class="comment">//Call this function to retrieve the last reboot fault context</span></div>
<div class="line"><a class="code hl_typedef" href="group__platform__error.html#ga59a8e4f484a02c888997744d20b2fcd9">mbed_error_status_t</a> mbed_get_reboot_fault_context (<a class="code hl_struct" href="structmbed__fault__context__t.html">mbed_fault_context_t</a> *fault_context);</div>
<div class="ttc" id="astructmbed__fault__context__t_html"><div class="ttname"><a href="structmbed__fault__context__t.html">mbed_fault_context_t</a></div><div class="ttdef"><b>Definition</b> mbed_fault_handler.h:80</div></div>
</div><!-- fragment --><p>The below API can be called by application to reset the error context captured in the Crash-Report RAM. The function should return MBED_ERROR_NOT_FOUND if there is no error context currently stored. </p><div class="fragment"><div class="line"><span class="comment">//Reset the reboot error context</span></div>
<div class="line"><a class="code hl_typedef" href="group__platform__error.html#ga59a8e4f484a02c888997744d20b2fcd9">mbed_error_status_t</a> <a class="code hl_function" href="group__platform__error.html#gaf06b4d1f81532c631cdc82c5f899be49">mbed_reset_reboot_error_info</a>()</div>
<div class="ttc" id="agroup__platform__error_html_gaf06b4d1f81532c631cdc82c5f899be49"><div class="ttname"><a href="group__platform__error.html#gaf06b4d1f81532c631cdc82c5f899be49">mbed_reset_reboot_error_info</a></div><div class="ttdeci">mbed_error_status_t mbed_reset_reboot_error_info(void)</div><div class="ttdef"><b>Definition</b> mbed_error.c:354</div></div>
</div><!-- fragment --><p>The below API can be called by application to reset(to be set to 0) the error reboot count captured in the Crash-Report RAM. The function should return MBED_ERROR_NOT_FOUND if there is no error context currently stored. </p><div class="fragment"><div class="line"><span class="comment">//Reset the reboot error context</span></div>
<div class="line"><a class="code hl_typedef" href="group__platform__error.html#ga59a8e4f484a02c888997744d20b2fcd9">mbed_error_status_t</a> <a class="code hl_function" href="group__platform__error.html#ga648a41d0b748aa86659c6f957f55bf77">mbed_reset_reboot_count</a>()</div>
<div class="ttc" id="agroup__platform__error_html_ga648a41d0b748aa86659c6f957f55bf77"><div class="ttname"><a href="group__platform__error.html#ga648a41d0b748aa86659c6f957f55bf77">mbed_reset_reboot_count</a></div><div class="ttdeci">mbed_error_status_t mbed_reset_reboot_count(void)</div><div class="ttdef"><b>Definition</b> mbed_error.c:366</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md806"></a>
Mechanism to report the error data after reboot</h3>
<p>MbedOS initialization sequence should check if the reboot is caused by a fatal error and should report the same to the application using callback mechanism.</p>
<p>MbedOS initialization sequence should be modified as shown in below diagram to report the crash report and invoke the callback.</p>
<p><img src="./diagrams/boot-error-report.jpg" alt="Error report on reboot" class="inline"/></p>
<p>Below should be the signature of the callback for reporting the error information.</p>
<p>The error handing system in MbedOS will call this callback function if it detects that the current reboot has been caused by a fatal error. This function will be defined with MBED_WEAK attribute by default and applications wanting to process the error report should override this function in application implementation. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__platform__error.html#ga1d17dd54b0a9c3b5dbd052c72069ea16">mbed_error_reboot_callback</a>(<a class="code hl_typedef" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a> *error_context);</div>
<div class="ttc" id="agroup__platform__error_html_ga1d17dd54b0a9c3b5dbd052c72069ea16"><div class="ttname"><a href="group__platform__error.html#ga1d17dd54b0a9c3b5dbd052c72069ea16">mbed_error_reboot_callback</a></div><div class="ttdeci">void mbed_error_reboot_callback(mbed_error_ctx *error_context)</div><div class="ttdef"><b>Definition</b> mbed_error.c:222</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md807"></a>
System should implement mechanism to track number of times the system is auto-rebooted and be able to stop auto-reboot when a configurable limit is reached</h3>
<p>Many a times rebooting may be a solution to bring the erroring device back into good <a class="el" href="pal__timer_8c.html#a51d375e3412343fad585076121e7d57a">state(after a fatal error for example)</a>but there might be scenarios when the system has a permanent issue causing it to run into fatal error on every boot. In such scenarios, auto-reboot mechanism can cause a constant reboot loop situation. In order to avoid this, implementation should provide a mechanism to prevent constant reboot loop by limiting the number of auto-reboots. The number of times auto-reboot happens on fatal errors should be configurable. A configuration option should be provided to configure the maximum number of auto-reboots(warm-resets). In order to implement this, system should track the number of times auto-reboot was effected using the Crash-Report RAM region.</p>
<h3><a class="anchor" id="autotoc_md808"></a>
Implementation should provide following configuration options</h3>
<p>Crash reporting implementation should provide enough parameters to control different aspects of crash reporting behavior so that developers can configure this feature to conform to their system design. Implementation should provide following configuration options to control the behavior as below.</p>
<ol type="1">
<li>Configuration option to enable or disable error the entire feature</li>
</ol>
<ol type="1">
<li>Configuration option to enable or disable auto-reboot when the system enters a fatal error scenario</li>
</ol>
<ol type="1">
<li>Configuration option to limit the number of auto-reboots</li>
</ol>
<h1><a class="anchor" id="autotoc_md809"></a>
Usage scenarios and examples</h1>
<p>Below (pseudo code) are some common usage scenarios using the new error reporting APIs.</p>
<h3><a class="anchor" id="autotoc_md810"></a>
Implementing crash reporting callback</h3>
<p>In order to implement the callback the user can override the default callback function(<em><a class="el" href="group__platform__error.html#ga1d17dd54b0a9c3b5dbd052c72069ea16">mbed_error_reboot_callback()</a></em>) implemented with MBED_WEAK attribute in platform layer as below.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a> my_error_ctx;</div>
<div class="line"><span class="comment">//Callback during reboot</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__platform__error.html#ga1d17dd54b0a9c3b5dbd052c72069ea16">mbed_error_reboot_callback</a>(<a class="code hl_typedef" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a> *error_context) </div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;Error callback received&quot;</span>);</div>
<div class="line">    <span class="comment">//Copy the error context in a local struct for processing it later</span></div>
<div class="line">    memcpy(&amp;my_error_ctx, error_context, <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a>));</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above function will be called during boot with a pointer to <em>error_context</em> structure.</p>
<h3><a class="anchor" id="autotoc_md811"></a>
Retrieving error info after reboot</h3>
<p>The error context captured can be retrieved using <a class="el" href="group__platform__error.html#gaf2e5bd0f2140b4d0d1bebf8f4497fba7">mbed_get_reboot_error_info()</a> API. See the below code for example usage of that API. In the example below, a status variable reboot_error_detected has been used to track the presence of error context capture.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a> error_ctx;</div>
<div class="line"><span class="keywordtype">int</span> reboot_error_detected = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Callback during reboot</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__platform__error.html#ga1d17dd54b0a9c3b5dbd052c72069ea16">mbed_error_reboot_callback</a>(<a class="code hl_typedef" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a> *error_context) </div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;error callback received&quot;</span>);</div>
<div class="line">    reboot_error_detected = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// main() runs in its own thread in the OS</span></div>
<div class="line"><span class="keywordtype">int</span> main() </div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (reboot_error_detected == 1) {</div>
<div class="line">        <span class="keywordflow">if</span> (MBED_SUCCESS == <a class="code hl_function" href="group__platform__error.html#gaf2e5bd0f2140b4d0d1bebf8f4497fba7">mbed_get_reboot_error_info</a>(&amp;error_ctx)) {</div>
<div class="line">            printf(<span class="stringliteral">&quot;\nSuccessfully read error context\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">//main continues...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md812"></a>
Retrieving fault context after reboot</h3>
<p>The fault context captured can be retrieved using mbed_get_reboot_fault_context() API. See the below code for example usage of that API. The example code below checks for error_status using the error context and then retrieves the fault context using mbed_get_reboot_fault_context() API.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a> error_ctx;</div>
<div class="line"><a class="code hl_struct" href="structmbed__fault__context__t.html">mbed_fault_context_t</a> fault_ctx;</div>
<div class="line"><span class="keywordtype">int</span> reboot_error_detected = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Callback during reboot</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__platform__error.html#ga1d17dd54b0a9c3b5dbd052c72069ea16">mbed_error_reboot_callback</a>(<a class="code hl_typedef" href="group__platform__error.html#gae8ba9417e839754566bab426aa6aa0a0">mbed_error_ctx</a> * error_context) </div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;error callback received&quot;</span>);</div>
<div class="line">    reboot_error_detected = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// main() runs in its own thread in the OS</span></div>
<div class="line"><span class="keywordtype">int</span> main() </div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (reboot_error_detected == 1) {</div>
<div class="line">        <span class="keywordflow">if</span> (MBED_SUCCESS == <a class="code hl_function" href="group__platform__error.html#gaf2e5bd0f2140b4d0d1bebf8f4497fba7">mbed_get_reboot_error_info</a>(&amp;error_ctx)) {</div>
<div class="line">            printf(<span class="stringliteral">&quot;\nRead in reboot info\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (error_ctx.error_status == MBED_ERROR_HARDFAULT_EXCEPTION) {</div>
<div class="line">               <span class="keywordflow">if</span> (MBED_SUCCESS == mbed_get_reboot_fault_context(&amp;fault_ctx)) {</div>
<div class="line">                   printf(<span class="stringliteral">&quot;\nRead in fault context info\n&quot;</span>);</div>
<div class="line">               }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">//main continues...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md813"></a>
Tools and configuration changes</h1>
<h3><a class="anchor" id="autotoc_md814"></a>
Platform configuration options for error reporting infrastruture</h3>
<p>Below is the list of new configuration options needed to configure error reporting functionality. All of these configuration options should be captured in mbed_lib.json file in platform directory.</p>
<p><b>crash-capture-enabled</b></p>
<p>Enables crash context capture when the system enters a fatal error/crash. When this is disabled it should also disable other dependent options.</p>
<p><b>fatal-error-auto-reboot-enabled</b></p>
<p>Enables auto-reboot on fatal errors.</p>
<p><b>error-reboot-max</b></p>
<p>Maximum number of auto reboots permitted when an error happens.</p>
<h1><a class="anchor" id="autotoc_md815"></a>
Other information</h1>
<h3><a class="anchor" id="autotoc_md816"></a>
Reusability</h3>
<h3><a class="anchor" id="autotoc_md817"></a>
Deprecations</h3>
<h3><a class="anchor" id="autotoc_md818"></a>
References</h3>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
