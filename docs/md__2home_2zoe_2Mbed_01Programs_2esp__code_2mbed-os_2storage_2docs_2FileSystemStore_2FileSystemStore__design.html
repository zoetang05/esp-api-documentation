<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: FileSystemStore in Mbed OS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2FileSystemStore_2FileSystemStore__design.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">FileSystemStore in Mbed OS</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md925"></a></p>
<ul>
<li>FileSystemStore in Mbed OS<ul>
<li>Revision history</li>
</ul>
</li>
<li>Introduction<ul>
<li>Overview and background</li>
<li>Requirements and assumptions</li>
</ul>
</li>
<li>System architecture and high-level design<ul>
<li>Design basics</li>
</ul>
</li>
<li>Detailed design<ul>
<li>Class header</li>
<li>Important data structures</li>
<li>Initialization and reset</li>
<li>Core APIs</li>
<li>Incremental set APIs</li>
<li>Key iterator APIs</li>
</ul>
</li>
<li>Usage scenarios and examples<ul>
<li>Standard usage of the class</li>
</ul>
</li>
<li>Other information<ul>
<li>Open issues</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md926"></a>
Revision history</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision   </th><th class="markdownTableHeadNone">Date   </th><th class="markdownTableHeadNone">Authors   </th><th class="markdownTableHeadNone">Mbed OS version   </th><th class="markdownTableHeadNone">Comments    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.0   </td><td class="markdownTableBodyNone">20 September 2018   </td><td class="markdownTableBodyNone">David Saada (<a href="https://github.com/davidsaada/">@davidsaada</a>)   </td><td class="markdownTableBodyNone">5.11+   </td><td class="markdownTableBodyNone">Initial revision   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md927"></a>
Introduction</h1>
<h3><a class="anchor" id="autotoc_md928"></a>
Overview and background</h3>
<p>FileSystemStore is a lightweight implementation of the <a class="el" href="md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2KVStore_2KVStore__design.html">KVStore</a> interface over file systems.</p>
<h3><a class="anchor" id="autotoc_md929"></a>
Requirements and assumptions</h3>
<p>FileSystemStore assumes the underlying file system qualities for resilience and file validation. This means that if the underlying file system has no protection against power failures, then neither would FileSystemStore have.</p>
<p>When initializing this class, it is assumed that the underlying FileSystem is initialized and mounted.</p>
<h1><a class="anchor" id="autotoc_md930"></a>
System architecture and high-level design</h1>
<h2><a class="anchor" id="autotoc_md931"></a>
Design basics</h2>
<p>FileSystemStore implements the get/set interface using files, where a single file represents each key. A key is represented by the file name, and its value is stored as file data. Therefore, FileSystemStore imitates the get/set actions using simple file operations. Set is achieved using open-write-close, get using open-read-close and so on. <br  />
</p>
<p>All files are concentrated under a single directory, whose name is hard coded. So actions such as "reset" are mapped to the deletion of all files under this directory, and iteration actions use file system APIs to traverse the directory. <br  />
</p>
<h3><a class="anchor" id="autotoc_md932"></a>
Data layout</h3>
<p>When storing the data, it is stored with a preceding 16-byte metadata header. Metadata includes flags and other parameters for basic validity checks. <br  />
</p>
<p><img src="./FileSystemStore_record.jpg" alt="FileSystemStore Record" class="inline"/></p>
<p>Fields are:</p>
<ul>
<li>Magic: A constant value, for quick validity checking.</li>
<li>Metadata size: Size of metadata header.</li>
<li>Revision: FileSystemStore revision (currently 1).</li>
<li>User flags: Flags received from user. Currently only write once is dealt with (others are ignored).</li>
</ul>
<h1><a class="anchor" id="autotoc_md933"></a>
Detailed design</h1>
<p>FileSystemStore fully implements the KVStore interface over a file system. As such, it uses the FileSystem class interface for file operations.</p>
<p><img src="./FileSystemStore_class_hierarchy.jpg" alt="FileSystemStore Class Hierarchy" class="inline"/></p>
<p>Functionality, as defined by KVStore, includes the following:</p>
<ul>
<li>Initialization and reset.</li>
<li>Core actions: get, set and remove.</li>
<li>Incremental set actions.</li>
<li>Iterator actions.</li>
</ul>
<h3><a class="anchor" id="autotoc_md934"></a>
Class header</h3>
<p>FileSystemStore has the following header:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FileSystemStore : KVStore {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FileSystemStore(FileSystem *fs);</div>
<div class="line">    <span class="keyword">virtual</span> ~FileSystemStore();</div>
<div class="line">         </div>
<div class="line">    <span class="comment">// Initialization and reset</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> init();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> deinit();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> reset();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Core API</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> size, uint32_t create_flags);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">void</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">size_t</span> *actual_size = NULL, <span class="keywordtype">size_t</span> offset = 0);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get_info(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, info_t *<a class="code hl_struct" href="structinfo.html">info</a>);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> remove(<span class="keyword">const</span> <span class="keywordtype">char</span> *key);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Incremental set API</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_start(set_handle_t *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">size_t</span> final_data_size, uint32_t create_flags);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_add_data(set_handle_t handle, <span class="keyword">const</span> <span class="keywordtype">void</span> *value_data, <span class="keywordtype">size_t</span> data_size);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_finalize(set_handle_t handle);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Key iterator</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_open(iterator_t *it, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix = NULL);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_next(iterator_t it, <span class="keywordtype">char</span> *key, <span class="keywordtype">size_t</span> key_size);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_close(iterator_t it);</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Mutex _mutex;</div>
<div class="line">    FileSystem *_fs;</div>
<div class="line">    <span class="keywordtype">bool</span> _is_initialized;</div>
<div class="line">}</div>
<div class="ttc" id="astructbuffer_html"><div class="ttname"><a href="structbuffer.html">buffer</a></div><div class="ttdef"><b>Definition</b> ns_buffer.h:201</div></div>
<div class="ttc" id="astructinfo_html"><div class="ttname"><a href="structinfo.html">info</a></div><div class="ttdef"><b>Definition</b> kvstore_global_api.h:38</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md935"></a>
Important data structures</h3>
<div class="fragment"><div class="line"><span class="comment">// Key metadata</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint32_t magic;</div>
<div class="line">    uint16_t metadata_size;</div>
<div class="line">    uint16_t revision;</div>
<div class="line">    uint32_t flags;</div>
<div class="line">} key_metadata_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// incremental set handle</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">char</span> *key;</div>
<div class="line">    uint32_t create_flags;</div>
<div class="line">} inc_set_handle_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterator handle</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">void</span> *dir_handle;</div>
<div class="line">    <span class="keywordtype">char</span> *prefix;</div>
<div class="line">} key_iterator_handle_t;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md936"></a>
Initialization and reset</h3>
<p><b>init function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int init();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If <code>_is_initialized</code>, return OK.</li>
<li>Create and take <code>_mutex</code>.</li>
<li>Create the FileSystemStore directory if it doesn't exist.</li>
<li>Set <code>_is_initialized</code> to true.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>deinit function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int deinit();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If not <code>_is_initialized</code>, return OK.</li>
<li>Take <code>_mutex</code>.</li>
<li>Set <code>_is_initialized</code> to false.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>reset function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int reset();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>Delete all files under the FileSystemStore directory.</li>
<li>Set <code>_num_keys</code> to 0.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md937"></a>
Core APIs</h3>
<p><b>set function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set(const char *key, const void *buffer, size_t size, uint32_t create_flags);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If not <code>_is_initialized</code>, return "not initialized" error.</li>
<li>Call <code>set_start</code> with all fields and a local <code>set_handle_t</code> variable.</li>
<li>Call <code>set_add_data</code> with <code>buffer</code> and <code>size</code>.</li>
<li>Call <code>set_finalize</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>get function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int get(const char *key, void *buffer, size_t buffer_size, size_t *actual_size = NULL, size_t offset = 0);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If not <code>_is_initialized</code>, return "not initialized" error.</li>
<li>Take <code>_mutex</code>.</li>
<li>Using the <code>stat</code> API, extract file size.</li>
<li>Open file <code>key</code> for reading to achieve a file handle.</li>
<li>If failed, release <code>_mutex</code> and return "not found" error.</li>
<li>Read from file into a <code>key_metadata_t</code> structure.</li>
<li>Using <code>size</code> API, achieve file size.</li>
<li>Seek to <code>offset</code> + metadata size.</li>
<li>Set <code>actual_size</code> as the minimum of buffer size and remainder of data.</li>
<li>Read data from file to <code>buffer</code>, size is <code>actual_size</code>.</li>
<li>Close file.</li>
<li>Release <code>_mutex</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>get_info function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int get_info(const char *key, info_t *info);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If not <code>_is_initialized</code>, return "not initialized" error.</li>
<li>Find file <code>key</code> under the FileSystemStore directory. If not existing, return "not found" error.</li>
<li>Take <code>_mutex</code>.</li>
<li>Open file <code>key</code> for reading to achieve a file handle.</li>
<li>If failed, release <code>_mutex</code>, and return "not found" error.</li>
<li>Using <code>size</code> API, achieve file size.</li>
<li>Read from file into a <code>key_metadata_t</code> structure.</li>
<li>Fill <code>info</code> structure with all relevant fields.</li>
<li>Close file.</li>
<li>Return OK.</li>
</ul>
<p><b>remove function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int remove(const char *key);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If not <code>_is_initialized</code>, return "not initialized" error.</li>
<li>Take <code>_mutex</code>.</li>
<li>Open file <code>key</code> for reading, and read data into a <code>key_metadata_t</code> structure.</li>
<li>If not existing, return "not found error".</li>
<li>If flag "write once" is preset, return "write once" error.</li>
<li>Delete file <code>key</code>.</li>
<li>Release <code>_mutex</code>.</li>
<li>Return OK.</li>
</ul>
<h3><a class="anchor" id="autotoc_md938"></a>
Incremental set APIs</h3>
<p><b>set_start function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set_start(set_handle_t *handle, const char *key, size_t final_data_size, uint32_t create_flags);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Find file <code>key</code> under the FileSystemStore directory. If not existing, increase <code>_num_keys</code> by 1.</li>
<li>Take <code>_mutex</code>.</li>
<li>Open file for reading, and read data into a <code>key_metadata_t</code> structure.</li>
<li>If existing and flag "write once" is preset, return "write once" error. <br  />
</li>
<li>Close file.</li>
<li>Allocate an <code>inc_set_handle_t</code> structure into <code>handle</code>.</li>
<li>Duplicate <code>key</code> in <code>handle</code>.</li>
<li>Update <code>create_flags</code> in <code>handle</code>.</li>
<li>Fill <code>key_metadata_t</code> structure with all relevant values (<code>create_flags</code> from handle).</li>
<li>Open file <code>key</code> for writing to achieve a file handle.</li>
<li>Write metadata structure to the file.</li>
<li>Close file.</li>
</ul>
<p><b>set_add_data function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set_add_data(set_handle_t handle, const void *value_data, size_t data_size);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Open file <code>key</code> for appending to achieve a file handle.</li>
<li>Write <code>value_data</code> to the file.</li>
<li>Close file.</li>
</ul>
<p><b>set_finalize function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set_finalize(set_handle_t handle);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Free <code>key</code> in <code>handle</code> and then <code>handle</code>.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md939"></a>
Key iterator APIs</h3>
<p><b>iterator_open function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int iterator_open(iterator_t *it, const char *prefix = NULL);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>Allocate a <code>key_iterator_handle_t</code> structure into <code>it</code>.</li>
<li>Duplicate <code>prefix</code> into same field in iterator.</li>
<li>Using directory <code>open</code> API, open FileSystemStore directory, and store dir handle in the handle's <code>dir_handle</code> field.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>iterator_next function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int iterator_next(iterator_t it, char *key, size_t key_size);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>Using direcory <code>read</code> API on handle's <code>dir_handle</code> field, read next file in directory.</li>
<li>While not reached end of directory.<ul>
<li>If name matches prefix:<ul>
<li>Copy file name to <code>key</code>, and return OK.</li>
</ul>
</li>
<li>Using direcory <code>read</code> API on handle's <code>dir_handle</code> field, read next file in directory.</li>
</ul>
</li>
<li>Return "not found" error.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>iterator_close function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int iterator_close(iterator_t it);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Using directory <code>close</code> API on <code>dir_handle</code> close handle.</li>
<li>Release <code>prefix</code> field in iterator and structure allocated at <code>it</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md940"></a>
Usage scenarios and examples</h1>
<h3><a class="anchor" id="autotoc_md941"></a>
Standard usage of the class</h3>
<p>The following example code shows standard use of the FileSystemStore class :</p>
<p><b>Standard usage example</b></p>
<div class="fragment"><div class="line"><span class="comment">// External file system of LittleFS type. Should be initialized.</span></div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_class" href="classLittleFileSystem.html">LittleFileSystem</a> fs;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Instantiate fsstore with our file system</span></div>
<div class="line">FileSystemStore fsstore(&amp;fs);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> res;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize fsstore</span></div>
<div class="line">res = fsstore.init();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add &quot;Key1&quot;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val1 = <span class="stringliteral">&quot;Value of key 1&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val2 = <span class="stringliteral">&quot;Updated value of key 1&quot;</span>;</div>
<div class="line">res = fsstore.set(<span class="stringliteral">&quot;Key1&quot;</span>, val1, <span class="keyword">sizeof</span>(val1), 0);</div>
<div class="line"><span class="comment">// Update value of &quot;Key1&quot;</span></div>
<div class="line">res = fsstore.set(<span class="stringliteral">&quot;Key1&quot;</span>, val2, <span class="keyword">sizeof</span>(val2), 0);</div>
<div class="line"> </div>
<div class="line">uint_8 value[32];</div>
<div class="line"><span class="keywordtype">size_t</span> actual_size;</div>
<div class="line"><span class="comment">// Get value of &quot;Key1&quot;. Value should return the updated value.</span></div>
<div class="line">res = fsstore.get(<span class="stringliteral">&quot;Key1&quot;</span>, value, <span class="keyword">sizeof</span>(value), &amp;actual_size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove &quot;Key1&quot;</span></div>
<div class="line">res = fsstore.remove(<span class="stringliteral">&quot;Key1&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Incremental write, if need to generate large data with a small buffer</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> data_size = 1024;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>[8];</div>
<div class="line"> </div>
<div class="line">KVSTore::set_handle_t handle;</div>
<div class="line">res = fsstore.set_start(&amp;handle, <span class="stringliteral">&quot;Key2&quot;</span>, data_size, 0);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; data_size / <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>); i++) {</div>
<div class="line">    memset(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, i, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">    res = fsstore.set_add_data(handle, <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">}</div>
<div class="line">res = fsstore.set_finalize(handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate over all keys starting with &quot;Key&quot;</span></div>
<div class="line">res = 0;</div>
<div class="line">KVSTore::iterator_t it;</div>
<div class="line">fsstore.iterator_open(&amp;it, <span class="stringliteral">&quot;Key*&quot;</span>);</div>
<div class="line"><span class="keywordtype">char</span> key[KVSTore::KV_MAX_KEY_LENGTH];</div>
<div class="line"><span class="keywordflow">while</span> (!res) {</div>
<div class="line">    res = fsstore.iterator_next(&amp;it, key, <span class="keyword">sizeof</span>(key));</div>
<div class="line">}</div>
<div class="line">res = fsstore.iterator_close(&amp;it);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deinitialize FileSystemStore</span></div>
<div class="line">res = fsstore.deinit();</div>
<div class="ttc" id="aclassLittleFileSystem_html"><div class="ttname"><a href="classLittleFileSystem.html">LittleFileSystem</a></div><div class="ttdef"><b>Definition</b> LittleFileSystem.h:36</div></div>
<div class="ttc" id="awsf__trace_8c_html_a631cb00ea94506727e7ab9cdd27cf9cd"><div class="ttname"><a href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a></div><div class="ttdeci">uint8_t buf[8]</div><div class="ttdef"><b>Definition</b> wsf_trace.c:81</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md942"></a>
Other information</h1>
<h3><a class="anchor" id="autotoc_md943"></a>
Open issues</h3>
<ul>
<li>Need to figure a way to prevent mutex abuse in incremental set APIs. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
