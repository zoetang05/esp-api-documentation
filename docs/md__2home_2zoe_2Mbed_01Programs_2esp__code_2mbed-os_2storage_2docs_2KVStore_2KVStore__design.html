<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: KVStore in Mbed OS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2KVStore_2KVStore__design.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">KVStore in Mbed OS</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md944"></a></p>
<ul>
<li>KVStore in Mbed OS<ul>
<li>Revision history</li>
</ul>
</li>
<li>Introduction<ul>
<li>Overview and background</li>
<li>Requirements and assumptions</li>
</ul>
</li>
<li>System architecture and high-level design<ul>
<li>Design basics<ul>
<li>Derived implementations</li>
</ul>
</li>
<li>Global Key Value interface</li>
</ul>
</li>
<li>Detailed design<ul>
<li>KVStore class design<ul>
<li>KVStore Class header</li>
</ul>
</li>
<li>Global Key Value interface design<ul>
<li>Global Key Value APIs</li>
</ul>
</li>
<li>Mapping APIs</li>
<li>Implementation<ul>
<li>Important data structures</li>
<li>Global Key Value API implementation</li>
<li>Attachment API implementation</li>
</ul>
</li>
</ul>
</li>
<li>Usage scenarios and examples<ul>
<li>Standard usage of the KVStore class</li>
<li>Standard usage of the Global Key Value interface</li>
</ul>
</li>
<li>Other information<ul>
<li>Open issues</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md945"></a>
Revision history</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision   </th><th class="markdownTableHeadNone">Date   </th><th class="markdownTableHeadNone">Authors   </th><th class="markdownTableHeadNone">Mbed OS version   </th><th class="markdownTableHeadNone">Comments    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.0   </td><td class="markdownTableBodyNone">26 September 2018   </td><td class="markdownTableBodyNone">David Saada (<a href="https://github.com/davidsaada/">@davidsaada</a>)   </td><td class="markdownTableBodyNone">5.11+   </td><td class="markdownTableBodyNone">Initial revision   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md946"></a>
Introduction</h1>
<h3><a class="anchor" id="autotoc_md947"></a>
Overview and background</h3>
<p>KVStore is an interface class whose purpose is to define APIs for a Key Value Store like storage over a block device.</p>
<h3><a class="anchor" id="autotoc_md948"></a>
Requirements and assumptions</h3>
<h1><a class="anchor" id="autotoc_md949"></a>
System architecture and high-level design</h1>
<h2><a class="anchor" id="autotoc_md950"></a>
Design basics</h2>
<p>KVStore defines a key value store like API set using this interface class. Classes implementing this interface store pairs of keys and values, where the keys are represented as character strings and the values are represented as binary blobs. Core APIs here are <em>get</em> and <em>set</em>, providing read and write access by key to the value in a single call. <em>remove</em> completes the set of core APIs. This simplifies the interface for the cases we need an actual key value store (like configurations). <br  />
</p>
<p>APIs also support an "incremental set" mode, allowing the implementing class to aggregate chunks of data for the set operation. This is for when the case the caller needs to generate large portions of data but doesn't wish to allocate large buffers for a single set operation. Note that <em>get</em> API doesn't have or require this functionality. Instead, it has an offset parameter (defaulting to 0) allowing the calling layer to extract portions of the data. <br  />
</p>
<p>Interface also includes iteration APIs, to let you iterate over all available keys, given a prefix. <br  />
</p>
<p>As some of the implementations use files as keys, key names must comply to file naming rules, meaning that characters like * , / etc. are not allowed in key names.</p>
<h3><a class="anchor" id="autotoc_md951"></a>
Derived implementations</h3>
<p><img src="./KVStore_classes.jpg" alt="KVStore Classes" class="inline"/></p>
<p>KVStore has a few derived implementations:</p>
<ul>
<li><a class="el" href="md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2TDBStore_2TDBStore__design.html">TDBStore</a> is the default solution because it gives the best performance, flash wear leveling and lowest overhead for a limited number of keys.</li>
<li><a class="el" href="md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2FileSystemStore_2FileSystemStore__design.html">FileSystemStore</a> is the preferred solution if you already have a file system and don't wish to have an additional one, or if specific POSIX features (such as file seeking) are required. It's also preferred if you don't have a limitation on the number of keys.</li>
<li><a class="el" href="md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2SecureStore_2SecureStore__design.html">SecureStore</a> adds security features such as encryption, rollback protection and authentication. It uses one of the other KVStore solutions as the underlying storage type.</li>
</ul>
<h2><a class="anchor" id="autotoc_md952"></a>
Global Key Value interface</h2>
<p>A parallel key-value API is provided as global C-style functions (for all functions, except for the incremental set ones). This API performs a limited type of mapping of partition or mount point names present in the keys. For each of the APIs defined in KVStore, the global version extracts a partition prefix from the key name. The prefix must be in the form "/partition/key-name". Then a lookup is performed to map the partition name to a concrete KVStore instance, and the API call is routed to that instance. The routed key name has the partition prefix stripped, leaving only "key-name".</p>
<p>In the case of iteration APIs, the prefix must include the partition (in the form of "/partition/prefix"). <br  />
</p>
<h1><a class="anchor" id="autotoc_md953"></a>
Detailed design</h1>
<h2><a class="anchor" id="autotoc_md954"></a>
KVStore class design</h2>
<p>As an interface class, KVStore has no implementation, just a class header.</p>
<h3><a class="anchor" id="autotoc_md955"></a>
KVStore class header</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>KVStore {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">enum</span> create_flags {</div>
<div class="line">        WRITE_ONCE_FLAG                     = (1 &lt;&lt; 0),</div>
<div class="line">        REQUIRE_CONFIDENTIALITY_FLAG        = (1 &lt;&lt; 1),</div>
<div class="line">        REQUIRE_REPLAY_PROTECTION_FLAG      = (1 &lt;&lt; 3),</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> uint32_t MAX_KEY_LENGTH = 128;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct </span>_opaque_set_handle *set_handle_t;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct </span>_opaque_key_iterator *iterator_t;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structinfo.html">info</a> {</div>
<div class="line">        <span class="keywordtype">size_t</span> size;</div>
<div class="line">        uint32_t flags;</div>
<div class="line">    } info_t;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialization and reset</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> init();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> deinit();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> reset();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Core API</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *buffer, <span class="keywordtype">size_t</span> size, uint32_t create_flags);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">void</span> *buffer, <span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">size_t</span> *actual_size = NULL, <span class="keywordtype">size_t</span> offset = 0);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get_info(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, info_t *info);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> remove(<span class="keyword">const</span> <span class="keywordtype">char</span> *key);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Incremental set API</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_start(set_handle_t *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">size_t</span> final_data_size, uint32_t create_flags);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_add_data(set_handle_t handle, <span class="keyword">const</span> <span class="keywordtype">void</span> *value_data, <span class="keywordtype">size_t</span> data_size);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_finalize(set_handle_t handle);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Key iterator</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_open(iterator_t *it, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix = NULL);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_next(iterator_t it, <span class="keywordtype">char</span> *key, <span class="keywordtype">size_t</span> key_size);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_close(iterator_t it);</div>
<div class="line">}</div>
<div class="ttc" id="astructinfo_html"><div class="ttname"><a href="structinfo.html">info</a></div><div class="ttdef"><b>Definition</b> kvstore_global_api.h:38</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md956"></a>
Global Key Value interface design</h2>
<p>As mentioned above, each KVStore API has a parallel C-style API, used globally with a partition name preceding the key name.</p>
<h3><a class="anchor" id="autotoc_md957"></a>
Global Key Value APIs</h3>
<div class="fragment"><div class="line"><span class="keyword">enum</span> kv_create_flags {</div>
<div class="line">    KV_WRITE_ONCE_FLAG                      = (1 &lt;&lt; 0),</div>
<div class="line">    KV_REQUIRE_CONFIDENTIALITY_FLAG         = (1 &lt;&lt; 1),</div>
<div class="line">    KV_REQUIRE_REPLAY_PROTECTION_FLAG       = (1 &lt;&lt; 3),</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t KV_MAX_KEY_LENGTH = 128;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_opaque_set_handle *kv_set_handle_t;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_opaque_key_iterator *kv_key_iterator_handle_t;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structinfo.html">info</a> {</div>
<div class="line">    <span class="keywordtype">size_t</span> size;</div>
<div class="line">    uint32_t flags;</div>
<div class="line">} kv_info_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Core API</span></div>
<div class="line"><span class="keywordtype">int</span> kv_set(<span class="keyword">const</span> <span class="keywordtype">char</span> *full_name_key, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> size, uint32_t create_flags);</div>
<div class="line"><span class="keywordtype">int</span> kv_get(<span class="keyword">const</span> <span class="keywordtype">char</span> *full_name_key, <span class="keywordtype">void</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">size_t</span> *actual_size);</div>
<div class="line"><span class="keywordtype">int</span> kv_get_info(<span class="keyword">const</span> <span class="keywordtype">char</span> *full_name_key, kv_info_t *<a class="code hl_struct" href="structinfo.html">info</a>);</div>
<div class="line"><span class="keywordtype">int</span> kv_remove(<span class="keyword">const</span> <span class="keywordtype">char</span> *full_name_key);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Key iterator</span></div>
<div class="line"><span class="keywordtype">int</span> kv_iterator_open(kv_key_iterator_handle_t *it, <span class="keyword">const</span> <span class="keywordtype">char</span> *full_prefix = <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="keywordtype">int</span> kv_iterator_next(kv_key_iterator_handle_t it, <span class="keywordtype">char</span> *key, <span class="keywordtype">size_t</span> key_size);</div>
<div class="line"><span class="keywordtype">int</span> kv_iterator_close(kv_key_iterator_handle_t it);</div>
<div class="ttc" id="astructbuffer_html"><div class="ttname"><a href="structbuffer.html">buffer</a></div><div class="ttdef"><b>Definition</b> ns_buffer.h:201</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md958"></a>
Mapping APIs</h2>
<p>To use the global C style APIs, you need APIs to map the partition name to the instance of the implementing KVStore class, typically called once at initialization time. So, for example a <code>"/tdbstore/key1"</code> name means that you wish to access <code>"key1"</code> key in a TDBStore instance. This means that you need to attach <code>"tdbstore"</code> string to the TDBStore instance at initialization time. <br  />
</p>
<p>These APIs are part of a different header file ("kv_map.h") because they serve the integration code and not the KVStore user code:</p>
<div class="fragment"><div class="line"><span class="comment">// Attach and detach</span></div>
<div class="line"><span class="keywordtype">int</span> kv_init();</div>
<div class="line"><span class="keywordtype">int</span> kv_attach(<span class="keyword">const</span> <span class="keywordtype">char</span> *partition_name, KVStore *kv_instance);</div>
<div class="line"><span class="keywordtype">int</span> kv_detach(<span class="keyword">const</span> <span class="keywordtype">char</span> *partition_name);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Full name lookup and then break it into KVStore instance and key</span></div>
<div class="line"><span class="keywordtype">int</span> kv_lookup(<span class="keyword">const</span> <span class="keywordtype">char</span> *full_name, KVStore&amp; *kv_instance, <span class="keywordtype">char</span> *key);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md959"></a>
Implementation</h2>
<p>Below is the implementation of the Global Key Value interface and of the attachment APIs. KVStore class has no implemetation because it's an interface class:</p>
<h3><a class="anchor" id="autotoc_md960"></a>
Important data structures</h3>
<div class="fragment"><div class="line"><span class="comment">// incremental set handle</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    KVStore *kvstore_intance;</div>
<div class="line">    KVStore::set_handle_t *set_handle;</div>
<div class="line">} kv_inc_set_handle_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterator handle</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    KVStore *kvstore_intance;</div>
<div class="line">    KVStore::iterator_t *iterator_handle;</div>
<div class="line">} kv_key_iterator_handle_t;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> MAX_ATTACHED_KVS 16</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">char</span> *partition_name;</div>
<div class="line">    KVStore *kvstore_instance;</div>
<div class="line">} kv_map_entry_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attachment table</span></div>
<div class="line">kv_map_entry_t kv_map_table[MAX_ATTACHED_KVS];</div>
<div class="line"><span class="keywordtype">int</span> kv_num_attached_kvs;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md961"></a>
Global Key Value API implementation</h3>
<p><b>kv_set function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_set(const char *full_name_key, const void *buffer, size_t size, uint32_t create_flags);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Using <code>kv_lookup</code>, break <code>full_name_key</code> into <code>key</code> and <code>kvs_instance</code>.</li>
<li>Call <code>kvs_instance</code> <code>set</code> method with <code>key</code> and the rest of the arguments.</li>
</ul>
<p><b>kv_get function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_get(const char *full_name_key, void *buffer, size_t buffer_size, size_t *actual_size);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Using <code>kv_lookup</code>, break <code>full_name_key</code> into <code>key</code> and <code>kvs_instance</code>.</li>
<li>Call <code>kvs_instance</code> <code>get</code> method with <code>key</code> and the rest of the arguments.</li>
</ul>
<p><b>kv_get_info function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_get_info(const char *full_name_key, kv_info_t *info);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Using <code>kv_lookup</code>, break <code>full_name_key</code> into <code>key</code> and <code>kvs_instance</code>.</li>
<li>Call <code>kvs_instance</code> <code>get_info</code> method with <code>key</code> and the rest of the arguments.</li>
</ul>
<p><b>kv_remove function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_remove(const char *full_name_key);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Using <code>kv_lookup</code>, break <code>full_name_key</code> into <code>key</code> and <code>kvs_instance</code>.</li>
<li>Call <code>kvs_instance</code> <code>remove</code> method with <code>key</code> and the rest of the arguments.</li>
</ul>
<p><b>kv_set_start function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_set_start(kv_set_handle_t *handle, const char *full_name_key, size_t final_data_size);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Allocate an <code>kv_inc_set_handle_t</code> structure into <code>handle</code>.</li>
<li>Using <code>kv_lookup</code>, break <code>full_name_key</code> into allocated <code>key</code> and <code>kvs_instance</code> (in <code>handle</code>).</li>
<li>Call <code>kvs_instance</code> <code>set_start</code> method with <code>key</code> and the rest of the arguments.</li>
</ul>
<p><b>kv_set_add_data function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_set_add_data(kv_set_handle_t handle, const void *value_data, size_t data_size);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Extract <code>kvs_instance</code> and <code>set_handle</code> from <code>handle</code>.</li>
<li>Call <code>kvs_instance</code> <code>set_add_data</code> method with <code>set_handle</code> and the rest of the arguments.</li>
</ul>
<p><b>kv_set_finalize function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_set_finalize(kv_set_handle_t handle);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Extract <code>kvs_instance</code> and <code>set_handle</code> from <code>handle</code>.</li>
<li>Call <code>kvs_instance</code> <code>set_finalize</code> method with <code>set_handle</code>.</li>
<li>Free <code>key</code> and <code>handle</code>.</li>
</ul>
<p><b>kv_iterator_open function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_iterator_open(kv_key_iterator_handle_t *it, const char *full_prefix = nullptr);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Allocate a <code>kv_key_iterator_handle_t</code> structure into <code>it</code>.</li>
<li>Using <code>kv_lookup</code>, break <code>full_name_key</code> into allocated <code>prefix</code> and <code>kvs_instance</code> (in <code>handle</code>).</li>
<li>Call <code>kvs_instance</code> <code>iterator_open</code> method with <code>iterator_handle</code>, <code>prefix</code> and the rest of the arguments.</li>
</ul>
<p><b>kv_iterator_next function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_iterator_next(kv_key_iterator_handle_t it, char *key, size_t key_size);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Extract <code>kvs_instance</code> and <code>iterator_handle</code> from <code>handle</code>.</li>
<li>Call <code>kvs_instance</code> <code>iterator_next</code> method with <code>iterator_handle</code> and the rest of the arguments.</li>
</ul>
<p><b>kv_iterator_close function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_iterator_close(kv_key_iterator_handle_t it);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Extract <code>kvs_instance</code> and <code>iterator_handle</code> from <code>handle</code>.</li>
<li>Call <code>kvs_instance</code> <code>set_finalize</code> method with <code>iterator_handle</code>.</li>
<li>Free <code>prefix</code> and <code>handle</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md962"></a>
Attachment API implementation</h3>
<p><b>kv_init function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_init();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Set <code>kv_num_attached_kvs</code> to 0.</li>
</ul>
<p><b>kv_attach function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_attach(const char *partition_name, KVStore *kv_instance);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Duplicate <code>partition_name</code> and <code>kv_instance</code> to last entry in <code>kv_map_table</code>.</li>
<li>Increment <code>kv_num_attached_kvs</code>.</li>
</ul>
<p><b>kv_detach function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_detach(const char *partition_name);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Look for entry with <code>partition_name</code> in <code>kv_map_table</code>.</li>
<li>Deallocate <code>partition_name</code> in this entry.</li>
<li>Copy all preceding entries back one position.</li>
<li>Decrement <code>kv_num_attached_kvs</code>.</li>
</ul>
<p><b>kv_lookup function</b></p>
<p>Header: <br  />
</p>
<p><code>int kv_lookup(const char *full_name, KVStore&amp; *kv_instance, char *key);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Break <code>full_name</code> string to <code>partition_name</code> and <code>key</code>.</li>
<li>Look for entry with <code>partition_name</code> in <code>kv_map_table</code>.</li>
<li>Extract <code>kv_instance</code> from table entry.</li>
</ul>
<h1><a class="anchor" id="autotoc_md963"></a>
Usage scenarios and examples</h1>
<h3><a class="anchor" id="autotoc_md964"></a>
Standard use of the KVStore class</h3>
<p>The following example code shows standard use of the KVStore, using the TDBStore class:</p>
<p><b>Standard usage example - with class APIs</b></p>
<div class="fragment"><div class="line"><span class="comment">// Underlying block device. Here, SPI Flash is fully used.</span></div>
<div class="line"><span class="comment">// One can use SlicingBlockDevice if we want a partition.</span></div>
<div class="line"><a class="code hl_class" href="classSPIFBlockDevice.html">SPIFBlockDevice</a> bd(PTE2, PTE4, PTE1, PTE5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Instantiate tdbstore with our block device and a maximum of 64 keys </span></div>
<div class="line">kvstore = <span class="keyword">new</span> TDBStore(64, &amp;bd);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> res;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize storage</span></div>
<div class="line">res = kvstore-&gt;init();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val1 = <span class="stringliteral">&quot;Value of key 1&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val2 = <span class="stringliteral">&quot;Updated value of key 1&quot;</span>;</div>
<div class="line"><span class="comment">// Add &quot;Key1&quot;</span></div>
<div class="line">res = kvstore-&gt;set(<span class="stringliteral">&quot;Key1&quot;</span>, val1, <span class="keyword">sizeof</span>(val1), 0);</div>
<div class="line"><span class="comment">// Update value of &quot;Key1&quot;</span></div>
<div class="line">res = kvstore-&gt;set(<span class="stringliteral">&quot;Key1&quot;</span>, val2, <span class="keyword">sizeof</span>(val2), 0);</div>
<div class="line"> </div>
<div class="line">uint_8 value[32];</div>
<div class="line"><span class="keywordtype">size_t</span> actual_size;</div>
<div class="line"><span class="comment">// Get value of &quot;Key1&quot;. Value should return the updated value.</span></div>
<div class="line">res = kvstore-&gt;get(<span class="stringliteral">&quot;Key1&quot;</span>, value, <span class="keyword">sizeof</span>(value), &amp;actual_size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove &quot;Key1&quot;</span></div>
<div class="line">res = kvstore-&gt;remove(<span class="stringliteral">&quot;Key1&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Incremental write, if need to generate large data with a small buffer</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> data_size = 1024;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>[8];</div>
<div class="line"> </div>
<div class="line">KVSTore::set_handle_t handle;</div>
<div class="line">res = kvstore-&gt;set_start(&amp;handle, <span class="stringliteral">&quot;Key2&quot;</span>, data_size, 0);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; data_size / <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>); i++) {</div>
<div class="line">    memset(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, i, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">    res = kvstore-&gt;set_add_data(handle, <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">}</div>
<div class="line">res = kvstore-&gt;set_finalize(handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate over all keys starting with &quot;Key&quot;</span></div>
<div class="line">res = 0;</div>
<div class="line">KVSTore::iterator_t it;</div>
<div class="line">kvstore-&gt;iterator_open(&amp;it, <span class="stringliteral">&quot;Key*&quot;</span>);</div>
<div class="line"><span class="keywordtype">char</span> key[KVSTore::KV_MAX_KEY_LENGTH];</div>
<div class="line"><span class="keywordflow">while</span> (!res) {</div>
<div class="line">    res = kvstore-&gt;iterator_next(&amp;it, key, <span class="keyword">sizeof</span>(key));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deinitialize TDBStore</span></div>
<div class="line">res = kvstore-&gt;deinit();</div>
<div class="ttc" id="aclassSPIFBlockDevice_html"><div class="ttname"><a href="classSPIFBlockDevice.html">SPIFBlockDevice</a></div><div class="ttdef"><b>Definition</b> SPIFBlockDevice.h:91</div></div>
<div class="ttc" id="awsf__trace_8c_html_a631cb00ea94506727e7ab9cdd27cf9cd"><div class="ttname"><a href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a></div><div class="ttdeci">uint8_t buf[8]</div><div class="ttdef"><b>Definition</b> wsf_trace.c:81</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md965"></a>
Standard usage of the Global Key Value interface</h3>
<p>The following example code shows how to use the previous example with the global key value interface. Here, <code>tdtbstore</code> is mapped to <code>"/tdbstore/"</code>.</p>
<p><b>Standard usage example - with global C-style APIs</b></p>
<p>This example assumes this code exists somewhere and is called during initialization:</p>
<div class="fragment"><div class="line"><span class="comment">// Assume TDBtore is already instantiated and initialized</span></div>
<div class="line"><span class="keyword">extern</span> TDBStore tdbstore;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> res;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attachment code. Should be called at initialization</span></div>
<div class="line">res = kv_init();</div>
<div class="line">res = kv_attach(<span class="stringliteral">&quot;tdbstore&quot;</span>, &amp;tdbstore);</div>
</div><!-- fragment --><p>This example shows how to access KVStore using C global APIs:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val1 = <span class="stringliteral">&quot;Value of key 1&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val2 = <span class="stringliteral">&quot;Updated value of key 1&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add &quot;Key1&quot;, now with full name, including &quot;/tdbstore/&quot; prefix.</span></div>
<div class="line">res = kv_set(<span class="stringliteral">&quot;/tdbstore/Key1&quot;</span>, val1, <span class="keyword">sizeof</span>(val1),  0);</div>
<div class="line"><span class="comment">// Update value of &quot;Key1&quot;</span></div>
<div class="line">res = kv_set(<span class="stringliteral">&quot;/tdbstore/Key1&quot;</span>, val2, <span class="keyword">sizeof</span>(val2), 0);</div>
<div class="line"> </div>
<div class="line">uint_8 value[32];</div>
<div class="line"><span class="keywordtype">size_t</span> actual_size;</div>
<div class="line"><span class="comment">// Get value of &quot;Key1&quot;. Value should return the updated value.</span></div>
<div class="line">res = kv_get(<span class="stringliteral">&quot;/tdbstore/Key1&quot;</span>, value, <span class="keyword">sizeof</span>(value), &amp;actual_size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove &quot;Key1&quot;</span></div>
<div class="line">res = kv_remove(<span class="stringliteral">&quot;/tdbstore/Key1&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Incremental write, if need to generate large data with a small buffer</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> data_size = 1024;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>[8];</div>
<div class="line"> </div>
<div class="line">kv_set_handle_t handle;</div>
<div class="line">res = kv_set_start(&amp;handle, <span class="stringliteral">&quot;/tdbstore/Key2&quot;</span>, data_size, 0);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; data_size / <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>); i++) {</div>
<div class="line">    memset(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, i, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">    res = kv_set_add_data(handle, <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">}</div>
<div class="line">res = kv_set_finalize(handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate over all keys starting with &quot;Key&quot; in tdbstore</span></div>
<div class="line">res = 0;</div>
<div class="line">kv_key_iterator_handle_t it;</div>
<div class="line">kv_iterator_open(&amp;it, <span class="stringliteral">&quot;/tdbstore/Key&quot;</span>);</div>
<div class="line"><span class="keywordtype">char</span> key[KV_MAX_KEY_LENGTH];</div>
<div class="line"><span class="keywordflow">while</span> (!res) {</div>
<div class="line">    res = kv_iterator_next(&amp;it, key, <span class="keyword">sizeof</span>(key));</div>
<div class="line">}</div>
<div class="line">res = kv_iterator_close(&amp;it);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
