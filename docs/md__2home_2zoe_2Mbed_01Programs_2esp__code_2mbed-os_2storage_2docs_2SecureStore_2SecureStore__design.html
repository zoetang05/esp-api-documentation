<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: SecureStore in Mbed OS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2SecureStore_2SecureStore__design.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">SecureStore in Mbed OS</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md966"></a></p>
<ul>
<li>SecureStore in Mbed OS<ul>
<li>Revision history</li>
</ul>
</li>
<li>Introduction<ul>
<li>Overview and background</li>
<li>Requirements and assumptions</li>
</ul>
</li>
<li>System architecture and high-level design<ul>
<li>Design basics<ul>
<li>Data layout</li>
<li>Basic implementation concepts</li>
</ul>
</li>
</ul>
</li>
<li>Detailed design<ul>
<li>Class header</li>
<li>Important data structures</li>
<li>Initialization and reset</li>
<li>Core APIs</li>
<li>Incremental set APIs</li>
<li>Key iterator APIs</li>
</ul>
</li>
<li>Usage scenarios and examples<ul>
<li>Standard usage of the class</li>
</ul>
</li>
<li>Other information<ul>
<li>Open issues</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md967"></a>
Revision history</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision   </th><th class="markdownTableHeadNone">Date   </th><th class="markdownTableHeadNone">Authors   </th><th class="markdownTableHeadNone">Mbed OS version   </th><th class="markdownTableHeadNone">Comments    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.0   </td><td class="markdownTableBodyNone">02 October 2018   </td><td class="markdownTableBodyNone">David Saada (<a href="https://github.com/davidsaada/">@davidsaada</a>)   </td><td class="markdownTableBodyNone">5.11+   </td><td class="markdownTableBodyNone">Initial revision   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md968"></a>
Introduction</h1>
<h3><a class="anchor" id="autotoc_md969"></a>
Overview and background</h3>
<p>SecureStore is a <a class="el" href="md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2KVStore_2KVStore__design.html">KVStore</a> based storage solution, providing security features on the stored data, such as encryption, authentication, rollback protection and write once, over an underlying KVStore class. It references an additional KVStore class for storing the rollback protection keys.</p>
<h3><a class="anchor" id="autotoc_md970"></a>
Requirements and assumptions</h3>
<p>SecureStore assumes that the underlying KVStore instances are instantiated and initialized.</p>
<h1><a class="anchor" id="autotoc_md971"></a>
System architecture and high-level design</h1>
<h2><a class="anchor" id="autotoc_md972"></a>
Design basics</h2>
<p>SecureStore is a storage class, derived from KVStore. It adds security features to the underlying key value store.</p>
<p>As such, it offers all KVStore APIs, with additional security options (which can be selected using the creation flags at set). These include:</p>
<ul>
<li>Encryption: Data is encrypted using the AES-CTR encryption method, with a randomly generated 8-byte IV. Key is derived from Device Key, using the NIST SP 800-108 KDF in counter mode spec, where salt is the key trimmed to 32 bytes, with "ENC" as prefix. Flag here is called "require confidentiality flag". <br  />
</li>
<li>Rollback protection: (Requires authentication) CMAC is stored in a designated rollback protected storage (also of KVStore type) and compared to when reading the data under the same KVStore key. A missing or different key in the rollback protected storage results in an error. The flag here is called "Require replay protection flag".</li>
<li>Write once: Key can only be stored once and can't be removed. The flag here is called "Write once flag".</li>
</ul>
<p>SecureStore maintains data integrity using a record CMAC. This 16-byte CMAC is calculated on all stored data (including key &amp; metadata) and stored at the end of the record. When reading the record, SecureStore compares the calculated CMAC with the stored one. In the case of encryption, CMAC is calculated on the encrypted data. The key used for generating the CMAC is derived from Device Key, where salt is the key trimmed to 32 bytes, with "AUTH" as prefix.</p>
<p><img src="./SecureStore_layers.jpg" alt="SecureStore Layers" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md973"></a>
Data layout</h3>
<p>When storing the data, it is stored with a preceding metadata header. Metadata includes flags and security related parameters, such as IV. The CMAC, calculated for authentication, is stored at the end of the data as it is calculated on the fly, so it can't be stored with the metadata. <br  />
</p>
<p><img src="./SecureStore_record.jpg" alt="SecureStore Record" class="inline"/></p>
<p>Fields are:</p>
<ul>
<li>Metadata size: Size of metadata header.</li>
<li>Revision: SecureStore revision (currently 1).</li>
<li>Data size: Size of user data.</li>
<li>Flags: User flags.</li>
<li>IV: Random generated IV.</li>
<li>Pad: Pad data to a multiple of 16 bytes (due to encryption).</li>
<li>CMAC: CMAC calculated on key, metadata and data.</li>
</ul>
<h3><a class="anchor" id="autotoc_md974"></a>
Basic implementation concepts</h3>
<p>Because the code can't construct a single buffer to store all data (including metadata and possibly encrypted data) in one shot, setting the data occurs in chunks, using the incremental set APIs. Get uses the offset argument to extract metadata, data and CMAC separately. <br  />
</p>
<p>Rollback protection (RBP) keys are stored in the designated rollback protection storage, which is also of KVStore type. RBP keys are the same as the SecureStore keys. <br  />
 This RBP storage is also used for storing the CMAC in write once case, as otherwise an attacker can delete this key from the underlying storage and modify this flag.</p>
<h1><a class="anchor" id="autotoc_md975"></a>
Detailed design</h1>
<p><img src="./SecureStore_class_hierarchy.jpg" alt="SecureStore Class Hierarchy" class="inline"/></p>
<p>Functionality, as defined by KVStore, includes the following:</p>
<ul>
<li>Initialization and reset.</li>
<li>Core actions: get, set and remove.</li>
<li>Incremental set actions.</li>
<li>Iterator actions.</li>
</ul>
<h3><a class="anchor" id="autotoc_md976"></a>
Class header</h3>
<p>SecureStore has the following header:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SecureStore : KVStore {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SecureStore(KVStore *underlying_kv, KVStore *rbp_kv);</div>
<div class="line">    <span class="keyword">virtual</span> ~SecureStore();</div>
<div class="line">         </div>
<div class="line">    <span class="comment">// Initialization and formatting</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> init();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> deinit();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> reset();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Core API</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> size, uint32_t create_flags);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">void</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">size_t</span> *actual_size = NULL, <span class="keywordtype">size_t</span> offset = 0);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get_info(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, info_t *<a class="code hl_struct" href="structinfo.html">info</a>);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> remove(<span class="keyword">const</span> <span class="keywordtype">char</span> *key);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Incremental set API</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_start(set_handle_t *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">size_t</span> final_data_size, uint32_t create_flags);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_add_data(set_handle_t handle, <span class="keyword">const</span> <span class="keywordtype">void</span> *value_data, <span class="keywordtype">size_t</span> data_size);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_finalize(set_handle_t handle);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Key iterator</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_open(iterator_t *it, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix = NULL);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_next(iterator_t it, <span class="keywordtype">char</span> *key, <span class="keywordtype">size_t</span> key_size);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_close(iterator_t it);</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Mutex _mutex;</div>
<div class="line">    KVStore *_underlying_kv;</div>
<div class="line">    KVStore *_rbp_kv;</div>
<div class="line">    <span class="keywordtype">void</span> *_entropy;</div>
<div class="line">    uint8_t *_scratch_buf;</div>
<div class="line">}</div>
<div class="ttc" id="astructbuffer_html"><div class="ttname"><a href="structbuffer.html">buffer</a></div><div class="ttdef"><b>Definition</b> ns_buffer.h:201</div></div>
<div class="ttc" id="astructinfo_html"><div class="ttname"><a href="structinfo.html">info</a></div><div class="ttdef"><b>Definition</b> kvstore_global_api.h:38</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md977"></a>
Important data structures</h3>
<div class="fragment"><div class="line"><span class="comment">// Record header</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint16_t metadata_size;</div>
<div class="line">    uint16_t revision;</div>
<div class="line">    uint32_t data_size;</div>
<div class="line">    uint32_t create_flags;</div>
<div class="line">    uint8_t  iv[8];</div>
<div class="line">} record_metadata_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// incremental set handle</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    record_metadata_t metadata;</div>
<div class="line">    bd_size_t offset;</div>
<div class="line">    <span class="keywordtype">char</span> *key;</div>
<div class="line">    <span class="keywordtype">void</span> *encrypt_handle;</div>
<div class="line">    <span class="keywordtype">void</span> *auth_handle;</div>
<div class="line">    KVStore::set_handle_t underlying_handle;</div>
<div class="line">} inc_set_handle_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterator handle</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    KVStore::iterator_t underlying_it;</div>
<div class="line">} key_iterator_handle_t;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md978"></a>
Initialization and reset</h3>
<p><b>init function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int init();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>if <code>_is_initialized</code>, return OK.</li>
<li>Take <code>_mutex</code>.</li>
<li>Initialize <code>_entropy</code> with TLS entropy APIs.</li>
<li>Using <code>DeviceKey</code> APIs, get the device key.</li>
<li>Allocate <code>_scratch_buf</code> as a 32 byte array.</li>
<li>Set <code>_is_initialized</code> to true.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>deinit function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int deinit();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>if not <code>_is_initialized</code>, return OK.</li>
<li>Take <code>_mutex</code>.</li>
<li>Deinitialize <code>_entropy</code>.</li>
<li>Deallocate <code>_scratch_buf</code>.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>reset function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int reset();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>Call <code>_underlying_kv</code> <code>reset</code> API.</li>
<li>Call <code>_rbp_kv</code> <code>reset</code> API.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md979"></a>
Core APIs</h3>
<p><b>set function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set(const char *key, const void *buffer, size_t size, uint32_t create_flags);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Call <code>set_start</code> with all fields and a local <code>set_handle_t</code> variable.</li>
<li>Call <code>set_add_data</code> with <code>buffer</code> and <code>size</code>.</li>
<li>Call <code>set_finalize</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>get function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int get(const char *key, void *buffer, size_t buffer_size, size_t *actual_size = NULL, size_t offset = 0);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>if not <code>_is_initialized</code> return error.</li>
<li>Take <code>_mutex</code>.</li>
<li>Call <code>_underlying_kv</code> <code>get</code> API with <code>metadata</code> size into a <code>metadata</code> local structure.</li>
<li>If failure:<ul>
<li>If rollback protection or write once flag set:<ul>
<li>Call <code>_rbp_kv</code> <code>get</code> API on a local <code>rbp_cmac</code> variable, key is <code>key</code>, size 16.</li>
<li>If no error, return "RBP authentication" error.</li>
</ul>
</li>
<li>Return "Key not found error".</li>
</ul>
</li>
<li>Derive a key from device key and <code>key</code>.</li>
<li>Allocate and initialize <code>auth_handle</code> CMAC calculation local handle with derived key.</li>
<li>Using <code>auth_handle</code> handle, calculate CMAC on <code>key</code> and <code>metadata</code>.</li>
<li>If encrypt flag set:<ul>
<li>Derive a key from device key and <code>key</code>.</li>
<li>Allocate and initialize a local <code>enc_handle</code> AES-CTR local handle with derived key and <code>iv</code> field.</li>
</ul>
</li>
<li>Set <code>data_size</code> local variable to data size in metadata.</li>
<li>Set <code>actual_size</code> to the minimum of <code>buffer_size</code> and <code>data_size</code>.</li>
<li>Set <code>current_offset</code> to 0.</li>
<li>While <code>data_size</code> &gt; 0:<ul>
<li>If <code>current_offset</code> between <code>offset</code> and <code>actual_size</code>.<ul>
<li>Set <code>dest_buf</code> to <code>buffer</code> and <code>chunk_size</code> to <code>actual_size</code>.</li>
</ul>
</li>
<li>Else:<ul>
<li>Set <code>dest_buf</code> to <code>_scratch_buf</code> and <code>chunk_size</code> to <code>actual_size</code>.</li>
</ul>
</li>
<li>Call <code>_underlying_kv</code> <code>get</code> API with <code>dest_buf</code> and <code>chunk_size</code>.</li>
<li>Calculate CMAC on <code>dest_buf</code>, using <code>_auth_handle</code> handle.</li>
<li>If encrypt flag set, decrypt <code>dest_buf</code> (in place) using <code>_enc_handle</code> handle.</li>
<li>Decrement <code>data_size</code> by <code>chunk_size</code>.</li>
</ul>
</li>
<li>Call <code>_underlying_kv</code> <code>get</code> API with on a local <code>read_cmac</code> variable, size 16.</li>
<li>Generate CMAC on local <code>cmac</code> variable .</li>
<li>Using <code>mbedtls_ssl_safer_memcmp</code> function, compare <code>read_cmac</code> with <code>cmac</code>. Return "data corrupt error" if no match.</li>
<li>If rollback protection or write once flags set:<ul>
<li>Call <code>_rbp_kv</code> <code>get</code> API on a local <code>rbp_cmac</code> variable, key is <code>key</code>, size 16.</li>
<li>If <code>rbp_cmac</code> doesn't match <code>cmac</code>, clear <code>buffer</code> and return "RBP authentication" error.</li>
</ul>
</li>
<li>Deinitialize and free <code>auth_handle</code> and <code>enc_handle</code>.</li>
<li>Release <code>_mutex</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>get_info function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int get_info(const char *key, info_t *info);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If not <code>_is_initialized</code>, return error.</li>
<li>Call <code>get</code> API with <code>key</code> and 0 in <code>buffer_size</code> parameter.</li>
<li>If failed, return error code.</li>
<li>Call <code>_underlying_kv</code> <code>get</code> API with <code>metadata</code> size and <code>key</code>.</li>
<li>Fill fields in <code>info</code> according to <code>metadata</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>remove function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int remove(const char *key);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If not <code>_is_initialized</code>, return error.</li>
<li>Take <code>_mutex</code>.</li>
<li>Call <code>_underlying_kv</code> <code>get</code> API with <code>metadata</code> size and <code>key</code>.</li>
<li>If not found, return "Not found" error.</li>
<li>If write once flag set, return "Already exists" error.</li>
<li>Call <code>_underlying_kv</code> <code>remove</code> API with <code>key</code>.</li>
<li>If rollback protect flag set, call <code>_rbp_kv</code> <code>remove</code> API with <code>key</code> as key.</li>
<li>Return OK.</li>
</ul>
<h3><a class="anchor" id="autotoc_md980"></a>
Incremental set APIs</h3>
<p><b>set_start function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set_start(set_handle_t *handle, const char *key, size_t final_data_size, uint32_t create_flags);</code></p>
<p>Pseudo code:</p><ul>
<li>Take <code>_mutex</code>.</li>
<li>Allocate an <code>inc_set_handle_t</code> and assign in handle.</li>
<li>If flags include write once flag:<ul>
<li>Call <code>_underlying_kv</code> <code>get_info</code> API.</li>
<li>If key exists, return "already exists" error.</li>
<li>Call <code>_rbp_kv</code> <code>get</code> API with <code>key</code> as key. If key exists, return "already exists" error.</li>
</ul>
</li>
<li>If encrypt flag set:<ul>
<li>Derive a key from device key and <code>key</code> as salt (trimmed to 32 bytes with "ENC" as prefix).</li>
<li>Using TLS entropy function on <code>_entropy</code> handle, randomly generate <code>iv</code> field.</li>
<li>Allocate and initialize <code>enc_handle</code> AES-CTR handle field with derived key and <code>iv</code> field.</li>
</ul>
</li>
<li>Fill all available fields in <code>metadata</code>.</li>
<li>Derive a key from device key and <code>key</code> as salt (trimmed to 32 bytes with "AUTH" as prefix).</li>
<li>Allocate and initialize <code>auth_handle</code> CMAC calculation handle field with derived key.</li>
<li>Using <code>auth_handle</code> handle, calculate CMAC on <code>key</code> and <code>metadata</code>.</li>
<li>Call <code>_underlying_kv</code> <code>set_start</code> API.</li>
<li>Call <code>_underlying_kv</code> <code>set_add_data</code> API with <code>metadata</code> field.</li>
<li>Return OK.</li>
</ul>
<p><b>set_add_data function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set_add_data(set_handle_t handle, const void *value_data, size_t data_size);</code></p>
<p>Pseudo code:</p>
<ul>
<li>If <code>offset</code> + <code>data_size</code> &gt; data size in handle, return error.</li>
<li>If flags include encryption:<ul>
<li>Iterate over <code>value_data</code> field in chunks of <code>_scratch_buf</code> size.<ul>
<li>Using <code>enc_handle</code> handle field, encrypt chunk into <code>_scratch_buf</code>.</li>
<li>Using <code>auth_handle</code> handle field, update CMAC of <code>_scratch_buf</code>.</li>
<li>Call <code>_underlying_kv</code> <code>set_add_data</code> API with <code>_scratch_buf</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Else:<ul>
<li>Using <code>auth_handle</code> handle field, update CMAC of <code>value_data</code>.</li>
<li>Call <code>_underlying_kv</code> <code>set_add_data</code> API with <code>value_data</code>.</li>
</ul>
</li>
<li>Update <code>offset</code> field in handle. <br  />
</li>
<li>Return OK.</li>
</ul>
<p><b>set_finalize function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set_finalize(set_handle_t handle);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Initialize a local <code>cmac</code> 16-byte array to 0.</li>
<li>If authentication flag set, using <code>auth_handle</code> handle field, generate <code>cmac</code>.</li>
<li>Call <code>_underlying_kv</code> <code>set_add_data</code> API with <code>cmac</code>.</li>
<li>Call <code>_underlying_kv</code> <code>set_finalize</code>.</li>
<li>If rollback protect or write once flags set, call <code>_rbp_kv</code> <code>set</code> API with <code>key</code> as key and <code>cmac</code> as data.</li>
<li>Deinitialize and free <code>auth_handle</code> and <code>enc_handle</code>.</li>
<li>Free <code>handle</code>.</li>
<li>Release <code>_mutex</code>.</li>
<li>Return OK.</li>
</ul>
<h3><a class="anchor" id="autotoc_md981"></a>
Key iterator APIs</h3>
<p><b>iterator_open function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int iterator_open(iterator_t *it, const char *prefix = NULL);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Allocate a <code>key_iterator_handle_t</code> structure into <code>it</code>.</li>
<li>Take <code>_mutex</code>.</li>
<li>Call <code>_underlying_kv</code> <code>iterator_open</code> with <code>underlying_it</code> field.</li>
<li>Release <code>_mutex</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>iterator_next function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int iterator_next(iterator_t it, char *key, size_t key_size);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>Call <code>_underlying_kv</code> <code>iterator_next</code> with <code>underlying_it</code> field.</li>
<li>Release <code>_mutex</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>iterator_close function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int iterator_close(iterator_t it);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>Call <code>_underlying_kv</code> <code>iterator_close</code> with <code>underlying_it</code> field.</li>
<li>Release <code>_mutex</code>.</li>
<li>Deallocate <code>it</code>.</li>
<li>Return OK.</li>
</ul>
<h1><a class="anchor" id="autotoc_md982"></a>
Usage scenarios and examples</h1>
<h3><a class="anchor" id="autotoc_md983"></a>
Standard use of the class</h3>
<p>The following example code shows standard use of the SecureStore class:</p>
<p><b>Standard usage example</b></p>
<div class="fragment"><div class="line"><span class="comment">// Underlying key value store - here TDBStore (should be instantiated and initialized)</span></div>
<div class="line"><span class="keyword">extern</span> TDBStore tdbstore;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Rollback protect store - also of TDBStore type (should be instantiated and initialized)</span></div>
<div class="line"><span class="keyword">extern</span> TDBStore rbp_tdbstore;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Instantiate SecureStore with tdbstore as underlying key value store and rbp_tdbstore as RBP storage</span></div>
<div class="line">SecureStore secure_store(&amp;tdbstore, &amp;rbp_tdbstore);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> res;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize secure_store</span></div>
<div class="line">res = secure_store.init();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val1 = <span class="stringliteral">&quot;Value of key 1&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val2 = <span class="stringliteral">&quot;Updated value of key 1&quot;</span>;</div>
<div class="line"><span class="comment">// Add &quot;Key1&quot; with encryption flag</span></div>
<div class="line">res = secure_store.set(<span class="stringliteral">&quot;Key1&quot;</span>, val1, <span class="keyword">sizeof</span>(val1), KVSTore::REQUIRE_CONFIDENTIALITY_FLAG);</div>
<div class="line"><span class="comment">// Update value of &quot;Key1&quot; (flags must be the same per key)</span></div>
<div class="line">res = secure_store.set(<span class="stringliteral">&quot;Key1&quot;</span>, val2, <span class="keyword">sizeof</span>(val2), KVSTore::REQUIRE_CONFIDENTIALITY_FLAG);</div>
<div class="line"> </div>
<div class="line">uint_8 value[32];</div>
<div class="line"><span class="keywordtype">size_t</span> actual_size;</div>
<div class="line"><span class="comment">// Get value of &quot;Key1&quot;. Value should return the updated value.</span></div>
<div class="line">res = secure_store.get(<span class="stringliteral">&quot;Key1&quot;</span>, value, <span class="keyword">sizeof</span>(value), &amp;actual_size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove &quot;Key1&quot;</span></div>
<div class="line">res = secure_store.remove(<span class="stringliteral">&quot;Key1&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Incremental write, if need to generate large data with a small buffer</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> data_size = 1024;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>[8];</div>
<div class="line"> </div>
<div class="line">KVSTore::set_handle_t handle;</div>
<div class="line">res = secure_store.set_start(&amp;handle, <span class="stringliteral">&quot;Key2&quot;</span>, data_size, 0);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; data_size / <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>); i++) {</div>
<div class="line">    memset(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, i, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">    res = secure_store.set_add_data(handle, <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">}</div>
<div class="line">res = secure_store.set_finalize(handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate over all keys starting with &quot;Key&quot;</span></div>
<div class="line">res = 0;</div>
<div class="line">KVSTore::iterator_t it;</div>
<div class="line">secure_store.iterator_open(&amp;it, <span class="stringliteral">&quot;Key*&quot;</span>);</div>
<div class="line"><span class="keywordtype">char</span> key[KVSTore::KV_MAX_KEY_LENGTH];</div>
<div class="line"><span class="keywordflow">while</span> (!res) {</div>
<div class="line">    res = secure_store.iterator_next(&amp;it, key, <span class="keyword">sizeof</span>(key)e);</div>
<div class="line">}</div>
<div class="line">res = secure_store.iterator_close(&amp;it);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deinitialize SecureStore</span></div>
<div class="line">res = secure_store.deinit();</div>
<div class="ttc" id="awsf__trace_8c_html_a631cb00ea94506727e7ab9cdd27cf9cd"><div class="ttname"><a href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a></div><div class="ttdeci">uint8_t buf[8]</div><div class="ttdef"><b>Definition</b> wsf_trace.c:81</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md984"></a>
Other information</h1>
<h3><a class="anchor" id="autotoc_md985"></a>
Open issues</h3>
<ul>
<li>Need to figure a way to prevent mutex abuse in incremental set APIs. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
