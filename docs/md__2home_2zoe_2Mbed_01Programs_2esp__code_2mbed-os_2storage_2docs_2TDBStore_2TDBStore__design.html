<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: TDBStore in Mbed OS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2TDBStore_2TDBStore__design.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">TDBStore in Mbed OS</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md986"></a></p>
<ul>
<li>TDBStore in Mbed OS<ul>
<li>Revision history</li>
</ul>
</li>
<li>Introduction<ul>
<li>Overview and background</li>
<li>Requirements and assumptions</li>
</ul>
</li>
<li>System architecture and high-level design<ul>
<li>Design basics<ul>
<li>Sequential writes</li>
<li>Memory layout and areas</li>
<li>Garbage collection</li>
<li>RAM Table</li>
</ul>
</li>
</ul>
</li>
<li>Detailed design<ul>
<li>Class header</li>
<li>Important data structures</li>
<li>Initialization and reset</li>
<li>Core APIs</li>
<li>Incremental set APIs</li>
<li>Key iterator APIs</li>
</ul>
</li>
<li>Usage scenarios and examples<ul>
<li>Standard usage of the class</li>
</ul>
</li>
<li>Other information<ul>
<li>Open issues</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md987"></a>
Revision history</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision   </th><th class="markdownTableHeadNone">Date   </th><th class="markdownTableHeadNone">Authors   </th><th class="markdownTableHeadNone">Mbed OS version   </th><th class="markdownTableHeadNone">Comments    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.0   </td><td class="markdownTableBodyNone">16 September 2018   </td><td class="markdownTableBodyNone">David Saada (<a href="https://github.com/davidsaada/">@davidsaada</a>)   </td><td class="markdownTableBodyNone">5.11+   </td><td class="markdownTableBodyNone">Initial revision   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md988"></a>
Introduction</h1>
<h3><a class="anchor" id="autotoc_md989"></a>
Overview and background</h3>
<p>Tiny Database Storage (TDBStore) is a lightweight module that stores data on flash storage. It is part of of the <a class="el" href="md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2docs_2KVStore_2KVStore__design.html">KVStore</a> class family, meaning it supports the get/set interface. It is designed to optimize performance (speed of access), reduce wearing of the flash and minimize storage overhead. It is also resilient to power failures.</p>
<h3><a class="anchor" id="autotoc_md990"></a>
Requirements and assumptions</h3>
<p>TDBStore assumes the underlying block device is fully dedicated to it (starting offset 0). If you want to dedicate only a part of the device to TDBStore, use a sliced block device, typically with <code><a class="el" href="classSlicingBlockDevice.html">SlicingBlockDevice</a></code>.</p>
<h1><a class="anchor" id="autotoc_md991"></a>
System architecture and high-level design</h1>
<h2><a class="anchor" id="autotoc_md992"></a>
Design basics</h2>
<p>TDBStore includes the following design basics: <br  />
</p><ul>
<li>Sequential writes: TDBStore performs all writes sequentially on the physical storage as records, superseding the previous ones for the same key. <br  />
</li>
<li>Memory layout - areas: TDBStore divides the physical storage equally into two areas - active and standby. All writes are made to the end of the active area's free space. When the active area is exhausted, a garbage collection process is invoked, copying only the up to date values of all keys to the standby area, and turning it active.</li>
<li>RAM table: Indexes all keys in RAM, thus allowing fast access to their records in the physical storage. <br  />
</li>
</ul>
<h3><a class="anchor" id="autotoc_md993"></a>
Sequential writes</h3>
<p>All writes occur sequentially on the physical storage as records, superseding the previous ones for the same key. Each data record is written right after the last written one. If a key is updated, a new record with this key is written, overriding the previous value of this key. If a key is deleted, a new record with a "deleted" flag is added.</p>
<p>Writes expect the storage to be erased. However, TDBStore takes the "erase as you go" approach, meaning that when it crosses a sector boundary, it checks whether the next sector is erased. If not, it erases the next sector. This saves time during initialization and garbage collection.</p>
<h3><a class="anchor" id="autotoc_md994"></a>
Memory layout and areas</h3>
<p><img src="./TDBStore_areas.jpg" alt="TDBStore Areas" class="inline"/></p>
<p>Each key is stored in a separate record on the active area. The first record in the area is the master record. Its main purpose is to hold an area version, protecting you against a case in which there are two valid areas. (This can happen in the extreme cases of power failures.)</p>
<p><img src="./TDBStore_record.jpg" alt="TDBStore Record" class="inline"/></p>
<p>A 24-byte header precedes a record key and data. Fields are:</p>
<ul>
<li>Magic: a constant value, for quick validity checking.</li>
<li>Header size: size of header.</li>
<li>Revision: TDBStore revision (currently 1).</li>
<li>User flags: Flags received from user. Currently only write once is dealt with (others are ignored).</li>
<li>Internal flags: Internal TDBStore flags (currently only includes deleted flag).</li>
<li>Key size: size of key.</li>
<li>Data size: size of data.</li>
<li>CRC: a 32-bit CRC, calculated on header (except CRC), key and data.</li>
<li>Programming size pad: padding to the storage programming size.</li>
</ul>
<h3><a class="anchor" id="autotoc_md995"></a>
Garbage collection</h3>
<p>Garbage collection (GC) is the process of compacting the records stored in the active area to the standby one, by copying only the most recent values of all the keys (without the ones marked as deleted). Then, the standby area becomes the active one and the previously active area is erased (not fully, only its first sector).</p>
<p>GC is invoked in the following cases:</p>
<ul>
<li>When the active area is exhausted.</li>
<li>During initialization, when a corruption is found while scanning the active area. In this case, GC is performed up to the record preceding the corruption.</li>
</ul>
<h3><a class="anchor" id="autotoc_md996"></a>
Reserved space</h3>
<p>The active area includes a fixed and small reserved space. This space is used for a quick storage and extraction of a write-once data (such as the device key). Its size is 32 bytes, aligned up to the underlying block device. Once it is written, nothing can modify it. It is also copied between the areas during garbage collection process.</p>
<h3><a class="anchor" id="autotoc_md997"></a>
RAM table</h3>
<p>All keys are indexed in memory using a RAM table. Key names are represented by a 32-bit hash. The table includes the hash (and sorted by it) and the offset to the key record in the block device. This allows both fast searching in the table and a low memory footprint. To keep code simple, the same CRC function used for recored validation is used for hash calculation (because TLS hash calculation is too heavy).</p>
<p><img src="./TDBStore_ram_table.jpg" alt="TDBStore RAM Table" class="inline"/></p>
<p>Key names may produce duplicate hash values. This is OK because the hash is only used for fast access to the key, and the key needs to be verified when accessing the storage. If the key doesn't match, move to the next duplicate in the table.</p>
<h1><a class="anchor" id="autotoc_md998"></a>
Detailed design</h1>
<p>TDBStore fully implements the KVStore interface over a block device. Due to the fact it may write to the block device in program units that don't have to match the underlying device program units, it should use a <code><a class="el" href="classBufferedBlockDevice.html">BufferedBlockDevice</a></code> for that purpose.</p>
<p><img src="./TDBStore_class_hierarchy.jpg" alt="TDBStore Class Hierarchy" class="inline"/></p>
<p>Functionality, as defined by KVStore, includes the following:</p>
<ul>
<li>Initialization and reset.</li>
<li>Core actions: get, set and remove.</li>
<li>Incremental set actions.</li>
<li>Iterator actions.</li>
</ul>
<h3><a class="anchor" id="autotoc_md999"></a>
Class header</h3>
<p>TDBStore has the following header:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TDBStore : KVStore {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    TDBSTore(<a class="code hl_class" href="classBlockDevice.html">BlockDevice</a> *bd = 0);</div>
<div class="line">    <span class="keyword">virtual</span> ~TDBSTore();</div>
<div class="line">         </div>
<div class="line">    <span class="comment">// Initialization and reset</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> init();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> deinit();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> reset();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Core API</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> size, uint32_t create_flags);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">void</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">size_t</span> *actual_size = NULL, <span class="keywordtype">size_t</span> offset = 0);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> get_info(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, info_t *<a class="code hl_struct" href="structinfo.html">info</a>);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> remove(<span class="keyword">const</span> <span class="keywordtype">char</span> *key);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Incremental set API</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_start(set_handle_t *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">size_t</span> final_data_size, uint32_t create_flags);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_add_data(set_handle_t handle, <span class="keyword">const</span> <span class="keywordtype">void</span> *value_data, <span class="keywordtype">size_t</span> data_size);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> set_finalize(set_handle_t handle);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Key iterator</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_open(iterator_t *it, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix = NULL);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_next(iterator_t it, <span class="keywordtype">char</span> *key, <span class="keywordtype">size_t</span> key_size);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> iterator_close(iterator_t it);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Reserved space APIs</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> reserved_space_set(<span class="keywordtype">void</span> *data);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> reserved_space_get(<span class="keywordtype">void</span> *data);</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Mutex _mutex;</div>
<div class="line">    <span class="keywordtype">void</span> *_ram_table;</div>
<div class="line">    <span class="keywordtype">size_t</span> *_max_keys;</div>
<div class="line">    <span class="keywordtype">size_t</span> *_num_keys;</div>
<div class="line">    <a class="code hl_class" href="classBlockDevice.html">BlockDevice</a> *_bd;</div>
<div class="line">    bd_addr_t _free_space_offset;</div>
<div class="line">    <a class="code hl_class" href="classBufferedBlockDevice.html">BufferedBlockDevice</a> *_buff_bd;</div>
<div class="line">    <span class="keywordtype">bool</span> _is_initialized;</div>
<div class="line">    <span class="keywordtype">int</span> _active_area;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Important internal functions</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// find record offset in flash</span></div>
<div class="line">    <span class="keywordtype">int</span> find_record(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, uint32_t *hash, bd_size_t *bd_offset, <span class="keywordtype">size_t</span> ram_table_ind);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// garbage collection</span></div>
<div class="line">    <span class="keywordtype">int</span> garbage_collection(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> size, uint32_t create_flags);</div>
<div class="line">}</div>
<div class="ttc" id="aclassBlockDevice_html"><div class="ttname"><a href="classBlockDevice.html">BlockDevice</a></div><div class="ttdef"><b>Definition</b> BlockDevice.h:48</div></div>
<div class="ttc" id="aclassBufferedBlockDevice_html"><div class="ttname"><a href="classBufferedBlockDevice.html">BufferedBlockDevice</a></div><div class="ttdef"><b>Definition</b> BufferedBlockDevice.h:31</div></div>
<div class="ttc" id="astructbuffer_html"><div class="ttname"><a href="structbuffer.html">buffer</a></div><div class="ttdef"><b>Definition</b> ns_buffer.h:201</div></div>
<div class="ttc" id="astructinfo_html"><div class="ttname"><a href="structinfo.html">info</a></div><div class="ttdef"><b>Definition</b> kvstore_global_api.h:38</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1000"></a>
Important data structures</h3>
<div class="fragment"><div class="line"><span class="comment">// RAM table entry</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint32_t  hash;</div>
<div class="line">    bd_size_t bd_offset;</div>
<div class="line">} ram_table_entry_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Record header</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint32_t magic;</div>
<div class="line">    uint16_t header_size;</div>
<div class="line">    uint16_t revision;</div>
<div class="line">    uint32_t user_flags;</div>
<div class="line">    uint16_t int_flags;</div>
<div class="line">    uint16_t key_size;</div>
<div class="line">    uint32_t data_size;</div>
<div class="line">    uint32_t crc;</div>
<div class="line">} record_header_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// incremental set handle</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    record_header_t header;</div>
<div class="line">    bd_size_t bd_base_offset;</div>
<div class="line">    bd_size_t bd_curr_offset;</div>
<div class="line">    uint32_t ram_table_ind;</div>
<div class="line">    uint32_t hash;</div>
<div class="line">    <span class="keywordtype">bool</span> new_key;</div>
<div class="line">} inc_set_handle_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterator handle</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">size_t</span> ram_table_ind;</div>
<div class="line">    <span class="keywordtype">char</span> *prefix;</div>
<div class="line">} key_iterator_handle_t;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1001"></a>
Initialization and reset</h3>
<p><b>init function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int init();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If <code>_is_initialized</code> return OK.</li>
<li>Take <code>_mutex</code>.</li>
<li>Set <code>_max_keys</code> to an initial value of 32.</li>
<li>Allocate <code>_ram_table</code> as an array of <code>_max_keys</code>.</li>
<li>Allocate <code>_buff_bd</code> with <code>_bd</code> as the underlying block device, and initialize it.</li>
<li>Check validity of master records on both areas.</li>
<li>If one is valid, set its area as <code>_active_area</code>.</li>
<li>If both are valid, set the one area whose master record has the higher version as <code>_active_area</code>. Erase first sector of the other one.</li>
<li>If none are valid, set area 0 as <code>_active_area</code>, and write master record with version 0.</li>
<li>Traverse active area until reaching an erased sector.<ul>
<li>Read current record and check its validity (calculte CRC).</li>
<li>If not valid, perform garbage collection and exit loop.</li>
<li>Advance <code>_free_space_offset</code>.</li>
<li>Call <code>find_record</code> function to calculate hash and find key.</li>
<li>If not found, add new RAM table entry with current hash.</li>
<li>Update position of key in RAM table.</li>
</ul>
</li>
<li>Set <code>_is_initialized</code> to true.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>deinit function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int deinit();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>If not <code>_is_initialized</code>, return OK.</li>
<li>Take <code>_mutex</code>.</li>
<li>Deinitialize <code>_buff_bd</code>, and free it.</li>
<li>Free <code>_ram_table</code>.</li>
<li>Set <code>_is_initialized</code> to false.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>reset function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int reset();</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>Erase first sector in both areas.</li>
<li>Set <code>_active_area</code> to 0.</li>
<li>Write a master record with version 0.</li>
<li>Set <code>_free_space_offset</code> to end of master record.</li>
<li>Set <code>_num_keys</code> to 0.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1002"></a>
Core APIs</h3>
<p><b>set function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set(const char *key, const void *buffer, size_t size, uint32_t create_flags);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>if not <code>_is_initialized</code>, return "not initialized" error.</li>
<li>Call <code>set_start</code> with all fields and a local <code>set_handle_t</code> variable.</li>
<li>Call <code>set_add_data</code> with <code>buffer</code> and <code>size</code>.</li>
<li>Call <code>set_finalize</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>get function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int get(const char *key, void *buffer, size_t buffer_size, size_t *actual_size = NULL, size_t offset = 0);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>if not <code>_is_initialized</code>, return "not initialized" error.</li>
<li>Take <code>_mutex</code>.</li>
<li>Call <code>find_record</code> to find record in storage.</li>
<li>If not found, return "not found" error.</li>
<li>Read header, and calculate CRC on it.</li>
<li>Update CRC with key (if offset is 0).</li>
<li>Read data into user buffer, starting offset. Actual size is minimum of buffer size and remainder of data.</li>
<li>If offset is 0,<ul>
<li>Update CRC with buffer.</li>
<li>Compare calculate CRC with header CRC. Return "data corrupt" error if different.</li>
</ul>
</li>
<li>Release <code>_mutex</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>get_info function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int get_info(const char *key, info_t *info);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>if not <code>_is_initialized</code>, return "not initialized" error.</li>
<li>Take <code>_mutex</code>.</li>
<li>Call <code>find_record</code> to find record in storage.</li>
<li>If not found, return "not found" error.</li>
<li>Read header.</li>
<li>Copy relevant fields from header into structure.</li>
<li>Release <code>_mutex</code>.</li>
<li>Return OK.</li>
</ul>
<p><b>remove function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int remove(const char *key);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Call <code>set</code> function with <code>key</code>, delete flag set in flags and empty data</li>
</ul>
<h3><a class="anchor" id="autotoc_md1003"></a>
Incremental set APIs</h3>
<p><b>set_start function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set_start(set_handle_t *handle, const char *key, size_t final_data_size, uint32_t create_flags);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>Check if final size fits in free space; if not, call <code>garbage_collection</code>.</li>
<li>Call <code>find_record</code> to find record in storage and achieve <code>ram_table_ind</code> and <code>hash</code>.</li>
<li>If found and <code>flags</code> field in header includes write once flag, return "write once" error.</li>
<li>Set <code>new_key</code> field in handle to true if not found and delete key not set.</li>
<li>Allocate an <code>inc_set_handle_t</code> structure into <code>handle</code>.</li>
<li>Calculate hash on <code>key</code> and update in <code>handle</code>.</li>
<li>Update <code>bd_base_offset</code> in handle to <code>_free_space_offset</code>.</li>
<li>Update a <code>record_header_t</code> structure with all relevant values.</li>
<li>Update all header fields in <code>handle</code>.</li>
<li>Calculate CRC on header.</li>
<li>Update <code>ram_table_ind</code> and <code>hash</code> in <code>handle</code>.</li>
<li>Program key in position after header.</li>
<li>Advance <code>_free_space_offset</code> and update in <code>bd_curr_offset</code> field in handle.</li>
<li>Set <code>_free_space_offset</code>, and update in <code>bd_curr_offset</code> field in handle.</li>
<li>Call <code>find_record</code> to calculate hash, and find record in storage (with null key and current hash).</li>
</ul>
<p><b>set_add_data function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set_add_data(set_handle_t handle, const void *value_data, size_t data_size);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Calculate CRC on <code>value_data</code> and update in handle.</li>
<li>Program <code>value_data</code> from <code>bd_curr_offset</code>.</li>
<li>Advance <code>bd_curr_offset</code>.</li>
</ul>
<p><b>set_finalize function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int set_finalize(set_handle_t handle);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Advance <code>_free_space_offset</code> to padded offset.</li>
<li>Update a <code>record_header_t</code> structure with all relevant values.</li>
<li>Program header at <code>bd_base_offset</code> from handle with pads.</li>
<li>Call <code>sync</code> on buffered block device.</li>
<li>If delete flag set:<ul>
<li>Remove entry in index <code>ram_table_ind</code> from RAM table.</li>
</ul>
</li>
<li>Else if <code>new_key</code> field is true:<ul>
<li>If <code>_num_keys</code> = <code>_max_keys</code>:<ul>
<li>Increase _max_keys by 1.</li>
<li>Duplicate ram table to with new <code>_max_keys</code> entries.</li>
</ul>
</li>
<li>Add entry <code>ram_table_ind</code>.</li>
</ul>
</li>
<li>Update <code>bd_offset</code> and <code>hash</code> in <code>ram_table_ind</code> position of RAM table.</li>
<li>Free <code>handle</code>.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1004"></a>
Key iterator APIs</h3>
<p><b>iterator_open function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int iterator_open(iterator_t *it, const char *prefix = NULL);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>Allocate a <code>key_iterator_handle_t</code> structure into <code>it</code>.</li>
<li>Set <code>ram_table_ind</code> field in iterator to 0.</li>
<li>Duplicate <code>prefix</code> into same field in iterator.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>iterator_next function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int iterator_next(iterator_t it, char *key, size_t key_size);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Take <code>_mutex</code>.</li>
<li>While <code>ram_table_ind</code> field in iterator smaller than <code>_num_keys</code>:<ul>
<li>Read key RAM table points to in <code>ram_table_ind</code> into a local variable.</li>
<li>If name matches prefix:<ul>
<li>Advance <code>ram_table_ind</code> field in iterator.</li>
<li>Copy name to <code>key</code>, and return OK.</li>
</ul>
</li>
<li>Advance <code>ram_table_ind</code> field in iterator.</li>
</ul>
</li>
<li>Return "not found" error.</li>
<li>Release <code>_mutex</code>.</li>
</ul>
<p><b>iterator_close function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int iterator_close(iterator_t it);</code></p>
<p>Pseudo code:</p>
<ul>
<li>Release <code>prefix</code> field in iterator and structure allocated at <code>it</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1005"></a>
Reserved space</h3>
<p><b>reserved_space_set function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int reserved_space_set(void *data);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Check if reserved space is not empty; if it is, return a "reserved space programmed error".</li>
<li>Copy <code>data</code> contents to reserved space location.</li>
</ul>
<p><b>reserved_space_get function</b></p>
<p>Header: <br  />
</p>
<p><code>virtual int reserved_space_get(void *data);</code></p>
<p>Pseudo code: <br  />
</p>
<ul>
<li>Copy contents from reserved space location <code>data</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md1006"></a>
Usage scenarios and examples</h1>
<h3><a class="anchor" id="autotoc_md1007"></a>
Standard use of the class</h3>
<p>The following example code shows standard use of the TDBStore class:</p>
<p><b>Standard usage example</b></p>
<div class="fragment"><div class="line"><span class="comment">// Underlying block device. Here, SPI Flash is fully used.</span></div>
<div class="line"><span class="comment">// One can use SlicingBlockDevice if we want a partition.</span></div>
<div class="line"><a class="code hl_class" href="classSPIFBlockDevice.html">SPIFBlockDevice</a> bd(PTE2, PTE4, PTE1, PTE5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Instantiate tdbstore with our block device</span></div>
<div class="line">TDBStore tdbstore(&amp;bd);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> res;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize tdbstore</span></div>
<div class="line">res = tdbstore.init();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add &quot;Key1&quot;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val1 = <span class="stringliteral">&quot;Value of key 1&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *val2 = <span class="stringliteral">&quot;Updated value of key 1&quot;</span>;</div>
<div class="line">res = tdbstore.set(<span class="stringliteral">&quot;Key1&quot;</span>, val1, <span class="keyword">sizeof</span>(val1), 0);</div>
<div class="line"><span class="comment">// Update value of &quot;Key1&quot;</span></div>
<div class="line">res = tdbstore.set(<span class="stringliteral">&quot;Key1&quot;</span>, val2, <span class="keyword">sizeof</span>(val2), 0);</div>
<div class="line"> </div>
<div class="line">uint_8 value[32];</div>
<div class="line"><span class="keywordtype">size_t</span> actual_size;</div>
<div class="line"><span class="comment">// Get value of &quot;Key1&quot;. Value should return the updated value.</span></div>
<div class="line">res = tdbstore.get(<span class="stringliteral">&quot;Key1&quot;</span>, value, <span class="keyword">sizeof</span>(value), &amp;actual_size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove &quot;Key1&quot;</span></div>
<div class="line">res = tdbstore.remove(<span class="stringliteral">&quot;Key1&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Incremental write, if need to generate large data with a small buffer</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> data_size = 1024;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>[8];</div>
<div class="line"> </div>
<div class="line">KVSTore::set_handle_t handle;</div>
<div class="line">res = tdbstore.set_start(&amp;handle, <span class="stringliteral">&quot;Key2&quot;</span>, data_size, 0);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; data_size / <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>); i++) {</div>
<div class="line">    memset(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, i, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">    res = tdbstore.set_add_data(handle, <a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>));</div>
<div class="line">}</div>
<div class="line">res = tdbstore.set_finalize(handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate over all keys starting with &quot;Key&quot;</span></div>
<div class="line">res = 0;</div>
<div class="line">KVSTore::iterator_t it;</div>
<div class="line">tdbstore.iterator_open(&amp;it, <span class="stringliteral">&quot;Key*&quot;</span>);</div>
<div class="line"><span class="keywordtype">char</span> key[KVSTore::KV_MAX_KEY_LENGTH];</div>
<div class="line"><span class="keywordflow">while</span> (!res) {</div>
<div class="line">    res = tdbstore.iterator_next(&amp;it, key, <span class="keyword">sizeof</span>(key));</div>
<div class="line">}</div>
<div class="line">res = tdbstore.iterator_close(&amp;it);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deinitialize TDBStore</span></div>
<div class="line">res = tdbstore.deinit();</div>
<div class="ttc" id="aclassSPIFBlockDevice_html"><div class="ttname"><a href="classSPIFBlockDevice.html">SPIFBlockDevice</a></div><div class="ttdef"><b>Definition</b> SPIFBlockDevice.h:91</div></div>
<div class="ttc" id="awsf__trace_8c_html_a631cb00ea94506727e7ab9cdd27cf9cd"><div class="ttname"><a href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a></div><div class="ttdeci">uint8_t buf[8]</div><div class="ttdef"><b>Definition</b> wsf_trace.c:81</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1008"></a>
Other information</h1>
<h3><a class="anchor" id="autotoc_md1009"></a>
Open issues</h3>
<ul>
<li>Need to figure a way to prevent mutex abuse in incremental set APIs. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
