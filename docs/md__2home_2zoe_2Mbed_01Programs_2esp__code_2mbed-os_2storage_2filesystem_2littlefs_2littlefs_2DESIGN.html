<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: The design of the little filesystem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2zoe_2Mbed_01Programs_2esp__code_2mbed-os_2storage_2filesystem_2littlefs_2littlefs_2DESIGN.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The design of the little filesystem</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1010"></a></p>
<p>A little fail-safe filesystem designed for embedded systems.</p>
<div class="fragment"><div class="line">   | | |     .---._____</div>
<div class="line">  .-----.   |          |</div>
<div class="line">--|o    |---| littlefs |</div>
<div class="line">--|     |---|          |</div>
<div class="line">  &#39;-----&#39;   &#39;----------&#39;</div>
<div class="line">   | | |</div>
</div><!-- fragment --><p>For a bit of backstory, the littlefs was developed with the goal of learning more about filesystem design by tackling the relative unsolved problem of managing a robust filesystem resilient to power loss on devices with limited RAM and ROM.</p>
<p>The embedded systems the littlefs is targeting are usually 32 bit microcontrollers with around 32KB of RAM and 512KB of ROM. These are often paired with SPI NOR flash chips with about 4MB of flash storage.</p>
<p>Flash itself is a very interesting piece of technology with quite a bit of nuance. Unlike most other forms of storage, writing to flash requires two operations: erasing and programming. The programming operation is relatively cheap and can be very granular. For NOR flash specifically, byte-level programs are quite common. Erasing, however, requires an expensive operation that forces the state of large blocks of memory to reset in a destructive reaction that gives flash its name. The <a href="https://en.wikipedia.org/wiki/Flash_memory">Wikipedia entry</a> has more information if you are interested in how this works.</p>
<p>This leaves us with an interesting set of limitations that can be simplified to three strong requirements:</p>
<ol type="1">
<li><p class="startli"><b>Power-loss resilient</b> - This is the main goal of the littlefs and the focus of this project.</p>
<p class="startli">Embedded systems are usually designed without a shutdown routine and a notable lack of user interface for recovery, so filesystems targeting embedded systems must be prepared to lose power at any given time.</p>
<p class="startli">Despite this state of things, there are very few embedded filesystems that handle power loss in a reasonable manner, and most can become corrupted if the user is unlucky enough.</p>
</li>
<li><p class="startli"><b>Wear leveling</b> - Due to the destructive nature of flash, most flash chips have a limited number of erase cycles, usually in the order of around 100,000 erases per block for NOR flash. Filesystems that don't take wear into account can easily burn through blocks used to store frequently updated metadata.</p>
<p class="startli">Consider the <a href="https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system">FAT filesystem</a>, which stores a file allocation table (FAT) at a specific offset from the beginning of disk. Every block allocation will update this table, and after 100,000 updates, the block will likely go bad, rendering the filesystem unusable even if there are many more erase cycles available on the storage as a whole.</p>
</li>
<li><p class="startli"><b>Bounded RAM/ROM</b> - Even with the design difficulties presented by the previous two limitations, we have already seen several flash filesystems developed on PCs that handle power loss just fine, such as the logging filesystems. However, these filesystems take advantage of the relatively cheap access to RAM, and use some rather... opportunistic... techniques, such as reconstructing the entire directory structure in RAM. These operations make perfect sense when the filesystem's only concern is erase cycles, but the idea is a bit silly on embedded systems.</p>
<p class="startli">To cater to embedded systems, the littlefs has the simple limitation of using only a bounded amount of RAM and ROM. That is, no matter what is written to the filesystem, and no matter how large the underlying storage is, the littlefs will always use the same amount of RAM and ROM. This presents a very unique challenge and makes presumably simple operations, such as iterating through the directory tree, surprisingly difficult.</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md1011"></a>
Existing designs?</h1>
<p>There are of course, many different existing filesystem. Here is a very rough summary of the general ideas behind some of them.</p>
<p>Most of the existing filesystems fall into the one big category of filesystem designed in the early days of spinny magnet disks. While there is a vast amount of interesting technology and ideas in this area, the nature of spinny magnet disks encourage properties, such as grouping writes near each other, that don't make as much sense on recent storage types. For instance, on flash, write locality is not important and can actually increase wear.</p>
<p>One of the most popular designs for flash filesystems is called the <a href="https://en.wikipedia.org/wiki/Log-structured_file_system">logging filesystem</a>. The flash filesystems <a href="https://en.wikipedia.org/wiki/JFFS">jffs</a> and <a href="https://en.wikipedia.org/wiki/YAFFS">yaffs</a> are good examples. In logging filesystem, data is not stored in a data structure on disk, but instead the changes to the files are stored on disk. This has several neat advantages, such as the fact that the data is written in a cyclic log format naturally levels wear as a side effect. And, with a bit of error detection, the entire filesystem can easily be designed to be resilient to power loss. The journaling component of most modern day filesystems is actually a reduced form of a logging filesystem. However, logging filesystems have a difficulty scaling as the size of storage increases. And most filesystems compensate by caching large parts of the filesystem in RAM, a strategy that is inappropriate for embedded systems.</p>
<p>Another interesting filesystem design technique is that of <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write (COW)</a>. A good example of this is the <a href="https://en.wikipedia.org/wiki/Btrfs">btrfs</a> filesystem. COW filesystems can easily recover from corrupted blocks and have natural protection against power loss. However, if they are not designed with wear in mind, a COW filesystem could unintentionally wear down the root block where the COW data structures are synchronized.</p>
<h1><a class="anchor" id="autotoc_md1012"></a>
Metadata pairs</h1>
<p>The core piece of technology that provides the backbone for the littlefs is the concept of metadata pairs. The key idea here is that any metadata that needs to be updated atomically is stored on a pair of blocks tagged with a revision count and checksum. Every update alternates between these two pairs, so that at any time there is always a backup containing the previous state of the metadata.</p>
<p>Consider a small example where each metadata pair has a revision count, a number as data, and the XOR of the block as a quick checksum. If we update the data to a value of 9, and then to a value of 5, here is what the pair of blocks may look like after each update: </p><div class="fragment"><div class="line">  block 1   block 2        block 1   block 2        block 1   block 2</div>
<div class="line">.---------.---------.    .---------.---------.    .---------.---------.</div>
<div class="line">| rev: 1  | rev: 0  |    | rev: 1  | rev: 2  |    | rev: 3  | rev: 2  |</div>
<div class="line">| data: 3 | data: 0 | -&gt; | data: 3 | data: 9 | -&gt; | data: 5 | data: 9 |</div>
<div class="line">| xor: 2  | xor: 0  |    | xor: 2  | xor: 11 |    | xor: 6  | xor: 11 |</div>
<div class="line">&#39;---------&#39;---------&#39;    &#39;---------&#39;---------&#39;    &#39;---------&#39;---------&#39;</div>
<div class="line">                 let data = 9             let data = 5</div>
</div><!-- fragment --><p>After each update, we can find the most up to date value of data by looking at the revision count.</p>
<p>Now consider what the blocks may look like if we suddenly lose power while changing the value of data to 5: </p><div class="fragment"><div class="line">  block 1   block 2        block 1   block 2        block 1   block 2</div>
<div class="line">.---------.---------.    .---------.---------.    .---------.---------.</div>
<div class="line">| rev: 1  | rev: 0  |    | rev: 1  | rev: 2  |    | rev: 3  | rev: 2  |</div>
<div class="line">| data: 3 | data: 0 | -&gt; | data: 3 | data: 9 | -x | data: 3 | data: 9 |</div>
<div class="line">| xor: 2  | xor: 0  |    | xor: 2  | xor: 11 |    | xor: 2  | xor: 11 |</div>
<div class="line">&#39;---------&#39;---------&#39;    &#39;---------&#39;---------&#39;    &#39;---------&#39;---------&#39;</div>
<div class="line">                 let data = 9             let data = 5</div>
<div class="line">                                          powerloss!!!</div>
</div><!-- fragment --><p>In this case, block 1 was partially written with a new revision count, but the littlefs hadn't made it to updating the value of data. However, if we check our checksum, we notice that block 1 was corrupted. So we fall back to block 2 and use the value 9.</p>
<p>Using this concept, the littlefs is able to update metadata blocks atomically. There are a few other tweaks, such as using a 32 bit CRC and using sequence arithmetic to handle revision count overflow, but the basic concept is the same. These metadata pairs define the backbone of the littlefs, and the rest of the filesystem is built on top of these atomic updates.</p>
<h1><a class="anchor" id="autotoc_md1013"></a>
Nonmeta data</h1>
<p>Now, the metadata pairs do come with some drawbacks. Most notably, each pair requires two blocks for each block of data. I'm sure users would be very unhappy if their storage were suddenly cut in half! Instead of storing everything in these metadata blocks, the littlefs uses a COW data structure for files, which is, in turn, pointed to by a metadata block. When we update a file, we create copies of any blocks that are modified until the metadata blocks are updated with the new copy. Once the metadata block points to the new copy, we deallocate the old blocks that are no longer in use.</p>
<p>Here is what updating a one-block file may look like: </p><div class="fragment"><div class="line">  block 1   block 2        block 1   block 2        block 1   block 2</div>
<div class="line">.---------.---------.    .---------.---------.    .---------.---------.</div>
<div class="line">| rev: 1  | rev: 0  |    | rev: 1  | rev: 0  |    | rev: 1  | rev: 2  |</div>
<div class="line">| file: 4 | file: 0 | -&gt; | file: 4 | file: 0 | -&gt; | file: 4 | file: 5 |</div>
<div class="line">| xor: 5  | xor: 0  |    | xor: 5  | xor: 0  |    | xor: 5  | xor: 7  |</div>
<div class="line">&#39;---------&#39;---------&#39;    &#39;---------&#39;---------&#39;    &#39;---------&#39;---------&#39;</div>
<div class="line">    |                        |                                  |</div>
<div class="line">    v                        v                                  v</div>
<div class="line"> block 4                  block 4    block 5       block 4    block 5</div>
<div class="line">.--------.               .--------. .--------.    .--------. .--------.</div>
<div class="line">| old    |               | old    | | new    |    | old    | | new    |</div>
<div class="line">| data   |               | data   | | data   |    | data   | | data   |</div>
<div class="line">|        |               |        | |        |    |        | |        |</div>
<div class="line">&#39;--------&#39;               &#39;--------&#39; &#39;--------&#39;    &#39;--------&#39; &#39;--------&#39;</div>
<div class="line">            update data in file        update metadata pair</div>
</div><!-- fragment --><p>It doesn't matter if we lose power while writing new data to block 5, because the old data remains unmodified in block 4. This example also highlights how the atomic updates of the metadata blocks provide a synchronization barrier for the rest of the littlefs.</p>
<p>At this point, it may look like we are wasting an awfully large amount of space on the metadata. Just looking at that example, we are using three blocks to represent a file that fits comfortably in one! So instead of giving each file a metadata pair, we actually store the metadata for all files contained in a single directory in a single metadata block.</p>
<p>Now we could just leave files here, copying the entire file on write provides the synchronization without the duplicated memory requirements of the metadata blocks. However, we can do a bit better.</p>
<h1><a class="anchor" id="autotoc_md1014"></a>
CTZ skip-lists</h1>
<p>There are many different data structures for representing the actual files in filesystems. Of these, the littlefs uses a rather unique <a href="https://upload.wikimedia.org/wikipedia/commons/0/0c/Cow_female_black_white.jpg">COW</a> data structure that allows the filesystem to reuse unmodified parts of the file without additional metadata pairs.</p>
<p>First lets consider storing files in a simple linked-list. What happens when we append a block? We have to change the last block in the linked-list to point to this new block, which means we have to copy out the last block, and change the second-to-last block, and then the third-to-last, and so on until we've copied out the entire file.</p>
<div class="fragment"><div class="line">Exhibit A: A linked-list</div>
<div class="line">.--------.  .--------.  .--------.  .--------.  .--------.  .--------.</div>
<div class="line">| data 0 |-&gt;| data 1 |-&gt;| data 2 |-&gt;| data 4 |-&gt;| data 5 |-&gt;| data 6 |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |  |        |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |  |        |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><p>To get around this, the littlefs, at its heart, stores files backward. Each block points to its predecessor, with the first block containing no pointers. If you think about it for a while, it starts to make a bit of sense. Appending blocks just point to their predecessor, and no other blocks need to be updated. If we update a block in the middle, we will need to copy out the blocks that follow but can reuse the blocks before the modified block. Because most file operations either reset the file each write or append to files, this design avoids copying the file in the most common cases.</p>
<div class="fragment"><div class="line">Exhibit B: A backwards linked-list</div>
<div class="line">.--------.  .--------.  .--------.  .--------.  .--------.  .--------.</div>
<div class="line">| data 0 |&lt;-| data 1 |&lt;-| data 2 |&lt;-| data 4 |&lt;-| data 5 |&lt;-| data 6 |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |  |        |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |  |        |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><p>However, a backwards linked-list does come with a rather glaring problem. Iterating over a file <em>in order</em> has a runtime cost of O(n^2). Gah! A quadratic runtime to just <em>read</em> a file? That's awful. Keep in mind reading files is usually the most common filesystem operation.</p>
<p>To avoid this problem, the littlefs uses a multilayered linked-list. For every nth block where n is divisible by 2^x, the block contains a pointer to block n-2^x. So each block contains anywhere from 1 to log2(n) pointers that skip to various sections of the preceding list. If you're familiar with data-structures, you may have recognized that this is a type of deterministic skip-list.</p>
<p>The name comes from the use of the <a href="https://en.wikipedia.org/wiki/Count_trailing_zeros">count trailing zeros (CTZ)</a> instruction, which allows us to calculate the power-of-two factors efficiently. For a given block n, the block contains ctz(n)+1 pointers.</p>
<div class="fragment"><div class="line">Exhibit C: A backward CTZ skip-list</div>
<div class="line">.--------.  .--------.  .--------.  .--------.  .--------.  .--------.</div>
<div class="line">| data 0 |&lt;-| data 1 |&lt;-| data 2 |&lt;-| data 3 |&lt;-| data 4 |&lt;-| data 5 |</div>
<div class="line">|        |&lt;-|        |--|        |&lt;-|        |--|        |  |        |</div>
<div class="line">|        |&lt;-|        |--|        |--|        |--|        |  |        |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><p>The additional pointers allow us to navigate the data-structure on disk much more efficiently than in a singly linked-list.</p>
<p>Taking exhibit C, for example, here is the path from data block 5 to data block 1. You can see how data block 3 was completely skipped: </p><div class="fragment"><div class="line">.--------.  .--------.  .--------.  .--------.  .--------.  .--------.</div>
<div class="line">| data 0 |  | data 1 |&lt;-| data 2 |  | data 3 |  | data 4 |&lt;-| data 5 |</div>
<div class="line">|        |  |        |  |        |&lt;-|        |--|        |  |        |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |  |        |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><p>The path to data block 0 is even quicker, requiring only two jumps: </p><div class="fragment"><div class="line">.--------.  .--------.  .--------.  .--------.  .--------.  .--------.</div>
<div class="line">| data 0 |  | data 1 |  | data 2 |  | data 3 |  | data 4 |&lt;-| data 5 |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |  |        |</div>
<div class="line">|        |&lt;-|        |--|        |--|        |--|        |  |        |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><p>We can find the runtime complexity by looking at the path to any block from the block containing the most pointers. Every step along the path divides the search space for the block in half. This gives us a runtime of O(log n). To get to the block with the most pointers, we can perform the same steps backwards, which puts the runtime at O(2 log n) = O(log n). The interesting part about this data structure is that this optimal path occurs naturally if we greedily choose the pointer that covers the most distance without passing our target block.</p>
<p>So now we have a representation of files that can be appended trivially with a runtime of O(1), and can be read with a worst case runtime of O(n log n). Given that the the runtime is also divided by the amount of data we can store in a block, this is pretty reasonable.</p>
<p>Unfortunately, the CTZ skip-list comes with a few questions that aren't straightforward to answer. What is the overhead? How do we handle more pointers than we can store in a block? How do we store the skip-list in a directory entry?</p>
<p>One way to find the overhead per block is to look at the data structure as multiple layers of linked-lists. Each linked-list skips twice as many blocks as the previous linked-list. Another way of looking at it is that each linked-list uses half as much storage per block as the previous linked-list. As we approach infinity, the number of pointers per block forms a geometric series. Solving this geometric series gives us an average of only 2 pointers per block.</p>
<p><img src="https://latex.codecogs.com/svg.latex?%5Clim_%7Bn%5Cto%5Cinfty%7D%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi%3D0%7D%5E%7Bn%7D%5Cleft%28%5Ctext%7Bctz%7D%28i%29&plus;1%5Cright%29%20%3D%20%5Csum_%7Bi%3D0%7D%5Cfrac%7B1%7D%7B2%5Ei%7D%20%3D%202" alt="overhead_per_block" class="inline"/></p>
<p>Finding the maximum number of pointers in a block is a bit more complicated, but because our file size is limited by the integer width we use to store the size, we can solve for it. Setting the overhead of the maximum pointers equal to the block size, we get the following equation. Note that a smaller block size results in more pointers, and a larger word width results in larger pointers.</p>
<p><img src="https://latex.codecogs.com/svg.latex?B%20%3D%20%5Cfrac%7Bw%7D%7B8%7D%5Cleft%5Clceil%5Clog_2%5Cleft%28%5Cfrac%7B2%5Ew%7D%7BB-2%5Cfrac%7Bw%7D%7B8%7D%7D%5Cright%29%5Cright%5Crceil" alt="maximum overhead" class="inline"/></p>
<p>where: <br  />
 B = block size in bytes <br  />
 w = word width in bits <br  />
</p>
<p>Solving the equation for B gives us the minimum block size for various word widths: <br  />
 32 bit CTZ skip-list = minimum block size of 104 bytes <br  />
 64 bit CTZ skip-list = minimum block size of 448 bytes <br  />
</p>
<p>Because littlefs uses a 32 bit word size, we are limited to a minimum block size of 104 bytes. This is a perfectly reasonable minimum block size, with most block sizes starting around 512 bytes. So we can avoid additional logic to avoid overflowing our block's capacity in the CTZ skip-list.</p>
<p>So, how do we store the skip-list in a directory entry? A naive approach would be to store a pointer to the head of the skip-list, the length of the file in bytes, the index of the head block in the skip-list and the offset in the head block in bytes. However, this is a lot of information, and we can observe that a file size maps to only one block index + offset pair. So it should be sufficient to store only the pointer and file size.</p>
<p>But there is one problem: Calculating the block index plus offset pair from a file size doesn't have an obvious implementation.</p>
<p>We can start by just writing down an equation. The first idea that comes to mind is to just use a for loop to sum together blocks until we reach our file size. We can write this equation as a summation:</p>
<p><img src="https://latex.codecogs.com/svg.latex?N%20%3D%20%5Csum_i%5En%5Cleft%5BB-%5Cfrac%7Bw%7D%7B8%7D%5Cleft%28%5Ctext%7Bctz%7D%28i%29&plus;1%5Cright%29%5Cright%5D" alt="summation1" class="inline"/></p>
<p>where: <br  />
 B = block size in bytes <br  />
 w = word width in bits <br  />
 n = block index in skip-list <br  />
 N = file size in bytes <br  />
</p>
<p>And this works quite well but is not trivial to calculate. This equation requires O(n) to compute, which brings the entire runtime of reading a file to O(n^2 log n). Fortunately, the additional O(n) does not need to touch disk, so it is not completely unreasonable. But if we could solve this equation into a form that is easily computable, we can avoid a big slowdown.</p>
<p>Unfortunately, the summation of the CTZ instruction presents a big challenge. How would you even begin to reason about integrating a bitwise instruction? Fortunately, there is a powerful tool I've found useful in these situations: The <a href="https://oeis.org/">On-Line Encyclopedia of Integer Sequences (OEIS)</a>. If we work out the first couple of values in our summation, we find that CTZ maps to <a href="https://oeis.org/A001511">A001511</a>, and its partial summation maps to <a href="https://oeis.org/A005187">A005187</a>, and, surprisingly, both of these sequences have relatively trivial equations! This leads us to a rather unintuitive property:</p>
<p><img src="https://latex.codecogs.com/svg.latex?%5Csum_i%5En%5Cleft%28%5Ctext%7Bctz%7D%28i%29&plus;1%5Cright%29%20%3D%202n-%5Ctext%7Bpopcount%7D%28n%29" alt="mindblown" class="inline"/></p>
<p>where: <br  />
 ctz(x) = the number of trailing bits that are 0 in x <br  />
 popcount(x) = the number of bits that are 1 in x <br  />
</p>
<p>It's a bit bewildering that these two seemingly unrelated bitwise instructions are related by this property. But if we start to dissect this equation, we can see that it does hold. As n approaches infinity, we do end up with an average overhead of 2 pointers as we found earlier. And popcount seems to handle the error from this average as it accumulates in the CTZ skip-list.</p>
<p>Now we can substitute into the original equation to get a trivial equation for a file size:</p>
<p><img src="https://latex.codecogs.com/svg.latex?N%20%3D%20Bn%20-%20%5Cfrac%7Bw%7D%7B8%7D%5Cleft%282n-%5Ctext%7Bpopcount%7D%28n%29%5Cright%29" alt="summation2" class="inline"/></p>
<p>Unfortunately, we're not quite done. The popcount function is noninjective, so we can only find the file size from the block index, not the other way around. However, we can solve for an n' block index that is greater than n with an error bounded by the range of the popcount function. We can then repeatedly substitute this n' into the original equation until the error is smaller than the integer division. As it turns out, we only need to perform this substitution once. Now we directly calculate our block index:</p>
<p><img src="https://latex.codecogs.com/svg.latex?n%20%3D%20%5Cleft%5Clfloor%5Cfrac%7BN-%5Cfrac%7Bw%7D%7B8%7D%5Cleft%28%5Ctext%7Bpopcount%7D%5Cleft%28%5Cfrac%7BN%7D%7BB-2%5Cfrac%7Bw%7D%7B8%7D%7D-1%5Cright%29&plus;2%5Cright%29%7D%7BB-2%5Cfrac%7Bw%7D%7B8%7D%7D%5Cright%5Crfloor" alt="formulaforn" class="inline"/></p>
<p>Now that we have our block index n, we can just plug it back into the above equation to find the offset. However, we do need to rearrange the equation a bit to avoid integer overflow:</p>
<p><img src="https://latex.codecogs.com/svg.latex?%5Cmathit%7Boff%7D%20%3D%20N%20-%20%5Cleft%28B-2%5Cfrac%7Bw%7D%7B8%7D%5Cright%29n%20-%20%5Cfrac%7Bw%7D%7B8%7D%5Ctext%7Bpopcount%7D%28n%29" alt="formulaforoff" class="inline"/></p>
<p>The solution involves quite a bit of math, but computers are very good at math. Now we can solve for both the block index and offset from the file size in O(1).</p>
<p>Here is what it might look like to update a file stored with a CTZ skip-list: </p><div class="fragment"><div class="line">                                      block 1   block 2</div>
<div class="line">                                    .---------.---------.</div>
<div class="line">                                    | rev: 1  | rev: 0  |</div>
<div class="line">                                    | file: 6 | file: 0 |</div>
<div class="line">                                    | size: 4 | size: 0 |</div>
<div class="line">                                    | xor: 3  | xor: 0  |</div>
<div class="line">                                    &#39;---------&#39;---------&#39;</div>
<div class="line">                                        |</div>
<div class="line">                                        v</div>
<div class="line">  block 3     block 4     block 5     block 6</div>
<div class="line">.--------.  .--------.  .--------.  .--------.</div>
<div class="line">| data 0 |&lt;-| data 1 |&lt;-| data 2 |&lt;-| data 3 |</div>
<div class="line">|        |&lt;-|        |--|        |  |        |</div>
<div class="line">|        |  |        |  |        |  |        |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  update data in file</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">                                      block 1   block 2</div>
<div class="line">                                    .---------.---------.</div>
<div class="line">                                    | rev: 1  | rev: 0  |</div>
<div class="line">                                    | file: 6 | file: 0 |</div>
<div class="line">                                    | size: 4 | size: 0 |</div>
<div class="line">                                    | xor: 3  | xor: 0  |</div>
<div class="line">                                    &#39;---------&#39;---------&#39;</div>
<div class="line">                                        |</div>
<div class="line">                                        v</div>
<div class="line">  block 3     block 4     block 5     block 6</div>
<div class="line">.--------.  .--------.  .--------.  .--------.</div>
<div class="line">| data 0 |&lt;-| data 1 |&lt;-| old    |&lt;-| old    |</div>
<div class="line">|        |&lt;-|        |--| data 2 |  | data 3 |</div>
<div class="line">|        |  |        |  |        |  |        |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
<div class="line">     ^ ^           ^</div>
<div class="line">     | |           |      block 7     block 8     block 9    block 10</div>
<div class="line">     | |           |    .--------.  .--------.  .--------.  .--------.</div>
<div class="line">     | |           &#39;----| new    |&lt;-| new    |&lt;-| new    |&lt;-| new    |</div>
<div class="line">     | &#39;----------------| data 2 |&lt;-| data 3 |--| data 4 |  | data 5 |</div>
<div class="line">     &#39;------------------|        |--|        |--|        |  |        |</div>
<div class="line">                        &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  update metadata pair</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">                                                   block 1   block 2</div>
<div class="line">                                                 .---------.---------.</div>
<div class="line">                                                 | rev: 1  | rev: 2  |</div>
<div class="line">                                                 | file: 6 | file: 10|</div>
<div class="line">                                                 | size: 4 | size: 6 |</div>
<div class="line">                                                 | xor: 3  | xor: 14 |</div>
<div class="line">                                                 &#39;---------&#39;---------&#39;</div>
<div class="line">                                                                |</div>
<div class="line">                                                                |</div>
<div class="line">  block 3     block 4     block 5     block 6                   |</div>
<div class="line">.--------.  .--------.  .--------.  .--------.                  |</div>
<div class="line">| data 0 |&lt;-| data 1 |&lt;-| old    |&lt;-| old    |                  |</div>
<div class="line">|        |&lt;-|        |--| data 2 |  | data 3 |                  |</div>
<div class="line">|        |  |        |  |        |  |        |                  |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;                  |</div>
<div class="line">     ^ ^           ^                                            v</div>
<div class="line">     | |           |      block 7     block 8     block 9    block 10</div>
<div class="line">     | |           |    .--------.  .--------.  .--------.  .--------.</div>
<div class="line">     | |           &#39;----| new    |&lt;-| new    |&lt;-| new    |&lt;-| new    |</div>
<div class="line">     | &#39;----------------| data 2 |&lt;-| data 3 |--| data 4 |  | data 5 |</div>
<div class="line">     &#39;------------------|        |--|        |--|        |  |        |</div>
<div class="line">                        &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1015"></a>
Block allocation</h1>
<p>So those two ideas provide the grounds for the filesystem. The metadata pairs give us directories, and the CTZ skip-lists give us files. But this leaves one big <a href="https://upload.wikimedia.org/wikipedia/commons/3/37/African_Bush_Elephant.jpg">elephant</a> of a question. How do we get those blocks in the first place?</p>
<p>One common strategy is to store unallocated blocks in a big free list, and initially the littlefs was designed with this in mind. By storing a reference to the free list in every single metadata pair, additions to the free list could be updated atomically at the same time the replacement blocks were stored in the metadata pair. During boot, every metadata pair had to be scanned to find the most recent free list, but once the list is found, the state of all free blocks becomes known.</p>
<p>However, this approach had several issues:</p>
<ul>
<li>There was a lot of nuanced logic for adding blocks to the free list without modifying the blocks because the blocks remain active until the metadata is updated.</li>
<li>The free list had to support both additions and removals in FIFO order while minimizing block erases.</li>
<li>The free list had to handle the case where the file system completely ran out of blocks and may no longer be able to add blocks to the free list.</li>
<li>If we used a revision count to track the most recently updated free list, metadata blocks that were left unmodified were ticking time bombs that would cause the system to go haywire if the revision count overflowed.</li>
<li>Every single metadata block wasted space to store these free list references.</li>
</ul>
<p>Actually, to simplify, this approach had one massive glaring issue: complexity.</p>
<blockquote class="doxtable">
<p>Complexity leads to fallibility. <br  />
 Fallibility leads to unmaintainability. <br  />
 Unmaintainability leads to suffering. <br  />
 </p>
</blockquote>
<p>Or at least, complexity leads to increased code size, which is a problem for embedded systems.</p>
<p>In the end, the littlefs adopted more of a "drop it on the floor" strategy. That is, the littlefs doesn't actually store information about which blocks are free on the storage. The littlefs already stores which files <em>are</em> in use, so to find a free block, the littlefs just takes all of the blocks that exist and subtracts the blocks that are in use.</p>
<p>Of course, it's not quite that simple. Most filesystems that adopt this "drop
it on the floor" strategy either rely on some properties inherent to the filesystem, such as the cyclic-buffer structure of logging filesystems, or use a bitmap or table stored in RAM to track free blocks, which scales with the size of storage and is problematic when you have limited RAM. You could iterate through every single block in storage and check it against every single block in the filesystem on every single allocation, but that would have an abhorrent runtime.</p>
<p>So the littlefs compromises. It doesn't store a bitmap the size of the storage, but it does store a little bit-vector that contains a fixed set lookahead for block allocations. During a block allocation, the lookahead vector is checked for any free blocks. If there are none, the lookahead region jumps forward, and the entire filesystem is scanned for free blocks.</p>
<p>Here's what it might look like to allocate 4 blocks on a decently busy filesystem with a 32bit lookahead and a total of 128 blocks (512Kbytes of storage if blocks are 4Kbyte): </p><div class="fragment"><div class="line">boot...         lookahead:</div>
<div class="line">                fs blocks: fffff9fffffffffeffffffffffff0000</div>
<div class="line">scanning...     lookahead: fffff9ff</div>
<div class="line">                fs blocks: fffff9fffffffffeffffffffffff0000</div>
<div class="line">alloc = 21      lookahead: fffffdff</div>
<div class="line">                fs blocks: fffffdfffffffffeffffffffffff0000</div>
<div class="line">alloc = 22      lookahead: ffffffff</div>
<div class="line">                fs blocks: fffffffffffffffeffffffffffff0000</div>
<div class="line">scanning...     lookahead:         fffffffe</div>
<div class="line">                fs blocks: fffffffffffffffeffffffffffff0000</div>
<div class="line">alloc = 63      lookahead:         ffffffff</div>
<div class="line">                fs blocks: ffffffffffffffffffffffffffff0000</div>
<div class="line">scanning...     lookahead:         ffffffff</div>
<div class="line">                fs blocks: ffffffffffffffffffffffffffff0000</div>
<div class="line">scanning...     lookahead:                 ffffffff</div>
<div class="line">                fs blocks: ffffffffffffffffffffffffffff0000</div>
<div class="line">scanning...     lookahead:                         ffff0000</div>
<div class="line">                fs blocks: ffffffffffffffffffffffffffff0000</div>
<div class="line">alloc = 112     lookahead:                         ffff8000</div>
<div class="line">                fs blocks: ffffffffffffffffffffffffffff8000</div>
</div><!-- fragment --><p>While this lookahead approach still has an asymptotic runtime of O(n^2) to scan all of storage, the lookahead reduces the practical runtime to a reasonable amount. Bit-vectors are surprisingly compact. Given only 16 bytes, the lookahead could track 128 blocks. For a 4Mbyte flash chip with 4Kbyte blocks, the littlefs would only need 8 passes to scan the entire storage.</p>
<p>The real benefit of this approach is just how much it simplified the design of the littlefs. Deallocating blocks is as simple as simply forgetting they exist, and there is absolutely no concern of bugs in the deallocation code causing difficult to detect memory leaks.</p>
<h1><a class="anchor" id="autotoc_md1016"></a>
Directories</h1>
<p>Now we just need directories to store our files. Because we already have metadata blocks that store information about files, let's just use these metadata blocks as the directories. Maybe turn the directories into linked lists of metadata blocks, so it isn't limited by the number of files that fit in a single block. Add entries that represent other nested directories. Drop "." and ".." entries because who needs them? Dust off our hands, and we now have a directory tree.</p>
<div class="fragment"><div class="line">            .--------.</div>
<div class="line">            |root dir|</div>
<div class="line">            | pair 0 |</div>
<div class="line">            |        |</div>
<div class="line">            &#39;--------&#39;</div>
<div class="line">            .-&#39;    &#39;-------------------------.</div>
<div class="line">           v                                  v</div>
<div class="line">      .--------.        .--------.        .--------.</div>
<div class="line">      | dir A  |-------&gt;| dir A  |        | dir B  |</div>
<div class="line">      | pair 0 |        | pair 1 |        | pair 0 |</div>
<div class="line">      |        |        |        |        |        |</div>
<div class="line">      &#39;--------&#39;        &#39;--------&#39;        &#39;--------&#39;</div>
<div class="line">      .-&#39;    &#39;-.            |             .-&#39;    &#39;-.</div>
<div class="line">     v          v           v            v          v</div>
<div class="line">.--------.  .--------.  .--------.  .--------.  .--------.</div>
<div class="line">| file C |  | file D |  | file E |  | file F |  | file G |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><p>Unfortunately, it turns out it's not that simple. See, iterating over a directory tree isn't actually all that easy, especially when you're trying to fit in a bounded amount of RAM, which rules out any recursive solution. And because our block allocator involves iterating over the entire filesystem tree, possibly multiple times in a single allocation, iteration needs to be efficient.</p>
<p>So, as a solution, the littlefs adopted a sort of threaded tree. Each directory not only contains pointers to all of its children, but also a pointer to the next directory. These pointers create a linked-list that is threaded through all of the directories in the filesystem. Because we only use this linked list to check for existence, the order doesn't actually matter. As an added plus, we can repurpose the pointer for the individual directory linked-lists and avoid using any additional space.</p>
<div class="fragment"><div class="line">            .--------.</div>
<div class="line">            |root dir|-.</div>
<div class="line">            | pair 0 | |</div>
<div class="line">   .--------|        |-&#39;</div>
<div class="line">   |        &#39;--------&#39;</div>
<div class="line">   |        .-&#39;    &#39;-------------------------.</div>
<div class="line">   |       v                                  v</div>
<div class="line">   |  .--------.        .--------.        .--------.</div>
<div class="line">   &#39;-&gt;| dir A  |-------&gt;| dir A  |-------&gt;| dir B  |</div>
<div class="line">      | pair 0 |        | pair 1 |        | pair 0 |</div>
<div class="line">      |        |        |        |        |        |</div>
<div class="line">      &#39;--------&#39;        &#39;--------&#39;        &#39;--------&#39;</div>
<div class="line">      .-&#39;    &#39;-.            |             .-&#39;    &#39;-.</div>
<div class="line">     v          v           v            v          v</div>
<div class="line">.--------.  .--------.  .--------.  .--------.  .--------.</div>
<div class="line">| file C |  | file D |  | file E |  | file F |  | file G |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |</div>
<div class="line">|        |  |        |  |        |  |        |  |        |</div>
<div class="line">&#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><p>This threaded tree approach does come with a few tradeoffs. Now, any time we want to manipulate the directory tree, we find ourselves having to update two pointers instead of one. For anyone familiar with creating atomic data structures, this should set off a whole bunch of red flags.</p>
<p>But unlike the data structure people, we can update a whole block atomically! So as long as we're really careful (and cheat a little bit), we can still manipulate the directory tree in a way that is resilient to power loss.</p>
<p>Consider how we might add a new directory. Because both pointers that reference it can come from the same directory, we only need a single atomic update to finagle the directory into the filesystem: </p><div class="fragment"><div class="line">   .--------.</div>
<div class="line">   |root dir|-.</div>
<div class="line">   | pair 0 | |</div>
<div class="line">.--|        |-&#39;</div>
<div class="line">|  &#39;--------&#39;</div>
<div class="line">|      |</div>
<div class="line">|      v</div>
<div class="line">|  .--------.</div>
<div class="line">&#39;-&gt;| dir A  |</div>
<div class="line">   | pair 0 |</div>
<div class="line">   |        |</div>
<div class="line">   &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  create the new directory block</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">               .--------.</div>
<div class="line">               |root dir|-.</div>
<div class="line">               | pair 0 | |</div>
<div class="line">            .--|        |-&#39;</div>
<div class="line">            |  &#39;--------&#39;</div>
<div class="line">            |      |</div>
<div class="line">            |      v</div>
<div class="line">            |  .--------.</div>
<div class="line">.--------.  &#39;-&gt;| dir A  |</div>
<div class="line">| dir B  |----&gt;| pair 0 |</div>
<div class="line">| pair 0 |     |        |</div>
<div class="line">|        |     &#39;--------&#39;</div>
<div class="line">&#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  update root to point to directory B</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">         .--------.</div>
<div class="line">         |root dir|-.</div>
<div class="line">         | pair 0 | |</div>
<div class="line">.--------|        |-&#39;</div>
<div class="line">|        &#39;--------&#39;</div>
<div class="line">|        .-&#39;    &#39;-.</div>
<div class="line">|       v          v</div>
<div class="line">|  .--------.  .--------.</div>
<div class="line">&#39;-&gt;| dir B  |-&gt;| dir A  |</div>
<div class="line">   | pair 0 |  | pair 0 |</div>
<div class="line">   |        |  |        |</div>
<div class="line">   &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><p>Note that even though directory B was added after directory A, we insert directory B before directory A in the linked-list because it is convenient.</p>
<p>Now how about removal: </p><div class="fragment"><div class="line">         .--------.        .--------.</div>
<div class="line">         |root dir|-------&gt;|root dir|-.</div>
<div class="line">         | pair 0 |        | pair 1 | |</div>
<div class="line">.--------|        |--------|        |-&#39;</div>
<div class="line">|        &#39;--------&#39;        &#39;--------&#39;</div>
<div class="line">|        .-&#39;    &#39;-.            |</div>
<div class="line">|       v          v           v</div>
<div class="line">|  .--------.  .--------.  .--------.</div>
<div class="line">&#39;-&gt;| dir A  |-&gt;| dir B  |-&gt;| dir C  |</div>
<div class="line">   | pair 0 |  | pair 0 |  | pair 0 |</div>
<div class="line">   |        |  |        |  |        |</div>
<div class="line">   &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  update root to no longer contain directory B</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">   .--------.              .--------.</div>
<div class="line">   |root dir|-------------&gt;|root dir|-.</div>
<div class="line">   | pair 0 |              | pair 1 | |</div>
<div class="line">.--|        |--------------|        |-&#39;</div>
<div class="line">|  &#39;--------&#39;              &#39;--------&#39;</div>
<div class="line">|      |                       |</div>
<div class="line">|      v                       v</div>
<div class="line">|  .--------.  .--------.  .--------.</div>
<div class="line">&#39;-&gt;| dir A  |-&gt;| dir B  |-&gt;| dir C  |</div>
<div class="line">   | pair 0 |  | pair 0 |  | pair 0 |</div>
<div class="line">   |        |  |        |  |        |</div>
<div class="line">   &#39;--------&#39;  &#39;--------&#39;  &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  remove directory B from the linked-list</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">   .--------.  .--------.</div>
<div class="line">   |root dir|-&gt;|root dir|-.</div>
<div class="line">   | pair 0 |  | pair 1 | |</div>
<div class="line">.--|        |--|        |-&#39;</div>
<div class="line">|  &#39;--------&#39;  &#39;--------&#39;</div>
<div class="line">|      |           |</div>
<div class="line">|      v           v</div>
<div class="line">|  .--------.  .--------.</div>
<div class="line">&#39;-&gt;| dir A  |-&gt;| dir C  |</div>
<div class="line">   | pair 0 |  | pair 0 |</div>
<div class="line">   |        |  |        |</div>
<div class="line">   &#39;--------&#39;  &#39;--------&#39;</div>
</div><!-- fragment --><p>Wait, wait, wait; that's not atomic at all! If power is lost after removing directory B from the root, directory B is still in the linked-list. We've just created a memory leak!</p>
<p>And to be honest, I don't have a clever solution for this case. As a side-effect of using multiple pointers in the threaded tree, the littlefs can end up with orphan blocks that have no parents and should have been removed.</p>
<p>To keep these orphan blocks from becoming a problem, the littlefs has a deorphan step that simply iterates through every directory in the linked-list and checks it against every directory entry in the filesystem to see if it has a parent. The deorphan step occurs on the first block allocation after boot, so orphans should never cause the littlefs to run out of storage prematurely. Note that the deorphan step never needs to run in a read-only filesystem.</p>
<h1><a class="anchor" id="autotoc_md1017"></a>
The move problem</h1>
<p>Now we have a real problem. How do we move things between directories while remaining power resilient? Even looking at the problem from a high level, it seems impossible. We can update directory blocks atomically, but atomically updating two independent directory blocks is not an atomic operation.</p>
<p>Here's the steps the filesystem may go through to move a directory: </p><div class="fragment"><div class="line">         .--------.</div>
<div class="line">         |root dir|-.</div>
<div class="line">         | pair 0 | |</div>
<div class="line">.--------|        |-&#39;</div>
<div class="line">|        &#39;--------&#39;</div>
<div class="line">|        .-&#39;    &#39;-.</div>
<div class="line">|       v          v</div>
<div class="line">|  .--------.  .--------.</div>
<div class="line">&#39;-&gt;| dir A  |-&gt;| dir B  |</div>
<div class="line">   | pair 0 |  | pair 0 |</div>
<div class="line">   |        |  |        |</div>
<div class="line">   &#39;--------&#39;  &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  update directory B to point to directory A</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">         .--------.</div>
<div class="line">         |root dir|-.</div>
<div class="line">         | pair 0 | |</div>
<div class="line">.--------|        |-&#39;</div>
<div class="line">|        &#39;--------&#39;</div>
<div class="line">|    .-----&#39;    &#39;-.</div>
<div class="line">|    |             v</div>
<div class="line">|    |           .--------.</div>
<div class="line">|    |        .-&gt;| dir B  |</div>
<div class="line">|    |        |  | pair 0 |</div>
<div class="line">|    |        |  |        |</div>
<div class="line">|    |        |  &#39;--------&#39;</div>
<div class="line">|    |     .-------&#39;</div>
<div class="line">|    v    v   |</div>
<div class="line">|  .--------. |</div>
<div class="line">&#39;-&gt;| dir A  |-&#39;</div>
<div class="line">   | pair 0 |</div>
<div class="line">   |        |</div>
<div class="line">   &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  update root to no longer contain directory A</div>
<div class="line">v</div>
<div class="line">     .--------.</div>
<div class="line">     |root dir|-.</div>
<div class="line">     | pair 0 | |</div>
<div class="line">.----|        |-&#39;</div>
<div class="line">|    &#39;--------&#39;</div>
<div class="line">|        |</div>
<div class="line">|        v</div>
<div class="line">|    .--------.</div>
<div class="line">| .-&gt;| dir B  |</div>
<div class="line">| |  | pair 0 |</div>
<div class="line">| &#39;--|        |-.</div>
<div class="line">|    &#39;--------&#39; |</div>
<div class="line">|        |      |</div>
<div class="line">|        v      |</div>
<div class="line">|    .--------. |</div>
<div class="line">&#39;---&gt;| dir A  |-&#39;</div>
<div class="line">     | pair 0 |</div>
<div class="line">     |        |</div>
<div class="line">     &#39;--------&#39;</div>
</div><!-- fragment --><p>We can leave any orphans up to the deorphan step to collect, but that doesn't help the case where dir A has both dir B and the root dir as parents if we lose power inconveniently.</p>
<p>Initially, you might think this is fine. Dir A <em>might</em> end up with two parents, but the filesystem will still work as intended. But then this raises the question of what do we do when the dir A wears out? For other directory blocks, we can update the parent pointer, but for a dir with two parents, we would need to work out how to update both parents. And the check for multiple parents would need to be carried out for every directory, even if the directory has never been moved.</p>
<p>It also presents a bad user-experience. Because the condition of ending up with two parents is rare, it's unlikely user-level code will be prepared. Just think about how users would recover from a multiparented directory. They can't just remove one directory because remove would report the directory as "not empty".</p>
<p>Other atomic filesystems simply COW the entire directory tree. But this introduces a significant bit of complexity, which leads to code size, along with a surprisingly expensive runtime cost during what most users assume is a single pointer update.</p>
<p>Another option is to update the directory block we're moving from to point to the destination with a sort of predicate that we have moved if the destination exists. Unfortunately, the omnipresent concern of wear could cause any of these directory entries to change blocks, and changing the entry size before a move introduces complications if it spills out of the current directory block.</p>
<p>So how do we go about moving a directory atomically?</p>
<p>We rely on the improbableness of power loss.</p>
<p>Power loss during a move is certainly possible, but it's actually relatively rare. Unless a device is writing to a filesystem constantly, it's unlikely that a power loss will occur during filesystem activity. We still need to handle the condition, but runtime during a power loss takes a back seat to the runtime during normal operations.</p>
<p>So what littlefs does is inelegantly simple. When littlefs moves a file, it marks the file as "moving". This is stored as a single bit in the directory entry and doesn't take up much space. Then littlefs moves the directory, finishing with the complete remove of the "moving" directory entry.</p>
<div class="fragment"><div class="line">         .--------.</div>
<div class="line">         |root dir|-.</div>
<div class="line">         | pair 0 | |</div>
<div class="line">.--------|        |-&#39;</div>
<div class="line">|        &#39;--------&#39;</div>
<div class="line">|        .-&#39;    &#39;-.</div>
<div class="line">|       v          v</div>
<div class="line">|  .--------.  .--------.</div>
<div class="line">&#39;-&gt;| dir A  |-&gt;| dir B  |</div>
<div class="line">   | pair 0 |  | pair 0 |</div>
<div class="line">   |        |  |        |</div>
<div class="line">   &#39;--------&#39;  &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  update root directory to mark directory A as moving</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">        .----------.</div>
<div class="line">        |root dir  |-.</div>
<div class="line">        | pair 0   | |</div>
<div class="line">.-------| moving A!|-&#39;</div>
<div class="line">|       &#39;----------&#39;</div>
<div class="line">|        .-&#39;    &#39;-.</div>
<div class="line">|       v          v</div>
<div class="line">|  .--------.  .--------.</div>
<div class="line">&#39;-&gt;| dir A  |-&gt;| dir B  |</div>
<div class="line">   | pair 0 |  | pair 0 |</div>
<div class="line">   |        |  |        |</div>
<div class="line">   &#39;--------&#39;  &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  update directory B to point to directory A</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">        .----------.</div>
<div class="line">        |root dir  |-.</div>
<div class="line">        | pair 0   | |</div>
<div class="line">.-------| moving A!|-&#39;</div>
<div class="line">|       &#39;----------&#39;</div>
<div class="line">|    .-----&#39;    &#39;-.</div>
<div class="line">|    |             v</div>
<div class="line">|    |           .--------.</div>
<div class="line">|    |        .-&gt;| dir B  |</div>
<div class="line">|    |        |  | pair 0 |</div>
<div class="line">|    |        |  |        |</div>
<div class="line">|    |        |  &#39;--------&#39;</div>
<div class="line">|    |     .-------&#39;</div>
<div class="line">|    v    v   |</div>
<div class="line">|  .--------. |</div>
<div class="line">&#39;-&gt;| dir A  |-&#39;</div>
<div class="line">   | pair 0 |</div>
<div class="line">   |        |</div>
<div class="line">   &#39;--------&#39;</div>
<div class="line"> </div>
<div class="line">|  update root to no longer contain directory A</div>
<div class="line">v</div>
<div class="line">     .--------.</div>
<div class="line">     |root dir|-.</div>
<div class="line">     | pair 0 | |</div>
<div class="line">.----|        |-&#39;</div>
<div class="line">|    &#39;--------&#39;</div>
<div class="line">|        |</div>
<div class="line">|        v</div>
<div class="line">|    .--------.</div>
<div class="line">| .-&gt;| dir B  |</div>
<div class="line">| |  | pair 0 |</div>
<div class="line">| &#39;--|        |-.</div>
<div class="line">|    &#39;--------&#39; |</div>
<div class="line">|        |      |</div>
<div class="line">|        v      |</div>
<div class="line">|    .--------. |</div>
<div class="line">&#39;---&gt;| dir A  |-&#39;</div>
<div class="line">     | pair 0 |</div>
<div class="line">     |        |</div>
<div class="line">     &#39;--------&#39;</div>
</div><!-- fragment --><p>Now, if we run into a directory entry that has been marked as "moved", one of two things is possible. Either the directory entry exists elsewhere in the filesystem, or it doesn't. This is a O(n) operation, but only occurs in the unlikely case we lost power during a move.</p>
<p>And we can easily fix the "moved" directory entry. Because we're already scanning the filesystem during the deorphan step, we can also check for moved entries. If we find one, we either remove the "moved" marking or remove the whole entry if it exists elsewhere in the filesystem.</p>
<h1><a class="anchor" id="autotoc_md1018"></a>
Wear awareness</h1>
<p>So now that we have all of the pieces of a filesystem, we can look at a more subtle attribute of embedded storage: The wear down of flash blocks.</p>
<p>The first concern for the littlefs, is that perfectly valid blocks can suddenly become unusable. As a nice side-effect of using a COW data-structure for files, we can simply move on to a different block when a file write fails. All modifications to files are performed in copies, so we will only replace the old file when we are sure none of the new file has errors. Directories, on the other hand, need a different strategy.</p>
<p>The solution to directory corruption in the littlefs relies on the redundant nature of the metadata pairs. If an error is detected during a write to one of the metadata pairs, we seek a new block to take its place. Once we find a block without errors, we iterate through the directory tree, updating any references to the corrupted metadata pair to point to the new metadata block. Just like when we remove directories, we can lose power during this operation and end up with a desynchronized metadata pair in our filesystem. And just like when we remove directories, we leave the possibility of a desynchronized metadata pair up to the deorphan step to clean up.</p>
<p>Here's what encountering a directory error may look like with all of the directories and directory pointers fully expanded: </p><div class="fragment"><div class="line">         root dir</div>
<div class="line">         block 1   block 2</div>
<div class="line">       .---------.---------.</div>
<div class="line">       | rev: 1  | rev: 0  |--.</div>
<div class="line">       |         |         |-.|</div>
<div class="line">.------|         |         |-|&#39;</div>
<div class="line">|.-----|         |         |-&#39;</div>
<div class="line">||     &#39;---------&#39;---------&#39;</div>
<div class="line">||       |||||&#39;--------------------------------------------------.</div>
<div class="line">||       ||||&#39;-----------------------------------------.         |</div>
<div class="line">||       |||&#39;-----------------------------.            |         |</div>
<div class="line">||       ||&#39;--------------------.         |            |         |</div>
<div class="line">||       |&#39;-------.             |         |            |         |</div>
<div class="line">||       v         v            v         v            v         v</div>
<div class="line">||    dir A                  dir B                  dir C</div>
<div class="line">||    block 3   block 4      block 5   block 6      block 7   block 8</div>
<div class="line">||  .---------.---------.  .---------.---------.  .---------.---------.</div>
<div class="line">|&#39;-&gt;| rev: 1  | rev: 0  |-&gt;| rev: 1  | rev: 0  |-&gt;| rev: 1  | rev: 0  |</div>
<div class="line">&#39;--&gt;|         |         |-&gt;|         |         |-&gt;|         |         |</div>
<div class="line">    |         |         |  |         |         |  |</div>
<div class="line">    |         |         |  |         |         |  |         |         |</div>
<div class="line">    &#39;---------&#39;---------&#39;  &#39;---------&#39;---------&#39;  &#39;---------&#39;---------&#39;</div>
<div class="line"> </div>
<div class="line">|  update directory B</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">         root dir</div>
<div class="line">         block 1   block 2</div>
<div class="line">       .---------.---------.</div>
<div class="line">       | rev: 1  | rev: 0  |--.</div>
<div class="line">       |         |         |-.|</div>
<div class="line">.------|         |         |-|&#39;</div>
<div class="line">|.-----|         |         |-&#39;</div>
<div class="line">||     &#39;---------&#39;---------&#39;</div>
<div class="line">||       |||||&#39;--------------------------------------------------.</div>
<div class="line">||       ||||&#39;-----------------------------------------.         |</div>
<div class="line">||       |||&#39;-----------------------------.            |         |</div>
<div class="line">||       ||&#39;--------------------.         |            |         |</div>
<div class="line">||       |&#39;-------.             |         |            |         |</div>
<div class="line">||       v         v            v         v            v         v</div>
<div class="line">||    dir A                  dir B                  dir C</div>
<div class="line">||    block 3   block 4      block 5   block 6      block 7   block 8</div>
<div class="line">||  .---------.---------.  .---------.---------.  .---------.---------.</div>
<div class="line">|&#39;-&gt;| rev: 1  | rev: 0  |-&gt;| rev: 1  | rev: 2  |-&gt;| rev: 1  | rev: 0  |</div>
<div class="line">&#39;--&gt;|         |         |-&gt;|         | corrupt!|-&gt;|         |         |</div>
<div class="line">    |         |         |  |         | corrupt!|  |         |         |</div>
<div class="line">    |         |         |  |         | corrupt!|  |         |         |</div>
<div class="line">    &#39;---------&#39;---------&#39;  &#39;---------&#39;---------&#39;  &#39;---------&#39;---------&#39;</div>
<div class="line"> </div>
<div class="line">|  oh no! corruption detected</div>
<div class="line">v  allocate a replacement block</div>
<div class="line"> </div>
<div class="line">         root dir</div>
<div class="line">         block 1   block 2</div>
<div class="line">       .---------.---------.</div>
<div class="line">       | rev: 1  | rev: 0  |--.</div>
<div class="line">       |         |         |-.|</div>
<div class="line">.------|         |         |-|&#39;</div>
<div class="line">|.-----|         |         |-&#39;</div>
<div class="line">||     &#39;---------&#39;---------&#39;</div>
<div class="line">||       |||||&#39;----------------------------------------------------.</div>
<div class="line">||       ||||&#39;-------------------------------------------.         |</div>
<div class="line">||       |||&#39;-----------------------------.              |         |</div>
<div class="line">||       ||&#39;--------------------.         |              |         |</div>
<div class="line">||       |&#39;-------.             |         |              |         |</div>
<div class="line">||       v         v            v         v              v         v</div>
<div class="line">||    dir A                  dir B                    dir C</div>
<div class="line">||    block 3   block 4      block 5   block 6        block 7   block 8</div>
<div class="line">||  .---------.---------.  .---------.---------.    .---------.---------.</div>
<div class="line">|&#39;-&gt;| rev: 1  | rev: 0  |-&gt;| rev: 1  | rev: 2  |---&gt;| rev: 1  | rev: 0  |</div>
<div class="line">&#39;--&gt;|         |         |-&gt;|         | corrupt!|---&gt;|         |         |</div>
<div class="line">    |         |         |  |         | corrupt!| .-&gt;|         |         |</div>
<div class="line">    |         |         |  |         | corrupt!| |  |         |         |</div>
<div class="line">    &#39;---------&#39;---------&#39;  &#39;---------&#39;---------&#39; |  &#39;---------&#39;---------&#39;</div>
<div class="line">                                       block 9   |</div>
<div class="line">                                     .---------. |</div>
<div class="line">                                     | rev: 2  |-&#39;</div>
<div class="line">                                     |         |</div>
<div class="line">                                     |         |</div>
<div class="line">                                     |         |</div>
<div class="line">                                     &#39;---------&#39;</div>
<div class="line"> </div>
<div class="line">|  update root directory to contain block 9</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">        root dir</div>
<div class="line">        block 1   block 2</div>
<div class="line">      .---------.---------.</div>
<div class="line">      | rev: 1  | rev: 2  |--.</div>
<div class="line">      |         |         |-.|</div>
<div class="line">.-----|         |         |-|&#39;</div>
<div class="line">|.----|         |         |-&#39;</div>
<div class="line">||    &#39;---------&#39;---------&#39;</div>
<div class="line">||       .--------&#39;||||&#39;----------------------------------------------.</div>
<div class="line">||       |         |||&#39;-------------------------------------.         |</div>
<div class="line">||       |         ||&#39;-----------------------.              |         |</div>
<div class="line">||       |         |&#39;------------.           |              |         |</div>
<div class="line">||       |         |             |           |              |         |</div>
<div class="line">||       v         v             v           v              v         v</div>
<div class="line">||    dir A                   dir B                      dir C</div>
<div class="line">||    block 3   block 4       block 5     block 9        block 7   block 8</div>
<div class="line">||  .---------.---------.   .---------. .---------.    .---------.---------.</div>
<div class="line">|&#39;-&gt;| rev: 1  | rev: 0  |--&gt;| rev: 1  |-| rev: 2  |---&gt;| rev: 1  | rev: 0  |</div>
<div class="line">&#39;--&gt;|         |         |-. |         | |         |---&gt;|         |         |</div>
<div class="line">    |         |         | | |         | |         | .-&gt;|         |         |</div>
<div class="line">    |         |         | | |         | |         | |  |         |         |</div>
<div class="line">    &#39;---------&#39;---------&#39; | &#39;---------&#39; &#39;---------&#39; |  &#39;---------&#39;---------&#39;</div>
<div class="line">                          |               block 6   |</div>
<div class="line">                          |             .---------. |</div>
<div class="line">                          &#39;------------&gt;| rev: 2  |-&#39;</div>
<div class="line">                                        | corrupt!|</div>
<div class="line">                                        | corrupt!|</div>
<div class="line">                                        | corrupt!|</div>
<div class="line">                                        &#39;---------&#39;</div>
<div class="line"> </div>
<div class="line">|  remove corrupted block from linked-list</div>
<div class="line">v</div>
<div class="line"> </div>
<div class="line">        root dir</div>
<div class="line">        block 1   block 2</div>
<div class="line">      .---------.---------.</div>
<div class="line">      | rev: 1  | rev: 2  |--.</div>
<div class="line">      |         |         |-.|</div>
<div class="line">.-----|         |         |-|&#39;</div>
<div class="line">|.----|         |         |-&#39;</div>
<div class="line">||    &#39;---------&#39;---------&#39;</div>
<div class="line">||       .--------&#39;||||&#39;-----------------------------------------.</div>
<div class="line">||       |         |||&#39;--------------------------------.         |</div>
<div class="line">||       |         ||&#39;--------------------.            |         |</div>
<div class="line">||       |         |&#39;-----------.         |            |         |</div>
<div class="line">||       |         |            |         |            |         |</div>
<div class="line">||       v         v            v         v            v         v</div>
<div class="line">||    dir A                  dir B                  dir C</div>
<div class="line">||    block 3   block 4      block 5   block 9      block 7   block 8</div>
<div class="line">||  .---------.---------.  .---------.---------.  .---------.---------.</div>
<div class="line">|&#39;-&gt;| rev: 1  | rev: 2  |-&gt;| rev: 1  | rev: 2  |-&gt;| rev: 1  | rev: 0  |</div>
<div class="line">&#39;--&gt;|         |         |-&gt;|         |         |-&gt;|         |         |</div>
<div class="line">    |         |         |  |         |         |  |         |         |</div>
<div class="line">    |         |         |  |         |         |  |         |         |</div>
<div class="line">    &#39;---------&#39;---------&#39;  &#39;---------&#39;---------&#39;  &#39;---------&#39;---------&#39;</div>
</div><!-- fragment --><p>Also one question I've been getting is: What about the root directory? It can't move, so wouldn't the filesystem die as soon as the root blocks develop errors? And you would be correct. So instead of storing the root in the first few blocks of the storage, the root is actually pointed to by the superblock. The superblock contains a few bits of static data, but outside of when the filesystem is formatted, it is only updated when the root develops errors and needs to be moved.</p>
<h1><a class="anchor" id="autotoc_md1019"></a>
Wear leveling</h1>
<p>The second concern for the littlefs is that blocks in the filesystem may wear unevenly. In this situation, a filesystem may meet an early demise where there are no more non-corrupted blocks that aren't in use. It's common to have files that were written once and left unmodified, wasting the potential erase cycles of the blocks it sits on.</p>
<p>Wear leveling is a term that describes distributing block writes evenly to avoid the early termination of a flash part. There are typically two levels of wear leveling:</p><ol type="1">
<li>Dynamic wear leveling - Wear is distributed evenly across all <b>dynamic</b> blocks. Usually this is accomplished by simply choosing the unused block with the lowest amount of wear. Note this does not solve the problem of static data.</li>
<li>Static wear leveling - Wear is distributed evenly across all <b>dynamic</b> and <b>static</b> blocks. Unmodified blocks may be evicted for new block writes. This does handle the problem of static data but may lead to wear amplification.</li>
</ol>
<p>In littlefs's case, it's possible to use the revision count on metadata pairs to approximate the wear of a metadata block. And combined with the COW nature of files, littlefs could provide your usual implementation of dynamic wear leveling.</p>
<p>However, the littlefs does not. This is for a few reasons. Most notably, even if the littlefs did implement dynamic wear leveling, this would still not handle the case of write-once files, and near the end of the lifetime of a flash device, you would likely end up with uneven wear on the blocks anyways.</p>
<p>As a flash device reaches the end of its life, the metadata blocks will naturally be the first to go because they are updated most often. In this situation, the littlefs is designed to simply move on to another set of metadata blocks. This traveling means that at the end of a flash device's life, the filesystem will have worn the device down nearly as evenly as the usual dynamic wear leveling could. More aggressive wear leveling would come with a code-size cost for marginal benefit.</p>
<p>One important takeaway to note:, If your storage stack uses highly sensitive storage, such as NAND flash, static wear leveling is the only valid solution. In most cases, you are going to be better off using a full <a href="https://en.wikipedia.org/wiki/Flash_translation_layer">flash translation layer (FTL)</a>. NAND flash already has many limitations that make it poorly suited for an embedded system: low erase cycles, very large blocks, errors that can develop even during reads, errors that can develop during writes of neighboring blocks. Managing sensitive storage, such as NAND flash, is out of scope for the littlefs. The littlefs does have some properties that may be beneficial on top of an FTL, such as limiting the number of writes where possible, but if you have the storage requirements that necessitate the need of NAND flash, you should have the RAM to match and just use an FTL or flash filesystem.</p>
<h1><a class="anchor" id="autotoc_md1020"></a>
Summary</h1>
<p>So, to summarize:</p>
<ol type="1">
<li>The littlefs is composed of directory blocks.</li>
<li>Each directory is a linked-list of metadata pairs.</li>
<li>These metadata pairs can be updated atomically by alternating which metadata block is active</li>
<li>Directory blocks contain either references to other directories or files</li>
<li>Files are represented by copy-on-write CTZ skip-lists which support O(1) append and O(n log n) reading</li>
<li>Blocks are allocated by scanning the filesystem for used blocks in a fixed-size lookahead region that is stored in a bit-vector</li>
<li>To facilitate scanning the filesystem, all directories are part of a linked-list that is threaded through the entire filesystem.</li>
<li>If a block develops an error, the littlefs allocates a new block and moves the data and references of the old block to the new.</li>
<li>Any case where an atomic operation is not possible, mistakes are resolved by a deorphan step that occurs on the first allocation after boot.</li>
</ol>
<p>That's the little filesystem. Thanks for reading! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
