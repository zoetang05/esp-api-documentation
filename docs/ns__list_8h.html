<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: /home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/libraries/nanostack-libservice/mbed-client-libservice/ns_list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('ns__list_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">ns_list.h File Reference<div class="ingroups"><a class="el" href="group__ns__list.html">Linked list support library.</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Linked list support library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ns__types_8h_source.html">ns_types.h</a>&quot;</code><br />
</div>
<p><a href="ns__list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structns__list.html">ns_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying generic linked list head.  <a href="structns__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structns__list__link.html">ns_list_link</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the link member in the user's entry structure.  <a href="structns__list__link.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad9c12dc26147f44613348d00e085f1c0" id="r_ad9c12dc26147f44613348d00e085f1c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a>(entry_type,  field)</td></tr>
<tr class="memdesc:ad9c12dc26147f44613348d00e085f1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a list head type.  <br /></td></tr>
<tr class="separator:ad9c12dc26147f44613348d00e085f1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eafe156a81b7776a93b8eddaa87e379" id="r_a0eafe156a81b7776a93b8eddaa87e379"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eafe156a81b7776a93b8eddaa87e379">NS_LIST_HEAD_INCOMPLETE</a>(entry_type)</td></tr>
<tr class="memdesc:a0eafe156a81b7776a93b8eddaa87e379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a list head type for an incomplete entry type.  <br /></td></tr>
<tr class="separator:a0eafe156a81b7776a93b8eddaa87e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66032ceb6767d11b5f237034e3431f1" id="r_ab66032ceb6767d11b5f237034e3431f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab66032ceb6767d11b5f237034e3431f1">NS_LIST_HEAD_BY_OFFSET_</a>(entry_type,  link_offset)</td></tr>
<tr class="memdesc:ab66032ceb6767d11b5f237034e3431f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal macro defining a list head, given the offset to the link pointer The +1 allows for link_offset being 0 - we can't declare a 0-size array.  <br /></td></tr>
<tr class="separator:ab66032ceb6767d11b5f237034e3431f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a22ca0f67693acc53600c30ef70402" id="r_a48a22ca0f67693acc53600c30ef70402"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48a22ca0f67693acc53600c30ef70402">NS_LIST_OFFSET_</a>(<a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:a48a22ca0f67693acc53600c30ef70402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset of link field in entry.  <br /></td></tr>
<tr class="separator:a48a22ca0f67693acc53600c30ef70402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0e3ac9ee881e9bbf614dea56ad80ac" id="r_a5b0e3ac9ee881e9bbf614dea56ad80ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b0e3ac9ee881e9bbf614dea56ad80ac">NS_PTR_MATCH_</a>(a,  b,  str)</td></tr>
<tr class="memdesc:a5b0e3ac9ee881e9bbf614dea56ad80ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for compatible pointer types.  <br /></td></tr>
<tr class="separator:a5b0e3ac9ee881e9bbf614dea56ad80ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aec9d3c2d9052b96186ab9862adeefc" id="r_a8aec9d3c2d9052b96186ab9862adeefc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8aec9d3c2d9052b96186ab9862adeefc">NS_LIST_TYPECAST_</a>(<a class="el" href="structlist.html">list</a>,  val)</td></tr>
<tr class="memdesc:a8aec9d3c2d9052b96186ab9862adeefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal macro to cast returned entry pointers to correct type.  <br /></td></tr>
<tr class="separator:a8aec9d3c2d9052b96186ab9862adeefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3f7205b5047586cc183ed47795218c" id="r_a8a3f7205b5047586cc183ed47795218c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type,  val)</td></tr>
<tr class="memdesc:a8a3f7205b5047586cc183ed47795218c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to force correct type if necessary.  <br /></td></tr>
<tr class="separator:a8a3f7205b5047586cc183ed47795218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74425da7c993fb9b99198cbc49b6ca88" id="r_a74425da7c993fb9b99198cbc49b6ca88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74425da7c993fb9b99198cbc49b6ca88">NS_LIST_TYPECHECK_</a>(<a class="el" href="structlist.html">list</a>,  entry)</td></tr>
<tr class="memdesc:a74425da7c993fb9b99198cbc49b6ca88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal macro to check types of input entry pointer.  <br /></td></tr>
<tr class="separator:a74425da7c993fb9b99198cbc49b6ca88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88ac510e4c61c91d733fe946852949a" id="r_ab88ac510e4c61c91d733fe946852949a"><td class="memItemLeft" align="right" valign="top"><a id="ab88ac510e4c61c91d733fe946852949a" name="ab88ac510e4c61c91d733fe946852949a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NS_LIST_POISON</b>&#160;&#160;&#160;((void *) 0xDEADBEEF)</td></tr>
<tr class="memdesc:ab88ac510e4c61c91d733fe946852949a"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Poison" value placed in unattached entries' link pointers. <br /></td></tr>
<tr class="separator:ab88ac510e4c61c91d733fe946852949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117c63fb93d96acc8f47c5dcdb343fe3" id="r_a117c63fb93d96acc8f47c5dcdb343fe3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a117c63fb93d96acc8f47c5dcdb343fe3">NS_LIST_LINK_INIT</a>(name)</td></tr>
<tr class="memdesc:a117c63fb93d96acc8f47c5dcdb343fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialiser for an entry's link member.  <br /></td></tr>
<tr class="separator:a117c63fb93d96acc8f47c5dcdb343fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d79a611e9be99dbd078fa2a465b5f6f" id="r_a7d79a611e9be99dbd078fa2a465b5f6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d79a611e9be99dbd078fa2a465b5f6f">ns_list_link_init</a>(entry,  field)</td></tr>
<tr class="memdesc:a7d79a611e9be99dbd078fa2a465b5f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an entry's list link.  <br /></td></tr>
<tr class="separator:a7d79a611e9be99dbd078fa2a465b5f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9167109e82b674cc5bcdbaae364002b" id="r_ab9167109e82b674cc5bcdbaae364002b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9167109e82b674cc5bcdbaae364002b">ns_list_init</a>(<a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:ab9167109e82b674cc5bcdbaae364002b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a list.  <br /></td></tr>
<tr class="separator:ab9167109e82b674cc5bcdbaae364002b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f01ef1e1b0956a24306acae1871e86" id="r_a99f01ef1e1b0956a24306acae1871e86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99f01ef1e1b0956a24306acae1871e86">NS_LIST_INIT</a>(name)</td></tr>
<tr class="memdesc:a99f01ef1e1b0956a24306acae1871e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialiser for an empty list.  <br /></td></tr>
<tr class="separator:a99f01ef1e1b0956a24306acae1871e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6aac5e1c6351a054e1efbb3755c018" id="r_a3a6aac5e1c6351a054e1efbb3755c018"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a6aac5e1c6351a054e1efbb3755c018">NS_LIST_NAME_INIT</a>(name)</td></tr>
<tr class="memdesc:a3a6aac5e1c6351a054e1efbb3755c018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and initialiser for an empty list.  <br /></td></tr>
<tr class="separator:a3a6aac5e1c6351a054e1efbb3755c018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee74fb3290b4feae119b93b9e2ee6f3" id="r_a3ee74fb3290b4feae119b93b9e2ee6f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ee74fb3290b4feae119b93b9e2ee6f3">NS_LIST_DEFINE</a>(name,  type,  field)</td></tr>
<tr class="memdesc:a3ee74fb3290b4feae119b93b9e2ee6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a list, and initialise to empty.  <br /></td></tr>
<tr class="separator:a3ee74fb3290b4feae119b93b9e2ee6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8ed122e6b063bdf17eea5e4cfd5702" id="r_ada8ed122e6b063bdf17eea5e4cfd5702"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada8ed122e6b063bdf17eea5e4cfd5702">ns_list_add_to_start</a>(<a class="el" href="structlist.html">list</a>,  entry)</td></tr>
<tr class="memdesc:ada8ed122e6b063bdf17eea5e4cfd5702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry to the start of the linked list.  <br /></td></tr>
<tr class="separator:ada8ed122e6b063bdf17eea5e4cfd5702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f52b7db0e2728665a020676c67c7c49" id="r_a9f52b7db0e2728665a020676c67c7c49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f52b7db0e2728665a020676c67c7c49">ns_list_add_to_end</a>(<a class="el" href="structlist.html">list</a>,  entry)</td></tr>
<tr class="memdesc:a9f52b7db0e2728665a020676c67c7c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry to the end of the linked list.  <br /></td></tr>
<tr class="separator:a9f52b7db0e2728665a020676c67c7c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c2a2e529663df19e76ffbf4f21cfe1" id="r_a03c2a2e529663df19e76ffbf4f21cfe1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03c2a2e529663df19e76ffbf4f21cfe1">ns_list_add_before</a>(<a class="el" href="structlist.html">list</a>,  before,  entry)</td></tr>
<tr class="memdesc:a03c2a2e529663df19e76ffbf4f21cfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry before a specified entry.  <br /></td></tr>
<tr class="separator:a03c2a2e529663df19e76ffbf4f21cfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dc57e411a5a481207ca20e8e97dbf2" id="r_a45dc57e411a5a481207ca20e8e97dbf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45dc57e411a5a481207ca20e8e97dbf2">ns_list_add_after</a>(<a class="el" href="structlist.html">list</a>,  after,  entry)</td></tr>
<tr class="memdesc:a45dc57e411a5a481207ca20e8e97dbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry after a specified entry.  <br /></td></tr>
<tr class="separator:a45dc57e411a5a481207ca20e8e97dbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca327da5a63ae4a66b3269ce6d8e7290" id="r_aca327da5a63ae4a66b3269ce6d8e7290"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca327da5a63ae4a66b3269ce6d8e7290">ns_list_is_empty</a>(<a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:aca327da5a63ae4a66b3269ce6d8e7290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a list is empty.  <br /></td></tr>
<tr class="separator:aca327da5a63ae4a66b3269ce6d8e7290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518119c9408bb8df6256384ad799dcf8" id="r_a518119c9408bb8df6256384ad799dcf8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a518119c9408bb8df6256384ad799dcf8">ns_list_get_first</a>(<a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:a518119c9408bb8df6256384ad799dcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first entry.  <br /></td></tr>
<tr class="separator:a518119c9408bb8df6256384ad799dcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9ddc7f8c72ca5747dbaf60340deed5" id="r_a9a9ddc7f8c72ca5747dbaf60340deed5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a9ddc7f8c72ca5747dbaf60340deed5">ns_list_get_previous</a>(<a class="el" href="structlist.html">list</a>,  current)</td></tr>
<tr class="memdesc:a9a9ddc7f8c72ca5747dbaf60340deed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the previous entry.  <br /></td></tr>
<tr class="separator:a9a9ddc7f8c72ca5747dbaf60340deed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea3b17bdff37015a5173a1bbd63056e" id="r_afea3b17bdff37015a5173a1bbd63056e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afea3b17bdff37015a5173a1bbd63056e">ns_list_get_next</a>(<a class="el" href="structlist.html">list</a>,  current)</td></tr>
<tr class="memdesc:afea3b17bdff37015a5173a1bbd63056e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next entry.  <br /></td></tr>
<tr class="separator:afea3b17bdff37015a5173a1bbd63056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f494e483d6455593dff2e34fdc00b0c" id="r_a7f494e483d6455593dff2e34fdc00b0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f494e483d6455593dff2e34fdc00b0c">ns_list_get_last</a>(<a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:a7f494e483d6455593dff2e34fdc00b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last entry.  <br /></td></tr>
<tr class="separator:a7f494e483d6455593dff2e34fdc00b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db6f03e1481a09ab4ccdd9e587b2f9a" id="r_a5db6f03e1481a09ab4ccdd9e587b2f9a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5db6f03e1481a09ab4ccdd9e587b2f9a">ns_list_remove</a>(<a class="el" href="structlist.html">list</a>,  entry)</td></tr>
<tr class="memdesc:a5db6f03e1481a09ab4ccdd9e587b2f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entry.  <br /></td></tr>
<tr class="separator:a5db6f03e1481a09ab4ccdd9e587b2f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f44eda3d999d1efbe95a3ee88e90b76" id="r_a3f44eda3d999d1efbe95a3ee88e90b76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f44eda3d999d1efbe95a3ee88e90b76">ns_list_replace</a>(<a class="el" href="structlist.html">list</a>,  current,  replacement)</td></tr>
<tr class="memdesc:a3f44eda3d999d1efbe95a3ee88e90b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an entry.  <br /></td></tr>
<tr class="separator:a3f44eda3d999d1efbe95a3ee88e90b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab312c3f74e9564c607f868dbd624c7e5" id="r_ab312c3f74e9564c607f868dbd624c7e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab312c3f74e9564c607f868dbd624c7e5">ns_list_concatenate</a>(dst,  src)</td></tr>
<tr class="memdesc:ab312c3f74e9564c607f868dbd624c7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two lists.  <br /></td></tr>
<tr class="separator:ab312c3f74e9564c607f868dbd624c7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e5929bdd69350959bbdc6055f0bf7a" id="r_aa3e5929bdd69350959bbdc6055f0bf7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3e5929bdd69350959bbdc6055f0bf7a">ns_list_foreach</a>(type,  e,  <a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:aa3e5929bdd69350959bbdc6055f0bf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate forwards over a list.  <br /></td></tr>
<tr class="separator:aa3e5929bdd69350959bbdc6055f0bf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15ee8e11ba10676b3414d9c238d1358" id="r_af15ee8e11ba10676b3414d9c238d1358"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af15ee8e11ba10676b3414d9c238d1358">ns_list_foreach_safe</a>(type,  e,  <a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:af15ee8e11ba10676b3414d9c238d1358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate forwards over a list, where user may delete.  <br /></td></tr>
<tr class="separator:af15ee8e11ba10676b3414d9c238d1358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7478c8c2d27a660e4483a97199a27b06" id="r_a7478c8c2d27a660e4483a97199a27b06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7478c8c2d27a660e4483a97199a27b06">ns_list_foreach_reverse</a>(type,  e,  <a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:a7478c8c2d27a660e4483a97199a27b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate backwards over a list.  <br /></td></tr>
<tr class="separator:a7478c8c2d27a660e4483a97199a27b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b3e7f9459bb3ca93c42c482a8fa877" id="r_a63b3e7f9459bb3ca93c42c482a8fa877"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63b3e7f9459bb3ca93c42c482a8fa877">ns_list_foreach_reverse_safe</a>(type,  e,  <a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:a63b3e7f9459bb3ca93c42c482a8fa877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate backwards over a list, where user may delete.  <br /></td></tr>
<tr class="separator:a63b3e7f9459bb3ca93c42c482a8fa877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8031f2276076f960ba418b6e35cd8eb0" id="r_a8031f2276076f960ba418b6e35cd8eb0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8031f2276076f960ba418b6e35cd8eb0">ns_list_count</a>(<a class="el" href="structlist.html">list</a>)</td></tr>
<tr class="memdesc:a8031f2276076f960ba418b6e35cd8eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count entries on a list.  <br /></td></tr>
<tr class="separator:a8031f2276076f960ba418b6e35cd8eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a53690b591fb7e9ee98f15bc54f441" id="r_a54a53690b591fb7e9ee98f15bc54f441"><td class="memItemLeft" align="right" valign="top"><a id="a54a53690b591fb7e9ee98f15bc54f441" name="a54a53690b591fb7e9ee98f15bc54f441"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NS_LIST_FN</b>&#160;&#160;&#160;<a class="el" href="ns__types_8h.html#a8ee7d4d6f8ffcfc6786cf264af633000">NS_INLINE</a></td></tr>
<tr class="separator:a54a53690b591fb7e9ee98f15bc54f441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f41fb9c20f728befdb2608551820955" id="r_a0f41fb9c20f728befdb2608551820955"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f41fb9c20f728befdb2608551820955">NS_LIST_LINK_</a>(e,  offset)</td></tr>
<tr class="separator:a0f41fb9c20f728befdb2608551820955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3e117cbb6255a74e46d3f528975643" id="r_a8d3e117cbb6255a74e46d3f528975643"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d3e117cbb6255a74e46d3f528975643">NS_LIST_NEXT_</a>(e,  offset)</td></tr>
<tr class="separator:a8d3e117cbb6255a74e46d3f528975643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2098ff73b29c1c34d110bd71af7d09e6" id="r_a2098ff73b29c1c34d110bd71af7d09e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2098ff73b29c1c34d110bd71af7d09e6">NS_LIST_PREV_</a>(e,  offset)</td></tr>
<tr class="separator:a2098ff73b29c1c34d110bd71af7d09e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432840529a6802a8ccf161b9d3f1a1a5" id="r_a432840529a6802a8ccf161b9d3f1a1a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a432840529a6802a8ccf161b9d3f1a1a5">NS_LIST_ENTRY_</a>(linkptr,  offset)</td></tr>
<tr class="separator:a432840529a6802a8ccf161b9d3f1a1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a43a0fb5da933ff2ff6a253a3e4922e81" id="r_a43a0fb5da933ff2ff6a253a3e4922e81"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structns__list.html">ns_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43a0fb5da933ff2ff6a253a3e4922e81">ns_list_t</a></td></tr>
<tr class="memdesc:a43a0fb5da933ff2ff6a253a3e4922e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying generic linked list head.  <br /></td></tr>
<tr class="separator:a43a0fb5da933ff2ff6a253a3e4922e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3177affad7a5581521d5732e58c908" id="r_a1e3177affad7a5581521d5732e58c908"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structns__list__link.html">ns_list_link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e3177affad7a5581521d5732e58c908">ns_list_link_t</a></td></tr>
<tr class="memdesc:a1e3177affad7a5581521d5732e58c908"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the link member in the user's entry structure.  <br /></td></tr>
<tr class="separator:a1e3177affad7a5581521d5732e58c908"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linked list support library. </p>
<p>The <a class="el" href="ns__list_8h.html" title="Linked list support library.">ns_list.h</a> file provides a doubly-linked list/queue, providing O(1) performance for all insertion/removal operations, and access to either end of the list.</p>
<p>Memory footprint is two pointers for the list head, and two pointers in each list entry. It is similar in concept to BSD's TAILQ.</p>
<p>Although the API is symmetrical and O(1) in both directions, due to internal pointer design, it is <em>slightly</em> more efficient to insert at the end when used as a queue, and to iterate forwards rather than backwards.</p>
<p>Example of an entry type that can be stored to this list. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>example_entry</div>
<div class="line">{</div>
<div class="line">    uint8_t        *data;</div>
<div class="line">    uint32_t       data_count;</div>
<div class="line">    <a class="code hl_typedef" href="#a1e3177affad7a5581521d5732e58c908">ns_list_link_t</a> link;</div>
<div class="line">}</div>
<div class="line">example_entry_t;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_define" href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a>(example_entry_t, link) my_list;</div>
<div class="line"><a class="code hl_define" href="#ab9167109e82b674cc5bcdbaae364002b">ns_list_init</a>(&amp;my_list);</div>
<div class="ttc" id="ans__list_8h_html_a1e3177affad7a5581521d5732e58c908"><div class="ttname"><a href="#a1e3177affad7a5581521d5732e58c908">ns_list_link_t</a></div><div class="ttdeci">struct ns_list_link ns_list_link_t</div><div class="ttdoc">The type for the link member in the user&#39;s entry structure.</div></div>
<div class="ttc" id="ans__list_8h_html_ab9167109e82b674cc5bcdbaae364002b"><div class="ttname"><a href="#ab9167109e82b674cc5bcdbaae364002b">ns_list_init</a></div><div class="ttdeci">#define ns_list_init(list)</div><div class="ttdoc">Initialise a list.</div><div class="ttdef"><b>Definition</b> ns_list.h:303</div></div>
<div class="ttc" id="ans__list_8h_html_ad9c12dc26147f44613348d00e085f1c0"><div class="ttname"><a href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a></div><div class="ttdeci">#define NS_LIST_HEAD(entry_type, field)</div><div class="ttdoc">Declare a list head type.</div><div class="ttdef"><b>Definition</b> ns_list.h:133</div></div>
</div><!-- fragment --><p> OR </p><div class="fragment"><div class="line"><a class="code hl_define" href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a>(example_entry_t, link) my_list = <a class="code hl_define" href="#a99f01ef1e1b0956a24306acae1871e86">NS_LIST_INIT</a>(my_list);</div>
<div class="ttc" id="ans__list_8h_html_a99f01ef1e1b0956a24306acae1871e86"><div class="ttname"><a href="#a99f01ef1e1b0956a24306acae1871e86">NS_LIST_INIT</a></div><div class="ttdeci">#define NS_LIST_INIT(name)</div><div class="ttdoc">Initialiser for an empty list.</div><div class="ttdef"><b>Definition</b> ns_list.h:318</div></div>
</div><!-- fragment --><p> OR </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_define" href="#a3ee74fb3290b4feae119b93b9e2ee6f3">NS_LIST_DEFINE</a>(my_list, example_entry_t, link);</div>
<div class="ttc" id="ans__list_8h_html_a3ee74fb3290b4feae119b93b9e2ee6f3"><div class="ttname"><a href="#a3ee74fb3290b4feae119b93b9e2ee6f3">NS_LIST_DEFINE</a></div><div class="ttdeci">#define NS_LIST_DEFINE(name, type, field)</div><div class="ttdoc">Define a list, and initialise to empty.</div><div class="ttdef"><b>Definition</b> ns_list.h:352</div></div>
</div><!-- fragment --><p> OR </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_define" href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a>(example_entry_t, link) example_list_t;</div>
<div class="line">example_list_t <a class="code hl_define" href="#a3a6aac5e1c6351a054e1efbb3755c018">NS_LIST_NAME_INIT</a>(my_list);</div>
<div class="ttc" id="ans__list_8h_html_a3a6aac5e1c6351a054e1efbb3755c018"><div class="ttname"><a href="#a3a6aac5e1c6351a054e1efbb3755c018">NS_LIST_NAME_INIT</a></div><div class="ttdeci">#define NS_LIST_NAME_INIT(name)</div><div class="ttdoc">Name and initialiser for an empty list.</div><div class="ttdef"><b>Definition</b> ns_list.h:339</div></div>
</div><!-- fragment --><p> NOTE: the link field SHALL NOT be accessed by the user.</p>
<p>An entry can exist on multiple lists by having multiple link fields.</p>
<p>All the list operations are implemented as macros, most of which are backed by optionally-inline functions. The macros do not evaluate any arguments more than once, unless documented.</p>
<p>In macro documentation, <code>list_t</code> refers to a list type defined using <a class="el" href="#ad9c12dc26147f44613348d00e085f1c0" title="Declare a list head type.">NS_LIST_HEAD()</a>, and <code><a class="el" href="structentry__t.html">entry_t</a></code> to the entry type that was passed to it. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a45dc57e411a5a481207ca20e8e97dbf2" name="a45dc57e411a5a481207ca20e8e97dbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dc57e411a5a481207ca20e8e97dbf2">&#9670;&#160;</a></span>ns_list_add_after</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_add_after</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>after</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an entry after a specified entry. </p>
<p><a class="el" href="#a03c2a2e529663df19e76ffbf4f21cfe1" title="Add an entry before a specified entry.">ns_list_add_before()</a> is <em>slightly</em> more efficient than <a class="el" href="#a45dc57e411a5a481207ca20e8e97dbf2" title="Add an entry after a specified entry.">ns_list_add_after()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(list_t *)</code> Pointer to list. </td></tr>
    <tr><td class="paramname">after</td><td><code>(<a class="el" href="structentry__t.html">entry_t</a> *)</code> Existing entry after which to place the new entry. </td></tr>
    <tr><td class="paramname">entry</td><td><code>(<a class="el" href="structentry__t.html">entry_t</a> * restrict)</code> Pointer to new entry to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03c2a2e529663df19e76ffbf4f21cfe1" name="a03c2a2e529663df19e76ffbf4f21cfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c2a2e529663df19e76ffbf4f21cfe1">&#9670;&#160;</a></span>ns_list_add_before</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_add_before</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>before</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an entry before a specified entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(list_t *)</code> Pointer to list. </td></tr>
    <tr><td class="paramname">before</td><td><code>(<a class="el" href="structentry__t.html">entry_t</a> *)</code> Existing entry before which to place the new entry. </td></tr>
    <tr><td class="paramname">entry</td><td><code>(<a class="el" href="structentry__t.html">entry_t</a> * restrict)</code> Pointer to new entry to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f52b7db0e2728665a020676c67c7c49" name="a9f52b7db0e2728665a020676c67c7c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f52b7db0e2728665a020676c67c7c49">&#9670;&#160;</a></span>ns_list_add_to_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_add_to_end</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an entry to the end of the linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(list_t *)</code> Pointer to list. </td></tr>
    <tr><td class="paramname">entry</td><td><code>(<a class="el" href="structentry__t.html">entry_t</a> * restrict)</code> Pointer to new entry to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada8ed122e6b063bdf17eea5e4cfd5702" name="ada8ed122e6b063bdf17eea5e4cfd5702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8ed122e6b063bdf17eea5e4cfd5702">&#9670;&#160;</a></span>ns_list_add_to_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_add_to_start</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an entry to the start of the linked list. </p>
<p><a class="el" href="#a9f52b7db0e2728665a020676c67c7c49" title="Add an entry to the end of the linked list.">ns_list_add_to_end()</a> is <em>slightly</em> more efficient than <a class="el" href="#ada8ed122e6b063bdf17eea5e4cfd5702" title="Add an entry to the start of the linked list.">ns_list_add_to_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(list_t *)</code> Pointer to list. </td></tr>
    <tr><td class="paramname">entry</td><td><code>(<a class="el" href="structentry__t.html">entry_t</a> * restrict)</code> Pointer to new entry to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab312c3f74e9564c607f868dbd624c7e5" name="ab312c3f74e9564c607f868dbd624c7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab312c3f74e9564c607f868dbd624c7e5">&#9670;&#160;</a></span>ns_list_concatenate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_concatenate</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two lists. </p>
<p>Attach the entries on the source list to the end of the destination list, leaving the source list empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td><code>(list_t *)</code> Pointer to destination list. </td></tr>
    <tr><td class="paramname">src</td><td><code>(list_t *)</code> Pointer to source list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8031f2276076f960ba418b6e35cd8eb0" name="a8031f2276076f960ba418b6e35cd8eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8031f2276076f960ba418b6e35cd8eb0">&#9670;&#160;</a></span>ns_list_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_count</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count entries on a list. </p>
<p>Unlike other operations, this is O(n). Note: if list might contain over 65535 entries, this function <b>must not</b> be used to get the entry count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(const list_t *)</code> Pointer to list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(uint_fast16_t)</code> Number of entries that are stored in list. </dd></dl>

</div>
</div>
<a id="a3ee74fb3290b4feae119b93b9e2ee6f3" name="a3ee74fb3290b4feae119b93b9e2ee6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee74fb3290b4feae119b93b9e2ee6f3">&#9670;&#160;</a></span>NS_LIST_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_DEFINE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>field</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a>(type, field) <a class="code hl_define" href="#a3a6aac5e1c6351a054e1efbb3755c018">NS_LIST_NAME_INIT</a>(name)</div>
</div><!-- fragment -->
<p>Define a list, and initialise to empty. </p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_define" href="#a3ee74fb3290b4feae119b93b9e2ee6f3">NS_LIST_DEFINE</a>(my_list, <a class="code hl_struct" href="structentry__t.html">entry_t</a>, link);</div>
<div class="ttc" id="astructentry__t_html"><div class="ttname"><a href="structentry__t.html">entry_t</a></div><div class="ttdef"><b>Definition</b> listtest.cpp:37</div></div>
</div><!-- fragment --><p> acts as </p><div class="fragment"><div class="line"><span class="keyword">static</span> list_type my_list = { empty <a class="code hl_struct" href="structlist.html">list</a> };</div>
<div class="ttc" id="astructlist_html"><div class="ttname"><a href="structlist.html">list</a></div><div class="ttdoc">Connected isochronous stream linked list.</div><div class="ttdef"><b>Definition</b> lctr_int_cis.h:307</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a432840529a6802a8ccf161b9d3f1a1a5" name="a432840529a6802a8ccf161b9d3f1a1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432840529a6802a8ccf161b9d3f1a1a5">&#9670;&#160;</a></span>NS_LIST_ENTRY_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_ENTRY_</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>linkptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<span class="keywordtype">void</span> *)((<span class="keywordtype">char</span> *)(linkptr) - offset))</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3e5929bdd69350959bbdc6055f0bf7a" name="aa3e5929bdd69350959bbdc6055f0bf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e5929bdd69350959bbdc6055f0bf7a">&#9670;&#160;</a></span>ns_list_foreach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_foreach</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (type *e = <a class="code hl_define" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type *, <a class="code hl_define" href="#a518119c9408bb8df6256384ad799dcf8">ns_list_get_first</a>(<a class="code hl_struct" href="structlist.html">list</a>)); \</div>
<div class="line">        e; e = <a class="code hl_define" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type *, <a class="code hl_define" href="#afea3b17bdff37015a5173a1bbd63056e">ns_list_get_next</a>(<a class="code hl_struct" href="structlist.html">list</a>, e)))</div>
<div class="ttc" id="ans__list_8h_html_a518119c9408bb8df6256384ad799dcf8"><div class="ttname"><a href="#a518119c9408bb8df6256384ad799dcf8">ns_list_get_first</a></div><div class="ttdeci">#define ns_list_get_first(list)</div><div class="ttdoc">Get the first entry.</div><div class="ttdef"><b>Definition</b> ns_list.h:408</div></div>
<div class="ttc" id="ans__list_8h_html_a8a3f7205b5047586cc183ed47795218c"><div class="ttname"><a href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a></div><div class="ttdeci">#define NS_LIST_TYPECOERCE(type, val)</div><div class="ttdoc">Macro to force correct type if necessary.</div><div class="ttdef"><b>Definition</b> ns_list.h:232</div></div>
<div class="ttc" id="ans__list_8h_html_afea3b17bdff37015a5173a1bbd63056e"><div class="ttname"><a href="#afea3b17bdff37015a5173a1bbd63056e">ns_list_get_next</a></div><div class="ttdeci">#define ns_list_get_next(list, current)</div><div class="ttdoc">Get the next entry.</div><div class="ttdef"><b>Definition</b> ns_list.h:429</div></div>
</div><!-- fragment -->
<p>Iterate forwards over a list. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_define" href="#aa3e5929bdd69350959bbdc6055f0bf7a">ns_list_foreach</a>(<span class="keyword">const</span> my_entry_t, cur, &amp;my_list)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, cur-&gt;name);</div>
<div class="line">}</div>
<div class="ttc" id="ans__list_8h_html_aa3e5929bdd69350959bbdc6055f0bf7a"><div class="ttname"><a href="#aa3e5929bdd69350959bbdc6055f0bf7a">ns_list_foreach</a></div><div class="ttdeci">#define ns_list_foreach(type, e, list)</div><div class="ttdoc">Iterate forwards over a list.</div><div class="ttdef"><b>Definition</b> ns_list.h:517</div></div>
</div><!-- fragment --><p> Deletion of the current entry is not permitted as its next is checked after running user code.</p>
<p>The iteration pointer is declared inside the loop, using C99/C++, so it is not accessible after the loop. This encourages good code style, and matches the semantics of C++11's "ranged for", which only provides the declaration form: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> my_entry_t cur : my_list)</div>
</div><!-- fragment --><p> If you need to see the value of the iteration pointer after a <code>break</code>, you will need to assign it to a variable declared outside the loop before breaking: </p><div class="fragment"><div class="line">my_entry_t *match = NULL;</div>
<div class="line"><a class="code hl_define" href="#aa3e5929bdd69350959bbdc6055f0bf7a">ns_list_foreach</a>(my_entry_t, cur, &amp;my_list)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (cur-&gt;id == <span class="keywordtype">id</span>)</div>
<div class="line">    {</div>
<div class="line">        match = cur;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The user has to specify the entry type for the pointer definition, as type extraction from the list argument isn't portable. On the other hand, this also permits const qualifiers, as in the example above, and serves as documentation. The entry type will be checked against the list type where the compiler supports it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Entry type <code>([const] <a class="el" href="structentry__t.html">entry_t</a>)</code>. </td></tr>
    <tr><td class="paramname">e</td><td>Name for iteration pointer to be defined inside the loop. </td></tr>
    <tr><td class="paramname">list</td><td><code>(const list_t *)</code> Pointer to list - evaluated multiple times. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7478c8c2d27a660e4483a97199a27b06" name="a7478c8c2d27a660e4483a97199a27b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7478c8c2d27a660e4483a97199a27b06">&#9670;&#160;</a></span>ns_list_foreach_reverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_foreach_reverse</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (type *e = <a class="code hl_define" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type *, <a class="code hl_define" href="#a7f494e483d6455593dff2e34fdc00b0c">ns_list_get_last</a>(<a class="code hl_struct" href="structlist.html">list</a>)); \</div>
<div class="line">        e; e = <a class="code hl_define" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type *, <a class="code hl_define" href="#a9a9ddc7f8c72ca5747dbaf60340deed5">ns_list_get_previous</a>(<a class="code hl_struct" href="structlist.html">list</a>, e)))</div>
<div class="ttc" id="ans__list_8h_html_a7f494e483d6455593dff2e34fdc00b0c"><div class="ttname"><a href="#a7f494e483d6455593dff2e34fdc00b0c">ns_list_get_last</a></div><div class="ttdeci">#define ns_list_get_last(list)</div><div class="ttdoc">Get the last entry.</div><div class="ttdef"><b>Definition</b> ns_list.h:439</div></div>
<div class="ttc" id="ans__list_8h_html_a9a9ddc7f8c72ca5747dbaf60340deed5"><div class="ttname"><a href="#a9a9ddc7f8c72ca5747dbaf60340deed5">ns_list_get_previous</a></div><div class="ttdeci">#define ns_list_get_previous(list, current)</div><div class="ttdoc">Get the previous entry.</div><div class="ttdef"><b>Definition</b> ns_list.h:418</div></div>
</div><!-- fragment -->
<p>Iterate backwards over a list. </p>
<p>As <a class="el" href="#aa3e5929bdd69350959bbdc6055f0bf7a" title="Iterate forwards over a list.">ns_list_foreach()</a>, but going backwards - see its documentation. Iterating forwards is <em>slightly</em> more efficient. </p>

</div>
</div>
<a id="a63b3e7f9459bb3ca93c42c482a8fa877" name="a63b3e7f9459bb3ca93c42c482a8fa877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b3e7f9459bb3ca93c42c482a8fa877">&#9670;&#160;</a></span>ns_list_foreach_reverse_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_foreach_reverse_safe</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (type *e = <a class="code hl_define" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type *, <a class="code hl_define" href="#a7f494e483d6455593dff2e34fdc00b0c">ns_list_get_last</a>(<a class="code hl_struct" href="structlist.html">list</a>)), *_next##e; \</div>
<div class="line">        e &amp;&amp; (_next##e = <a class="code hl_define" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type *, <a class="code hl_define" href="#a9a9ddc7f8c72ca5747dbaf60340deed5">ns_list_get_previous</a>(<a class="code hl_struct" href="structlist.html">list</a>, e)), <span class="keyword">true</span>); e = _next##e)</div>
</div><!-- fragment -->
<p>Iterate backwards over a list, where user may delete. </p>
<p>As <a class="el" href="#af15ee8e11ba10676b3414d9c238d1358" title="Iterate forwards over a list, where user may delete.">ns_list_foreach_safe()</a>, but going backwards - see its documentation. Iterating forwards is <em>slightly</em> more efficient. </p>

</div>
</div>
<a id="af15ee8e11ba10676b3414d9c238d1358" name="af15ee8e11ba10676b3414d9c238d1358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15ee8e11ba10676b3414d9c238d1358">&#9670;&#160;</a></span>ns_list_foreach_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_foreach_safe</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (type *e = <a class="code hl_define" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type *, <a class="code hl_define" href="#a518119c9408bb8df6256384ad799dcf8">ns_list_get_first</a>(<a class="code hl_struct" href="structlist.html">list</a>)), *_next##e; \</div>
<div class="line">        e &amp;&amp; (_next##e = <a class="code hl_define" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type *, <a class="code hl_define" href="#afea3b17bdff37015a5173a1bbd63056e">ns_list_get_next</a>(<a class="code hl_struct" href="structlist.html">list</a>, e)), <span class="keyword">true</span>); e = _next##e)</div>
</div><!-- fragment -->
<p>Iterate forwards over a list, where user may delete. </p>
<p>As <a class="el" href="#aa3e5929bdd69350959bbdc6055f0bf7a" title="Iterate forwards over a list.">ns_list_foreach()</a>, but deletion of current entry is permitted as its next pointer is recorded before running user code.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_define" href="#af15ee8e11ba10676b3414d9c238d1358">ns_list_foreach_safe</a>(my_entry_t, cur, &amp;my_list)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_define" href="#a5db6f03e1481a09ab4ccdd9e587b2f9a">ns_list_remove</a>(cur);</div>
<div class="line">}</div>
<div class="ttc" id="ans__list_8h_html_a5db6f03e1481a09ab4ccdd9e587b2f9a"><div class="ttname"><a href="#a5db6f03e1481a09ab4ccdd9e587b2f9a">ns_list_remove</a></div><div class="ttdeci">#define ns_list_remove(list, entry)</div><div class="ttdoc">Remove an entry.</div><div class="ttdef"><b>Definition</b> ns_list.h:447</div></div>
<div class="ttc" id="ans__list_8h_html_af15ee8e11ba10676b3414d9c238d1358"><div class="ttname"><a href="#af15ee8e11ba10676b3414d9c238d1358">ns_list_foreach_safe</a></div><div class="ttdeci">#define ns_list_foreach_safe(type, e, list)</div><div class="ttdoc">Iterate forwards over a list, where user may delete.</div><div class="ttdef"><b>Definition</b> ns_list.h:538</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Entry type <code>(<a class="el" href="structentry__t.html">entry_t</a>)</code>. </td></tr>
    <tr><td class="paramname">e</td><td>Name for iteration pointer to be defined inside the loop. </td></tr>
    <tr><td class="paramname">list</td><td><code>(list_t *)</code> Pointer to list - evaluated multiple times. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a518119c9408bb8df6256384ad799dcf8" name="a518119c9408bb8df6256384ad799dcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518119c9408bb8df6256384ad799dcf8">&#9670;&#160;</a></span>ns_list_get_first</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_get_first</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#a8aec9d3c2d9052b96186ab9862adeefc">NS_LIST_TYPECAST_</a>(<a class="code hl_struct" href="structlist.html">list</a>, (<a class="code hl_struct" href="structlist.html">list</a>)-&gt;slist.first_entry)</div>
<div class="ttc" id="ans__list_8h_html_a8aec9d3c2d9052b96186ab9862adeefc"><div class="ttname"><a href="#a8aec9d3c2d9052b96186ab9862adeefc">NS_LIST_TYPECAST_</a></div><div class="ttdeci">#define NS_LIST_TYPECAST_(list, val)</div><div class="ttdoc">Internal macro to cast returned entry pointers to correct type.</div><div class="ttdef"><b>Definition</b> ns_list.h:213</div></div>
</div><!-- fragment -->
<p>Get the first entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(const list_t *)</code> Pointer to list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="structentry__t.html">entry_t</a> *)</code> Pointer to first entry. </dd>
<dd>
NULL if list is empty. </dd></dl>

</div>
</div>
<a id="a7f494e483d6455593dff2e34fdc00b0c" name="a7f494e483d6455593dff2e34fdc00b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f494e483d6455593dff2e34fdc00b0c">&#9670;&#160;</a></span>ns_list_get_last</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_get_last</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(const list_t *)</code> Pointer to list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="structentry__t.html">entry_t</a> *)</code> Pointer to last entry. </dd>
<dd>
NULL if list is empty. </dd></dl>

</div>
</div>
<a id="afea3b17bdff37015a5173a1bbd63056e" name="afea3b17bdff37015a5173a1bbd63056e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea3b17bdff37015a5173a1bbd63056e">&#9670;&#160;</a></span>ns_list_get_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_get_next</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>current</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(const list_t *)</code> Pointer to list. </td></tr>
    <tr><td class="paramname">current</td><td><code>(const <a class="el" href="structentry__t.html">entry_t</a> *)</code> Pointer to current entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="structentry__t.html">entry_t</a> *)</code> Pointer to next entry. </dd>
<dd>
NULL if current entry is last. </dd></dl>

</div>
</div>
<a id="a9a9ddc7f8c72ca5747dbaf60340deed5" name="a9a9ddc7f8c72ca5747dbaf60340deed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9ddc7f8c72ca5747dbaf60340deed5">&#9670;&#160;</a></span>ns_list_get_previous</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_get_previous</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>current</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the previous entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(const list_t *)</code> Pointer to list. </td></tr>
    <tr><td class="paramname">current</td><td><code>(const <a class="el" href="structentry__t.html">entry_t</a> *)</code> Pointer to current entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="structentry__t.html">entry_t</a> *)</code> Pointer to previous entry. </dd>
<dd>
NULL if current entry is first. </dd></dl>

</div>
</div>
<a id="ad9c12dc26147f44613348d00e085f1c0" name="ad9c12dc26147f44613348d00e085f1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c12dc26147f44613348d00e085f1c0">&#9670;&#160;</a></span>NS_LIST_HEAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_HEAD</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>field</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#ab66032ceb6767d11b5f237034e3431f1">NS_LIST_HEAD_BY_OFFSET_</a>(entry_type, offsetof(entry_type, field))</div>
<div class="ttc" id="ans__list_8h_html_ab66032ceb6767d11b5f237034e3431f1"><div class="ttname"><a href="#ab66032ceb6767d11b5f237034e3431f1">NS_LIST_HEAD_BY_OFFSET_</a></div><div class="ttdeci">#define NS_LIST_HEAD_BY_OFFSET_(entry_type, link_offset)</div><div class="ttdoc">Internal macro defining a list head, given the offset to the link pointer The +1 allows for link_offs...</div><div class="ttdef"><b>Definition</b> ns_list.h:157</div></div>
</div><!-- fragment -->
<p>Declare a list head type. </p>
<p>This union stores the real list head, and also encodes as compile-time type information the offset of the link pointer, and the type of the entry.</p>
<p>Note that type information is compiler-dependent; this means <a class="el" href="#a518119c9408bb8df6256384ad799dcf8" title="Get the first entry.">ns_list_get_first()</a> could return either <code>void *</code>, or a pointer to the actual entry type. So <code><a class="el" href="#a518119c9408bb8df6256384ad799dcf8" title="Get the first entry.">ns_list_get_first()</a>-&gt;data</code> is not a portable construct - always assign returned entry pointers to a properly typed pointer variable. This assignment will be then type-checked where the compiler supports it, and will dereference correctly on compilers that don't support this extension.</p>
<p>If you need to support C++03 compilers that cannot return properly-typed pointers, such as IAR 7, you need to use NS_LIST_TYPECOERCE to force the type. </p><div class="fragment"><div class="line"><a class="code hl_define" href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a>(example_entry_t, link) my_list;</div>
<div class="line"> </div>
<div class="line">example_entry_t *entry = <a class="code hl_define" href="#a518119c9408bb8df6256384ad799dcf8">ns_list_get_first</a>(&amp;my_list);</div>
<div class="line">do_something(entry-&gt;data);</div>
</div><!-- fragment --><p> Each use of this macro generates a new anonymous union, so these two lists have different types: </p><div class="fragment"><div class="line"><a class="code hl_define" href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a>(example_entry_t, link) my_list1;</div>
<div class="line"><a class="code hl_define" href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a>(example_entry_t, link) my_list2;</div>
</div><!-- fragment --><p> If you need to use a list type in multiple places, eg as a function parameter, use typedef: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_define" href="#ad9c12dc26147f44613348d00e085f1c0">NS_LIST_HEAD</a>(example_entry_t, link) example_list_t;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> example_function(example_list_t *);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab66032ceb6767d11b5f237034e3431f1" name="ab66032ceb6767d11b5f237034e3431f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66032ceb6767d11b5f237034e3431f1">&#9670;&#160;</a></span>NS_LIST_HEAD_BY_OFFSET_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_HEAD_BY_OFFSET_</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>link_offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">union </span>\</div>
<div class="line">{ \</div>
<div class="line">    <a class="code hl_typedef" href="#a43a0fb5da933ff2ff6a253a3e4922e81">ns_list_t</a> slist; \</div>
<div class="line">    NS_FUNNY_COMPARE_OK \</div>
<div class="line">    NS_STATIC_ASSERT(link_offset &lt;= (ns_list_offset_t) -1, <span class="stringliteral">&quot;link offset too large&quot;</span>) \</div>
<div class="line">    NS_FUNNY_COMPARE_RESTORE \</div>
<div class="line">    char (*offset)[link_offset + 1]; \</div>
<div class="line">    entry_type *type; \</div>
<div class="line">}</div>
<div class="ttc" id="ans__list_8h_html_a43a0fb5da933ff2ff6a253a3e4922e81"><div class="ttname"><a href="#a43a0fb5da933ff2ff6a253a3e4922e81">ns_list_t</a></div><div class="ttdeci">struct ns_list ns_list_t</div><div class="ttdoc">Underlying generic linked list head.</div></div>
</div><!-- fragment -->
<p>Internal macro defining a list head, given the offset to the link pointer The +1 allows for link_offset being 0 - we can't declare a 0-size array. </p>

</div>
</div>
<a id="a0eafe156a81b7776a93b8eddaa87e379" name="a0eafe156a81b7776a93b8eddaa87e379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eafe156a81b7776a93b8eddaa87e379">&#9670;&#160;</a></span>NS_LIST_HEAD_INCOMPLETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_HEAD_INCOMPLETE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#ab66032ceb6767d11b5f237034e3431f1">NS_LIST_HEAD_BY_OFFSET_</a>(entry_type, 0)</div>
</div><!-- fragment -->
<p>Declare a list head type for an incomplete entry type. </p>
<p>This declares a list head, similarly to <a class="el" href="#ad9c12dc26147f44613348d00e085f1c0" title="Declare a list head type.">NS_LIST_HEAD()</a>, but unlike that this can be used in contexts where the entry type may be incomplete.</p>
<p>To use this, the link pointer must be the first member in the actual complete structure. This is NOT checked - the definition of the element should probably test NS_STATIC_ASSERT(offsetof(type, link) == 0) if outside users are known to be using <a class="el" href="#a0eafe156a81b7776a93b8eddaa87e379" title="Declare a list head type for an incomplete entry type.">NS_LIST_HEAD_INCOMPLETE()</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>opaque;</div>
<div class="line"><a class="code hl_define" href="#a0eafe156a81b7776a93b8eddaa87e379">NS_LIST_HEAD_INCOMPLETE</a>(<span class="keyword">struct</span> opaque) opaque_list;</div>
<div class="ttc" id="ans__list_8h_html_a0eafe156a81b7776a93b8eddaa87e379"><div class="ttname"><a href="#a0eafe156a81b7776a93b8eddaa87e379">NS_LIST_HEAD_INCOMPLETE</a></div><div class="ttdeci">#define NS_LIST_HEAD_INCOMPLETE(entry_type)</div><div class="ttdoc">Declare a list head type for an incomplete entry type.</div><div class="ttdef"><b>Definition</b> ns_list.h:150</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a99f01ef1e1b0956a24306acae1871e86" name="a99f01ef1e1b0956a24306acae1871e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f01ef1e1b0956a24306acae1871e86">&#9670;&#160;</a></span>NS_LIST_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_INIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ { NULL, &amp;(name).slist.first_entry } }</div>
</div><!-- fragment -->
<p>Initialiser for an empty list. </p>
<p>Usage in an enclosing initialiser: </p><div class="fragment"><div class="line"><span class="keyword">static</span> my_type_including_list_t x = {</div>
<div class="line">    <span class="stringliteral">&quot;Something&quot;</span>,</div>
<div class="line">    23,</div>
<div class="line">    <a class="code hl_define" href="#a99f01ef1e1b0956a24306acae1871e86">NS_LIST_INIT</a>(x),</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="#a3ee74fb3290b4feae119b93b9e2ee6f3" title="Define a list, and initialise to empty.">NS_LIST_DEFINE()</a> or <a class="el" href="#a3a6aac5e1c6351a054e1efbb3755c018" title="Name and initialiser for an empty list.">NS_LIST_NAME_INIT()</a> may provide a shorter alternative in simpler cases. </p>

</div>
</div>
<a id="ab9167109e82b674cc5bcdbaae364002b" name="ab9167109e82b674cc5bcdbaae364002b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9167109e82b674cc5bcdbaae364002b">&#9670;&#160;</a></span>ns_list_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_init</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a list. </p>
<p>Initialise a list head before use. A list head must be initialised using this function or one of the <a class="el" href="#a99f01ef1e1b0956a24306acae1871e86" title="Initialiser for an empty list.">NS_LIST_INIT()</a>-type macros before use. A zero-initialised list head is <em>not</em> valid.</p>
<p>If used on a list containing existing entries, those entries will become detached. (They are not modified, but their links are now effectively undefined).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Pointer to a <a class="el" href="#ad9c12dc26147f44613348d00e085f1c0" title="Declare a list head type.">NS_LIST_HEAD()</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca327da5a63ae4a66b3269ce6d8e7290" name="aca327da5a63ae4a66b3269ce6d8e7290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca327da5a63ae4a66b3269ce6d8e7290">&#9670;&#160;</a></span>ns_list_is_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_is_empty</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((bool) ((<a class="code hl_struct" href="structlist.html">list</a>)-&gt;slist.first_entry == NULL))</div>
</div><!-- fragment -->
<p>Check if a list is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(const list_t *)</code> Pointer to list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(bool)</code> true if the list is empty. </dd></dl>

</div>
</div>
<a id="a0f41fb9c20f728befdb2608551820955" name="a0f41fb9c20f728befdb2608551820955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f41fb9c20f728befdb2608551820955">&#9670;&#160;</a></span>NS_LIST_LINK_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_LINK_</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code hl_typedef" href="#a1e3177affad7a5581521d5732e58c908">ns_list_link_t</a> *)((<span class="keywordtype">char</span> *)(e) + offset))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a117c63fb93d96acc8f47c5dcdb343fe3" name="a117c63fb93d96acc8f47c5dcdb343fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117c63fb93d96acc8f47c5dcdb343fe3">&#9670;&#160;</a></span>NS_LIST_LINK_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_LINK_INIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="ns__types_8h.html#aa819a25b0a9c0a4c2782827841cbf235">NS_FUNNY_INTPTR_OK</a> \</div>
<div class="line">    { <a class="code hl_define" href="#ab88ac510e4c61c91d733fe946852949a">NS_LIST_POISON</a>, <a class="code hl_define" href="#ab88ac510e4c61c91d733fe946852949a">NS_LIST_POISON</a> } \</div>
<div class="line">    NS_FUNNY_INTPTR_RESTORE</div>
<div class="ttc" id="ans__list_8h_html_ab88ac510e4c61c91d733fe946852949a"><div class="ttname"><a href="#ab88ac510e4c61c91d733fe946852949a">NS_LIST_POISON</a></div><div class="ttdeci">#define NS_LIST_POISON</div><div class="ttdoc">&quot;Poison&quot; value placed in unattached entries&#39; link pointers.</div><div class="ttdef"><b>Definition</b> ns_list.h:266</div></div>
<div class="ttc" id="ans__types_8h_html_aa819a25b0a9c0a4c2782827841cbf235"><div class="ttname"><a href="ns__types_8h.html#aa819a25b0a9c0a4c2782827841cbf235">NS_FUNNY_INTPTR_OK</a></div><div class="ttdeci">#define NS_FUNNY_INTPTR_OK</div><div class="ttdoc">Pragma to suppress warnings about unusual pointer values.</div><div class="ttdef"><b>Definition</b> ns_types.h:251</div></div>
</div><!-- fragment -->
<p>Initialiser for an entry's link member. </p>
<p>This initialiser is not required by the library, but a user may want an initialiser to include in their own entry initialiser. See <a class="el" href="#a7d79a611e9be99dbd078fa2a465b5f6f" title="Initialise an entry&#39;s list link.">ns_list_link_init()</a> for more discussion. </p>

</div>
</div>
<a id="a7d79a611e9be99dbd078fa2a465b5f6f" name="a7d79a611e9be99dbd078fa2a465b5f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d79a611e9be99dbd078fa2a465b5f6f">&#9670;&#160;</a></span>ns_list_link_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_link_init</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>field</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an entry's list link. </p>
<p>This "initialises" an unattached entry's link by filling the fields with poison. This is optional, as unattached entries field pointers are not meaningful, and it is not valid to call ns_list_get_next or similar on an unattached entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>Pointer to an entry </td></tr>
    <tr><td class="paramname">field</td><td>The name of the link member to initialise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a6aac5e1c6351a054e1efbb3755c018" name="a3a6aac5e1c6351a054e1efbb3755c018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6aac5e1c6351a054e1efbb3755c018">&#9670;&#160;</a></span>NS_LIST_NAME_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_NAME_INIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">name = <a class="code hl_define" href="#a99f01ef1e1b0956a24306acae1871e86">NS_LIST_INIT</a>(name)</div>
</div><!-- fragment -->
<p>Name and initialiser for an empty list. </p>
<p>Usage: </p><div class="fragment"><div class="line">list_t <a class="code hl_define" href="#a3a6aac5e1c6351a054e1efbb3755c018">NS_LIST_NAME_INIT</a>(foo);</div>
</div><!-- fragment --><p> acts as </p><div class="fragment"><div class="line">list_t foo = { empty <a class="code hl_struct" href="structlist.html">list</a> };</div>
</div><!-- fragment --><p> Also useful with designated initialisers: </p><div class="fragment"><div class="line">.NS_LIST_NAME_INIT(foo),</div>
</div><!-- fragment --><p> acts as </p><div class="fragment"><div class="line">.foo = { empty <a class="code hl_struct" href="structlist.html">list</a> },</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8d3e117cbb6255a74e46d3f528975643" name="a8d3e117cbb6255a74e46d3f528975643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3e117cbb6255a74e46d3f528975643">&#9670;&#160;</a></span>NS_LIST_NEXT_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_NEXT_</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(NS_LIST_LINK_(e, offset)-&gt;next)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a48a22ca0f67693acc53600c30ef70402" name="a48a22ca0f67693acc53600c30ef70402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a22ca0f67693acc53600c30ef70402">&#9670;&#160;</a></span>NS_LIST_OFFSET_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_OFFSET_</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((ns_list_offset_t) (<span class="keyword">sizeof</span> *(<a class="code hl_struct" href="structlist.html">list</a>)-&gt;offset - 1))</div>
</div><!-- fragment -->
<p>Get offset of link field in entry. </p>
<dl class="section return"><dt>Returns</dt><dd><code>(ns_list_offset_t)</code> The offset of the link field for entries on the specified list </dd></dl>

</div>
</div>
<a id="a2098ff73b29c1c34d110bd71af7d09e6" name="a2098ff73b29c1c34d110bd71af7d09e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2098ff73b29c1c34d110bd71af7d09e6">&#9670;&#160;</a></span>NS_LIST_PREV_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_PREV_</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(NS_LIST_LINK_(e, offset)-&gt;prev)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5db6f03e1481a09ab4ccdd9e587b2f9a" name="a5db6f03e1481a09ab4ccdd9e587b2f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db6f03e1481a09ab4ccdd9e587b2f9a">&#9670;&#160;</a></span>ns_list_remove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_remove</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(list_t *)</code> Pointer to list. </td></tr>
    <tr><td class="paramname">entry</td><td><code>(<a class="el" href="structentry__t.html">entry_t</a> *)</code> Entry on list to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f44eda3d999d1efbe95a3ee88e90b76" name="a3f44eda3d999d1efbe95a3ee88e90b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f44eda3d999d1efbe95a3ee88e90b76">&#9670;&#160;</a></span>ns_list_replace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ns_list_replace</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>current</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><code>(list_t *)</code> Pointer to list. </td></tr>
    <tr><td class="paramname">current</td><td><code>(<a class="el" href="structentry__t.html">entry_t</a> *)</code> Existing entry on list to be replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td><code>(<a class="el" href="structentry__t.html">entry_t</a> * restrict)</code> New entry to be the replacement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aec9d3c2d9052b96186ab9862adeefc" name="a8aec9d3c2d9052b96186ab9862adeefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aec9d3c2d9052b96186ab9862adeefc">&#9670;&#160;</a></span>NS_LIST_TYPECAST_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_TYPECAST_</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(0 ? (<a class="code hl_struct" href="structlist.html">list</a>)-&gt;type : (val))</div>
</div><!-- fragment -->
<p>Internal macro to cast returned entry pointers to correct type. </p>
<p>Not portable in C, alas. With GCC or C++11, the "get entry" macros return correctly-typed pointers. Otherwise, the macros return <code>void *</code>.</p>
<p>The attempt at a portable version would work if the C <code>?:</code> operator wasn't broken - <code>x ? (t *) : (void *)</code> should really have type <code>(t *)</code> in C, but it has type <code>(void *)</code>, which only makes sense for C++. The <code>?:</code> is left in, in case some day it works. Some compilers may still warn if this is assigned to a different type. </p>

</div>
</div>
<a id="a74425da7c993fb9b99198cbc49b6ca88" name="a74425da7c993fb9b99198cbc49b6ca88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74425da7c993fb9b99198cbc49b6ca88">&#9670;&#160;</a></span>NS_LIST_TYPECHECK_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_TYPECHECK_</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="structlist.html">list</a></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="#a5b0e3ac9ee881e9bbf614dea56ad80ac">NS_PTR_MATCH_</a>((<a class="code hl_struct" href="structlist.html">list</a>)-&gt;type, (entry), <span class="stringliteral">&quot;incorrect entry type for list&quot;</span>), (entry))</div>
<div class="ttc" id="ans__list_8h_html_a5b0e3ac9ee881e9bbf614dea56ad80ac"><div class="ttname"><a href="#a5b0e3ac9ee881e9bbf614dea56ad80ac">NS_PTR_MATCH_</a></div><div class="ttdeci">#define NS_PTR_MATCH_(a, b, str)</div><div class="ttdoc">Check for compatible pointer types.</div><div class="ttdef"><b>Definition</b> ns_list.h:196</div></div>
</div><!-- fragment -->
<p>Internal macro to check types of input entry pointer. </p>

</div>
</div>
<a id="a8a3f7205b5047586cc183ed47795218c" name="a8a3f7205b5047586cc183ed47795218c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3f7205b5047586cc183ed47795218c">&#9670;&#160;</a></span>NS_LIST_TYPECOERCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_LIST_TYPECOERCE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(val)</div>
</div><!-- fragment -->
<p>Macro to force correct type if necessary. </p>
<p>In C, doesn't matter if NS_LIST_TYPECAST_ works or not, as it's legal to assign void * to a pointer. In C++, we can't do that, so need a back-up plan for C++03. This forces the type, so breaks type-safety - only activate when needed, meaning we still get typechecks on other toolchains.</p>
<p>If a straight assignment of a <a class="el" href="structns__list.html" title="Underlying generic linked list head.">ns_list</a> function to a pointer fails on a C++03 compiler, use the following construct. This will not be required with C++11 compilers. </p><div class="fragment"><div class="line">type *elem = <a class="code hl_define" href="#a8a3f7205b5047586cc183ed47795218c">NS_LIST_TYPECOERCE</a>(type *, <a class="code hl_define" href="#a518119c9408bb8df6256384ad799dcf8">ns_list_get_first</a>(<a class="code hl_struct" href="structlist.html">list</a>));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5b0e3ac9ee881e9bbf614dea56ad80ac" name="a5b0e3ac9ee881e9bbf614dea56ad80ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0e3ac9ee881e9bbf614dea56ad80ac">&#9670;&#160;</a></span>NS_PTR_MATCH_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NS_PTR_MATCH_</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((void) <span class="keyword">sizeof</span> ((a) == (b)))</div>
</div><!-- fragment -->
<p>Check for compatible pointer types. </p>
<p>This test will produce a diagnostic about a pointer mismatch on the == inside the sizeof operator. For example ARM/Norcroft C gives the error: </p><pre class="fragment">operand types are incompatible ("entry_t *" and "other_t *")
</pre> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1e3177affad7a5581521d5732e58c908" name="a1e3177affad7a5581521d5732e58c908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3177affad7a5581521d5732e58c908">&#9670;&#160;</a></span>ns_list_link_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structns__list__link.html">ns_list_link</a> <a class="el" href="#a1e3177affad7a5581521d5732e58c908">ns_list_link_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type for the link member in the user's entry structure. </p>
<p>Users should not access this member directly - just pass its name to the list head macros. The funny prev pointer simplifies common operations (eg insertion, removal), at the expense of complicating rare reverse iteration.</p>
<p>NB - the list implementation relies on next being the first member. </p>

</div>
</div>
<a id="a43a0fb5da933ff2ff6a253a3e4922e81" name="a43a0fb5da933ff2ff6a253a3e4922e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a0fb5da933ff2ff6a253a3e4922e81">&#9670;&#160;</a></span>ns_list_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structns__list.html">ns_list</a> <a class="el" href="#a43a0fb5da933ff2ff6a253a3e4922e81">ns_list_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Underlying generic linked list head. </p>
<p>Users should not use this type directly, but use the <a class="el" href="#ad9c12dc26147f44613348d00e085f1c0" title="Declare a list head type.">NS_LIST_HEAD()</a> macro. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5fdebfbd0a4b5643a5e85bf3c8b1558b.html">mbed-os</a></li><li class="navelem"><a class="el" href="dir_456207283565120b441ff9733579e7b8.html">connectivity</a></li><li class="navelem"><a class="el" href="dir_9a297b342377d9e739c11e99c248e04e.html">libraries</a></li><li class="navelem"><a class="el" href="dir_e2d6ac2c64c809a090d428edd50341ba.html">nanostack-libservice</a></li><li class="navelem"><a class="el" href="dir_1f4e1c4b03af8a0c108ca263a8bc1e48.html">mbed-client-libservice</a></li><li class="navelem"><a class="el" href="ns__list_8h.html">ns_list.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
