<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: /home/zoe/Mbed Programs/esp_code/mbed-os/platform/FEATURE_EXPERIMENTAL_API/FEATURE_PSA/TARGET_MBED_PSA_SRV/services/attestation/qcbor/inc/qcbor.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('qcbor_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">qcbor.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="UsefulBuf_8h_source.html">UsefulBuf.h</a>&quot;</code><br />
</div>
<p><a href="qcbor_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____QCBORTrackNesting.html">__QCBORTrackNesting</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__QCBOREncodeContext.html">_QCBOREncodeContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____QCBORDecodeNesting.html">__QCBORDecodeNesting</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__QCBORDecodeContext.html">_QCBORDecodeContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__QCBORItem.html">_QCBORItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structQCBORStringAllocator.html">QCBORStringAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structQCBORTagListIn.html">QCBORTagListIn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structQCBORTagListOut.html">QCBORTagListOut</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a64ac055dbdc50a087402de17816a557b" id="r_a64ac055dbdc50a087402de17816a557b"><td class="memItemLeft" align="right" valign="top"><a id="a64ac055dbdc50a087402de17816a557b" name="a64ac055dbdc50a087402de17816a557b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QCBOR_MAX_ARRAY_NESTING1</b>&#160;&#160;&#160;15</td></tr>
<tr class="separator:a64ac055dbdc50a087402de17816a557b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28df2dcab99010210fcc0994f0c7344" id="r_ac28df2dcab99010210fcc0994f0c7344"><td class="memItemLeft" align="right" valign="top"><a id="ac28df2dcab99010210fcc0994f0c7344" name="ac28df2dcab99010210fcc0994f0c7344"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QCBOR_MAX_ARRAY_OFFSET</b>&#160;&#160;&#160;(UINT32_MAX - 100)</td></tr>
<tr class="separator:ac28df2dcab99010210fcc0994f0c7344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8a0e2ce85d8dfab20a4af538b8235d" id="r_a1e8a0e2ce85d8dfab20a4af538b8235d"><td class="memItemLeft" align="right" valign="top"><a id="a1e8a0e2ce85d8dfab20a4af538b8235d" name="a1e8a0e2ce85d8dfab20a4af538b8235d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_NONE_TYPE_RAW</b>&#160;&#160;&#160;9</td></tr>
<tr class="separator:a1e8a0e2ce85d8dfab20a4af538b8235d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fc42e4aa9762640f51e50210a00432" id="r_a40fc42e4aa9762640f51e50210a00432"><td class="memItemLeft" align="right" valign="top"><a id="a40fc42e4aa9762640f51e50210a00432" name="a40fc42e4aa9762640f51e50210a00432"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_NONE_TAG_LABEL_REORDER</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a40fc42e4aa9762640f51e50210a00432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d6ec85051683a1a38f4cd04ec1ea87" id="r_ad3d6ec85051683a1a38f4cd04ec1ea87"><td class="memItemLeft" align="right" valign="top"><a id="ad3d6ec85051683a1a38f4cd04ec1ea87" name="ad3d6ec85051683a1a38f4cd04ec1ea87"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_TYPE_POSITIVE_INT</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ad3d6ec85051683a1a38f4cd04ec1ea87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61cc78b5ae2058b0185385e50de1822" id="r_ac61cc78b5ae2058b0185385e50de1822"><td class="memItemLeft" align="right" valign="top"><a id="ac61cc78b5ae2058b0185385e50de1822" name="ac61cc78b5ae2058b0185385e50de1822"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_TYPE_NEGATIVE_INT</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ac61cc78b5ae2058b0185385e50de1822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcc3c29187ac12ebb8fa687e588c017" id="r_aefcc3c29187ac12ebb8fa687e588c017"><td class="memItemLeft" align="right" valign="top"><a id="aefcc3c29187ac12ebb8fa687e588c017" name="aefcc3c29187ac12ebb8fa687e588c017"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_TYPE_BYTE_STRING</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aefcc3c29187ac12ebb8fa687e588c017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4880464e7e16c4e3389d2c0ec6bca97d" id="r_a4880464e7e16c4e3389d2c0ec6bca97d"><td class="memItemLeft" align="right" valign="top"><a id="a4880464e7e16c4e3389d2c0ec6bca97d" name="a4880464e7e16c4e3389d2c0ec6bca97d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_TYPE_TEXT_STRING</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a4880464e7e16c4e3389d2c0ec6bca97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec40799814a47bfe3bb40cbfaf107b9" id="r_abec40799814a47bfe3bb40cbfaf107b9"><td class="memItemLeft" align="right" valign="top"><a id="abec40799814a47bfe3bb40cbfaf107b9" name="abec40799814a47bfe3bb40cbfaf107b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_TYPE_ARRAY</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:abec40799814a47bfe3bb40cbfaf107b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6d383ee9870804764bb635292d0df5" id="r_a4f6d383ee9870804764bb635292d0df5"><td class="memItemLeft" align="right" valign="top"><a id="a4f6d383ee9870804764bb635292d0df5" name="a4f6d383ee9870804764bb635292d0df5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_TYPE_MAP</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a4f6d383ee9870804764bb635292d0df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d06922f2518ae370a2ad361984c35b6" id="r_a9d06922f2518ae370a2ad361984c35b6"><td class="memItemLeft" align="right" valign="top"><a id="a9d06922f2518ae370a2ad361984c35b6" name="a9d06922f2518ae370a2ad361984c35b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_TYPE_OPTIONAL</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a9d06922f2518ae370a2ad361984c35b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e92e4a09c97e2f9b005d31165f02e6b" id="r_a6e92e4a09c97e2f9b005d31165f02e6b"><td class="memItemLeft" align="right" valign="top"><a id="a6e92e4a09c97e2f9b005d31165f02e6b" name="a6e92e4a09c97e2f9b005d31165f02e6b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_MAJOR_TYPE_SIMPLE</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:a6e92e4a09c97e2f9b005d31165f02e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cae7d6aacd1efa907886ef843904aec" id="r_a3cae7d6aacd1efa907886ef843904aec"><td class="memItemLeft" align="right" valign="top"><a id="a3cae7d6aacd1efa907886ef843904aec" name="a3cae7d6aacd1efa907886ef843904aec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEN_IS_ONE_BYTE</b>&#160;&#160;&#160;24</td></tr>
<tr class="separator:a3cae7d6aacd1efa907886ef843904aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7fa60ba2c3a976e8e41e441f5cad8b" id="r_abc7fa60ba2c3a976e8e41e441f5cad8b"><td class="memItemLeft" align="right" valign="top"><a id="abc7fa60ba2c3a976e8e41e441f5cad8b" name="abc7fa60ba2c3a976e8e41e441f5cad8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEN_IS_TWO_BYTES</b>&#160;&#160;&#160;25</td></tr>
<tr class="separator:abc7fa60ba2c3a976e8e41e441f5cad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a47a6807405eb5bcb22097bca67c9b" id="r_ac9a47a6807405eb5bcb22097bca67c9b"><td class="memItemLeft" align="right" valign="top"><a id="ac9a47a6807405eb5bcb22097bca67c9b" name="ac9a47a6807405eb5bcb22097bca67c9b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEN_IS_FOUR_BYTES</b>&#160;&#160;&#160;26</td></tr>
<tr class="separator:ac9a47a6807405eb5bcb22097bca67c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057fa6ea84f8b853ee1045b0e0a969e0" id="r_a057fa6ea84f8b853ee1045b0e0a969e0"><td class="memItemLeft" align="right" valign="top"><a id="a057fa6ea84f8b853ee1045b0e0a969e0" name="a057fa6ea84f8b853ee1045b0e0a969e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEN_IS_EIGHT_BYTES</b>&#160;&#160;&#160;27</td></tr>
<tr class="separator:a057fa6ea84f8b853ee1045b0e0a969e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30971dae83dd81d8337e3751ac14ad0c" id="r_a30971dae83dd81d8337e3751ac14ad0c"><td class="memItemLeft" align="right" valign="top"><a id="a30971dae83dd81d8337e3751ac14ad0c" name="a30971dae83dd81d8337e3751ac14ad0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDINFO_RESERVED1</b>&#160;&#160;&#160;28</td></tr>
<tr class="separator:a30971dae83dd81d8337e3751ac14ad0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadff2f1fa085945a0d02de05fbf38eaa" id="r_aadff2f1fa085945a0d02de05fbf38eaa"><td class="memItemLeft" align="right" valign="top"><a id="aadff2f1fa085945a0d02de05fbf38eaa" name="aadff2f1fa085945a0d02de05fbf38eaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDINFO_RESERVED2</b>&#160;&#160;&#160;29</td></tr>
<tr class="separator:aadff2f1fa085945a0d02de05fbf38eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae113063012c1c8aba48f1562ad85bdea" id="r_ae113063012c1c8aba48f1562ad85bdea"><td class="memItemLeft" align="right" valign="top"><a id="ae113063012c1c8aba48f1562ad85bdea" name="ae113063012c1c8aba48f1562ad85bdea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDINFO_RESERVED3</b>&#160;&#160;&#160;30</td></tr>
<tr class="separator:ae113063012c1c8aba48f1562ad85bdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1034b82b31b5d4be152dd41a6fbbac" id="r_a6d1034b82b31b5d4be152dd41a6fbbac"><td class="memItemLeft" align="right" valign="top"><a id="a6d1034b82b31b5d4be152dd41a6fbbac" name="a6d1034b82b31b5d4be152dd41a6fbbac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEN_IS_INDEFINITE</b>&#160;&#160;&#160;31</td></tr>
<tr class="separator:a6d1034b82b31b5d4be152dd41a6fbbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae08159f37a8cc6a2ccace95580ae305" id="r_aae08159f37a8cc6a2ccace95580ae305"><td class="memItemLeft" align="right" valign="top"><a id="aae08159f37a8cc6a2ccace95580ae305" name="aae08159f37a8cc6a2ccace95580ae305"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TWENTY_FOUR</b>&#160;&#160;&#160;24</td></tr>
<tr class="separator:aae08159f37a8cc6a2ccace95580ae305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f01747fee8d393dd1bda112484ab040" id="r_a5f01747fee8d393dd1bda112484ab040"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f01747fee8d393dd1bda112484ab040">CBOR_TAG_DATE_STRING</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a5f01747fee8d393dd1bda112484ab040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dedcb07c8058893a67efe42f6740990" id="r_a7dedcb07c8058893a67efe42f6740990"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dedcb07c8058893a67efe42f6740990">CBOR_TAG_DATE_EPOCH</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a7dedcb07c8058893a67efe42f6740990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47367e57493f51fbf0253df494a17743" id="r_a47367e57493f51fbf0253df494a17743"><td class="memItemLeft" align="right" valign="top"><a id="a47367e57493f51fbf0253df494a17743" name="a47367e57493f51fbf0253df494a17743"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_POS_BIGNUM</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a47367e57493f51fbf0253df494a17743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35c30486c5c22bc76934951d106a19" id="r_acf35c30486c5c22bc76934951d106a19"><td class="memItemLeft" align="right" valign="top"><a id="acf35c30486c5c22bc76934951d106a19" name="acf35c30486c5c22bc76934951d106a19"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_NEG_BIGNUM</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:acf35c30486c5c22bc76934951d106a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178366916d8cba5ca397270dea4cc210" id="r_a178366916d8cba5ca397270dea4cc210"><td class="memItemLeft" align="right" valign="top"><a id="a178366916d8cba5ca397270dea4cc210" name="a178366916d8cba5ca397270dea4cc210"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_FRACTION</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a178366916d8cba5ca397270dea4cc210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60db63e43182f0da134488a738b78831" id="r_a60db63e43182f0da134488a738b78831"><td class="memItemLeft" align="right" valign="top"><a id="a60db63e43182f0da134488a738b78831" name="a60db63e43182f0da134488a738b78831"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_BIGFLOAT</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a60db63e43182f0da134488a738b78831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd472df086cea8862e652de562082bf8" id="r_afd472df086cea8862e652de562082bf8"><td class="memItemLeft" align="right" valign="top"><a id="afd472df086cea8862e652de562082bf8" name="afd472df086cea8862e652de562082bf8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_COSE_ENCRYPTO</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:afd472df086cea8862e652de562082bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82158ea87960392edbb9ffee3b66217f" id="r_a82158ea87960392edbb9ffee3b66217f"><td class="memItemLeft" align="right" valign="top"><a id="a82158ea87960392edbb9ffee3b66217f" name="a82158ea87960392edbb9ffee3b66217f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_COSE_MAC0</b>&#160;&#160;&#160;17</td></tr>
<tr class="separator:a82158ea87960392edbb9ffee3b66217f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f57c4e91f9928fdcfc2cb67d8afb837" id="r_a6f57c4e91f9928fdcfc2cb67d8afb837"><td class="memItemLeft" align="right" valign="top"><a id="a6f57c4e91f9928fdcfc2cb67d8afb837" name="a6f57c4e91f9928fdcfc2cb67d8afb837"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_COSE_SIGN1</b>&#160;&#160;&#160;18</td></tr>
<tr class="separator:a6f57c4e91f9928fdcfc2cb67d8afb837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2ebbfda6478b8a6f3b6fb4eb9aad35" id="r_a3f2ebbfda6478b8a6f3b6fb4eb9aad35"><td class="memItemLeft" align="right" valign="top"><a id="a3f2ebbfda6478b8a6f3b6fb4eb9aad35" name="a3f2ebbfda6478b8a6f3b6fb4eb9aad35"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_ENC_AS_B64URL</b>&#160;&#160;&#160;21</td></tr>
<tr class="separator:a3f2ebbfda6478b8a6f3b6fb4eb9aad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b2235940ebe74c314836a8b15a434a" id="r_a32b2235940ebe74c314836a8b15a434a"><td class="memItemLeft" align="right" valign="top"><a id="a32b2235940ebe74c314836a8b15a434a" name="a32b2235940ebe74c314836a8b15a434a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_ENC_AS_B64</b>&#160;&#160;&#160;22</td></tr>
<tr class="separator:a32b2235940ebe74c314836a8b15a434a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564140d87a0773a7a810f86af5118d6e" id="r_a564140d87a0773a7a810f86af5118d6e"><td class="memItemLeft" align="right" valign="top"><a id="a564140d87a0773a7a810f86af5118d6e" name="a564140d87a0773a7a810f86af5118d6e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_ENC_AS_B16</b>&#160;&#160;&#160;23</td></tr>
<tr class="separator:a564140d87a0773a7a810f86af5118d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0776aec29acb7c6d4581b0d092ab35" id="r_a0b0776aec29acb7c6d4581b0d092ab35"><td class="memItemLeft" align="right" valign="top"><a id="a0b0776aec29acb7c6d4581b0d092ab35" name="a0b0776aec29acb7c6d4581b0d092ab35"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_CBOR</b>&#160;&#160;&#160;24</td></tr>
<tr class="separator:a0b0776aec29acb7c6d4581b0d092ab35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae8a1164ab0a3341445582cfe81613f" id="r_a4ae8a1164ab0a3341445582cfe81613f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ae8a1164ab0a3341445582cfe81613f">CBOR_TAG_URI</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a4ae8a1164ab0a3341445582cfe81613f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531e2d609d863de2e6cd1287d42c0357" id="r_a531e2d609d863de2e6cd1287d42c0357"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a531e2d609d863de2e6cd1287d42c0357">CBOR_TAG_B64URL</a>&#160;&#160;&#160;33</td></tr>
<tr class="separator:a531e2d609d863de2e6cd1287d42c0357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fe584ddba0632aeda34609d4fabeed" id="r_a82fe584ddba0632aeda34609d4fabeed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82fe584ddba0632aeda34609d4fabeed">CBOR_TAG_B64</a>&#160;&#160;&#160;34</td></tr>
<tr class="separator:a82fe584ddba0632aeda34609d4fabeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa819563ea8b98c073c4533ef345eeef2" id="r_aa819563ea8b98c073c4533ef345eeef2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa819563ea8b98c073c4533ef345eeef2">CBOR_TAG_REGEX</a>&#160;&#160;&#160;35</td></tr>
<tr class="separator:aa819563ea8b98c073c4533ef345eeef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bb552dc369fa13a9aaa74cd84f191b" id="r_af8bb552dc369fa13a9aaa74cd84f191b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bb552dc369fa13a9aaa74cd84f191b">CBOR_TAG_MIME</a>&#160;&#160;&#160;36</td></tr>
<tr class="separator:af8bb552dc369fa13a9aaa74cd84f191b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d58429f77ffbe918a6d923b0c54735" id="r_a83d58429f77ffbe918a6d923b0c54735"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83d58429f77ffbe918a6d923b0c54735">CBOR_TAG_BIN_UUID</a>&#160;&#160;&#160;37</td></tr>
<tr class="separator:a83d58429f77ffbe918a6d923b0c54735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab22f8a2eb6a94ed44bb0ca8a72a743" id="r_a6ab22f8a2eb6a94ed44bb0ca8a72a743"><td class="memItemLeft" align="right" valign="top"><a id="a6ab22f8a2eb6a94ed44bb0ca8a72a743" name="a6ab22f8a2eb6a94ed44bb0ca8a72a743"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_CWT</b>&#160;&#160;&#160;61</td></tr>
<tr class="separator:a6ab22f8a2eb6a94ed44bb0ca8a72a743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5e27746b416e804f9e6e6199ba812a" id="r_a8a5e27746b416e804f9e6e6199ba812a"><td class="memItemLeft" align="right" valign="top"><a id="a8a5e27746b416e804f9e6e6199ba812a" name="a8a5e27746b416e804f9e6e6199ba812a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_ENCRYPT</b>&#160;&#160;&#160;96</td></tr>
<tr class="separator:a8a5e27746b416e804f9e6e6199ba812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5455c92387c9611859febd1163666b02" id="r_a5455c92387c9611859febd1163666b02"><td class="memItemLeft" align="right" valign="top"><a id="a5455c92387c9611859febd1163666b02" name="a5455c92387c9611859febd1163666b02"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_MAC</b>&#160;&#160;&#160;97</td></tr>
<tr class="separator:a5455c92387c9611859febd1163666b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ffed36e707fcac6ae229bc958677d5" id="r_a15ffed36e707fcac6ae229bc958677d5"><td class="memItemLeft" align="right" valign="top"><a id="a15ffed36e707fcac6ae229bc958677d5" name="a15ffed36e707fcac6ae229bc958677d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_SIGN</b>&#160;&#160;&#160;98</td></tr>
<tr class="separator:a15ffed36e707fcac6ae229bc958677d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c3cec3b93fc7cbc91c1ddd12eb797d" id="r_a35c3cec3b93fc7cbc91c1ddd12eb797d"><td class="memItemLeft" align="right" valign="top"><a id="a35c3cec3b93fc7cbc91c1ddd12eb797d" name="a35c3cec3b93fc7cbc91c1ddd12eb797d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_GEO_COORD</b>&#160;&#160;&#160;103</td></tr>
<tr class="separator:a35c3cec3b93fc7cbc91c1ddd12eb797d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae1b64585c657d98bef46b06e9757b6" id="r_acae1b64585c657d98bef46b06e9757b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acae1b64585c657d98bef46b06e9757b6">CBOR_TAG_CBOR_MAGIC</a>&#160;&#160;&#160;55799</td></tr>
<tr class="separator:acae1b64585c657d98bef46b06e9757b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae223f57a0ec732a66e0356f7dc228090" id="r_ae223f57a0ec732a66e0356f7dc228090"><td class="memItemLeft" align="right" valign="top"><a id="ae223f57a0ec732a66e0356f7dc228090" name="ae223f57a0ec732a66e0356f7dc228090"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_TAG_NONE</b>&#160;&#160;&#160;UINT64_MAX</td></tr>
<tr class="separator:ae223f57a0ec732a66e0356f7dc228090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daba57367a17b452ab88f30867a8fb0" id="r_a2daba57367a17b452ab88f30867a8fb0"><td class="memItemLeft" align="right" valign="top"><a id="a2daba57367a17b452ab88f30867a8fb0" name="a2daba57367a17b452ab88f30867a8fb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_SIMPLEV_FALSE</b>&#160;&#160;&#160;20</td></tr>
<tr class="separator:a2daba57367a17b452ab88f30867a8fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04e5b4b6696bd6d6ba2ed918f1f8a9d" id="r_ab04e5b4b6696bd6d6ba2ed918f1f8a9d"><td class="memItemLeft" align="right" valign="top"><a id="ab04e5b4b6696bd6d6ba2ed918f1f8a9d" name="ab04e5b4b6696bd6d6ba2ed918f1f8a9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_SIMPLEV_TRUE</b>&#160;&#160;&#160;21</td></tr>
<tr class="separator:ab04e5b4b6696bd6d6ba2ed918f1f8a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27229e3e9d5b19e276322d2d81c0f31" id="r_af27229e3e9d5b19e276322d2d81c0f31"><td class="memItemLeft" align="right" valign="top"><a id="af27229e3e9d5b19e276322d2d81c0f31" name="af27229e3e9d5b19e276322d2d81c0f31"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_SIMPLEV_NULL</b>&#160;&#160;&#160;22</td></tr>
<tr class="separator:af27229e3e9d5b19e276322d2d81c0f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8ed5b07377d966ca34b22e51573173" id="r_a8e8ed5b07377d966ca34b22e51573173"><td class="memItemLeft" align="right" valign="top"><a id="a8e8ed5b07377d966ca34b22e51573173" name="a8e8ed5b07377d966ca34b22e51573173"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_SIMPLEV_UNDEF</b>&#160;&#160;&#160;23</td></tr>
<tr class="separator:a8e8ed5b07377d966ca34b22e51573173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9c0c7e4b32ecf1e7c507f9c654c6fb" id="r_a8b9c0c7e4b32ecf1e7c507f9c654c6fb"><td class="memItemLeft" align="right" valign="top"><a id="a8b9c0c7e4b32ecf1e7c507f9c654c6fb" name="a8b9c0c7e4b32ecf1e7c507f9c654c6fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_SIMPLEV_ONEBYTE</b>&#160;&#160;&#160;24</td></tr>
<tr class="separator:a8b9c0c7e4b32ecf1e7c507f9c654c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22fb3ce491207ac658a52bbcedd89d1" id="r_af22fb3ce491207ac658a52bbcedd89d1"><td class="memItemLeft" align="right" valign="top"><a id="af22fb3ce491207ac658a52bbcedd89d1" name="af22fb3ce491207ac658a52bbcedd89d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HALF_PREC_FLOAT</b>&#160;&#160;&#160;25</td></tr>
<tr class="separator:af22fb3ce491207ac658a52bbcedd89d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbd943404cab4deb5f46a3ed0ca55fd" id="r_a0bbd943404cab4deb5f46a3ed0ca55fd"><td class="memItemLeft" align="right" valign="top"><a id="a0bbd943404cab4deb5f46a3ed0ca55fd" name="a0bbd943404cab4deb5f46a3ed0ca55fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SINGLE_PREC_FLOAT</b>&#160;&#160;&#160;26</td></tr>
<tr class="separator:a0bbd943404cab4deb5f46a3ed0ca55fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3fb37432278a32a91f066f4e505ce6" id="r_aad3fb37432278a32a91f066f4e505ce6"><td class="memItemLeft" align="right" valign="top"><a id="aad3fb37432278a32a91f066f4e505ce6" name="aad3fb37432278a32a91f066f4e505ce6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DOUBLE_PREC_FLOAT</b>&#160;&#160;&#160;27</td></tr>
<tr class="separator:aad3fb37432278a32a91f066f4e505ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327e097f9e27da2789e7368f735f47dc" id="r_a327e097f9e27da2789e7368f735f47dc"><td class="memItemLeft" align="right" valign="top"><a id="a327e097f9e27da2789e7368f735f47dc" name="a327e097f9e27da2789e7368f735f47dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CBOR_SIMPLE_BREAK</b>&#160;&#160;&#160;31</td></tr>
<tr class="separator:a327e097f9e27da2789e7368f735f47dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9b599e92af0a69453a8f8b61ec7777" id="r_adb9b599e92af0a69453a8f8b61ec7777"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb9b599e92af0a69453a8f8b61ec7777">QCBOR_MAX_ITEMS_IN_ARRAY</a>&#160;&#160;&#160;(UINT16_MAX-1)</td></tr>
<tr class="separator:adb9b599e92af0a69453a8f8b61ec7777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecdeb0c5bc02f8892a2c89cdae3e25e" id="r_adecdeb0c5bc02f8892a2c89cdae3e25e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adecdeb0c5bc02f8892a2c89cdae3e25e">QCBOR_MAX_ARRAY_NESTING</a>&#160;&#160;&#160;QCBOR_MAX_ARRAY_NESTING1</td></tr>
<tr class="separator:adecdeb0c5bc02f8892a2c89cdae3e25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2134be6f6197c468ec2190a16b7086" id="r_acc2134be6f6197c468ec2190a16b7086"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc2134be6f6197c468ec2190a16b7086">QCBOR_MAX_CUSTOM_TAGS</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:acc2134be6f6197c468ec2190a16b7086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5917b8146669036e62a49a54b5c4c601" id="r_a5917b8146669036e62a49a54b5c4c601"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5917b8146669036e62a49a54b5c4c601">QCBOR_TYPE_NONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a5917b8146669036e62a49a54b5c4c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad060737704d85d5407ea2f342df9a66" id="r_aad060737704d85d5407ea2f342df9a66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad060737704d85d5407ea2f342df9a66">QCBOR_TYPE_INT64</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aad060737704d85d5407ea2f342df9a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a54fa5ae26645015243d1681331405" id="r_a16a54fa5ae26645015243d1681331405"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16a54fa5ae26645015243d1681331405">QCBOR_TYPE_UINT64</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a16a54fa5ae26645015243d1681331405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d5e4cd1373d0da4e537be46fb6960f" id="r_aa4d5e4cd1373d0da4e537be46fb6960f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d5e4cd1373d0da4e537be46fb6960f">QCBOR_TYPE_ARRAY</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:aa4d5e4cd1373d0da4e537be46fb6960f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d68008ebd9bf49e4417a21be81e429" id="r_ac2d68008ebd9bf49e4417a21be81e429"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2d68008ebd9bf49e4417a21be81e429">QCBOR_TYPE_MAP</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:ac2d68008ebd9bf49e4417a21be81e429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae886c89aec2e7cf66c01b6eddb95a96d" id="r_ae886c89aec2e7cf66c01b6eddb95a96d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae886c89aec2e7cf66c01b6eddb95a96d">QCBOR_TYPE_BYTE_STRING</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ae886c89aec2e7cf66c01b6eddb95a96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a815aef632d06e4cf6f8d9df53edf4" id="r_a76a815aef632d06e4cf6f8d9df53edf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76a815aef632d06e4cf6f8d9df53edf4">QCBOR_TYPE_TEXT_STRING</a>&#160;&#160;&#160;7</td></tr>
<tr class="separator:a76a815aef632d06e4cf6f8d9df53edf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa198d9c5262e614999afd356b653ba" id="r_adaa198d9c5262e614999afd356b653ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaa198d9c5262e614999afd356b653ba">QCBOR_TYPE_POSBIGNUM</a>&#160;&#160;&#160;9</td></tr>
<tr class="separator:adaa198d9c5262e614999afd356b653ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c803e8cc9062cda64c79ce227ec6ab" id="r_ae9c803e8cc9062cda64c79ce227ec6ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9c803e8cc9062cda64c79ce227ec6ab">QCBOR_TYPE_NEGBIGNUM</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ae9c803e8cc9062cda64c79ce227ec6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ada2e6df4c177daf197808f006279c7" id="r_a3ada2e6df4c177daf197808f006279c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ada2e6df4c177daf197808f006279c7">QCBOR_TYPE_DATE_STRING</a>&#160;&#160;&#160;11</td></tr>
<tr class="separator:a3ada2e6df4c177daf197808f006279c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec90d1718b1b06f0dedab210ae53593d" id="r_aec90d1718b1b06f0dedab210ae53593d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec90d1718b1b06f0dedab210ae53593d">QCBOR_TYPE_DATE_EPOCH</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:aec90d1718b1b06f0dedab210ae53593d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028f8c16e763a72709662c9119cebcfd" id="r_a028f8c16e763a72709662c9119cebcfd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028f8c16e763a72709662c9119cebcfd">QCBOR_TYPE_UKNOWN_SIMPLE</a>&#160;&#160;&#160;13</td></tr>
<tr class="separator:a028f8c16e763a72709662c9119cebcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad705c12ce13feb36465c7667569d1" id="r_af7ad705c12ce13feb36465c7667569d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7ad705c12ce13feb36465c7667569d1">QCBOR_TYPE_FALSE</a>&#160;&#160;&#160;20</td></tr>
<tr class="separator:af7ad705c12ce13feb36465c7667569d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4625f4d10093a48fbcc274bc4823082b" id="r_a4625f4d10093a48fbcc274bc4823082b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4625f4d10093a48fbcc274bc4823082b">QCBOR_TYPE_TRUE</a>&#160;&#160;&#160;21</td></tr>
<tr class="separator:a4625f4d10093a48fbcc274bc4823082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2f594f9dc2703e7eaff43a186953ff" id="r_a5f2f594f9dc2703e7eaff43a186953ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f2f594f9dc2703e7eaff43a186953ff">QCBOR_TYPE_NULL</a>&#160;&#160;&#160;22</td></tr>
<tr class="separator:a5f2f594f9dc2703e7eaff43a186953ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1b9d3bc96e09b9881582491bc70138" id="r_aaf1b9d3bc96e09b9881582491bc70138"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf1b9d3bc96e09b9881582491bc70138">QCBOR_TYPE_UNDEF</a>&#160;&#160;&#160;23</td></tr>
<tr class="separator:aaf1b9d3bc96e09b9881582491bc70138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6b81ebf8ffb251ac1cee59329aa9e3" id="r_a3d6b81ebf8ffb251ac1cee59329aa9e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d6b81ebf8ffb251ac1cee59329aa9e3">QCBOR_TYPE_FLOAT</a>&#160;&#160;&#160;26</td></tr>
<tr class="separator:a3d6b81ebf8ffb251ac1cee59329aa9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaeb5fec90e5121d21bfcefef094f9d0" id="r_adaeb5fec90e5121d21bfcefef094f9d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaeb5fec90e5121d21bfcefef094f9d0">QCBOR_TYPE_DOUBLE</a>&#160;&#160;&#160;27</td></tr>
<tr class="separator:adaeb5fec90e5121d21bfcefef094f9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02b6f79a71304eda226a7ac33305479" id="r_ad02b6f79a71304eda226a7ac33305479"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad02b6f79a71304eda226a7ac33305479">QCBOR_TYPE_MAP_AS_ARRAY</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ad02b6f79a71304eda226a7ac33305479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4f7b51f2a6f29123ee31ca92f4201d" id="r_a6b4f7b51f2a6f29123ee31ca92f4201d"><td class="memItemLeft" align="right" valign="top"><a id="a6b4f7b51f2a6f29123ee31ca92f4201d" name="a6b4f7b51f2a6f29123ee31ca92f4201d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QCBOR_TYPE_BREAK</b>&#160;&#160;&#160;31</td></tr>
<tr class="separator:a6b4f7b51f2a6f29123ee31ca92f4201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7017ac2848e9092cc07849edc2cedc22" id="r_a7017ac2848e9092cc07849edc2cedc22"><td class="memItemLeft" align="right" valign="top"><a id="a7017ac2848e9092cc07849edc2cedc22" name="a7017ac2848e9092cc07849edc2cedc22"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QCBOR_TYPE_OPTTAG</b>&#160;&#160;&#160;254</td></tr>
<tr class="separator:a7017ac2848e9092cc07849edc2cedc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4377ad62925e5d38c948b6a00ac52a0" id="r_ab4377ad62925e5d38c948b6a00ac52a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4377ad62925e5d38c948b6a00ac52a0">QCBOR_DECODE_MIN_MEM_POOL_SIZE</a>&#160;&#160;&#160;72</td></tr>
<tr class="separator:ab4377ad62925e5d38c948b6a00ac52a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a006a1a4047c8551db3606f81a0115851" id="r_a006a1a4047c8551db3606f81a0115851"><td class="memItemLeft" align="right" valign="top"><a id="a006a1a4047c8551db3606f81a0115851" name="a006a1a4047c8551db3606f81a0115851"></a>
typedef struct <a class="el" href="struct____QCBORTrackNesting.html">__QCBORTrackNesting</a>&#160;</td><td class="memItemRight" valign="bottom"><b>QCBORTrackNesting</b></td></tr>
<tr class="separator:a006a1a4047c8551db3606f81a0115851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d632a62dd55ce1bbcd70ecab4f48a05" id="r_a6d632a62dd55ce1bbcd70ecab4f48a05"><td class="memItemLeft" align="right" valign="top"><a id="a6d632a62dd55ce1bbcd70ecab4f48a05" name="a6d632a62dd55ce1bbcd70ecab4f48a05"></a>
typedef struct <a class="el" href="struct____QCBORDecodeNesting.html">__QCBORDecodeNesting</a>&#160;</td><td class="memItemRight" valign="bottom"><b>QCBORDecodeNesting</b></td></tr>
<tr class="separator:a6d632a62dd55ce1bbcd70ecab4f48a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cda6b7e1f5c811c87a80551f2f5647" id="r_af9cda6b7e1f5c811c87a80551f2f5647"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__QCBORItem.html">_QCBORItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a></td></tr>
<tr class="separator:af9cda6b7e1f5c811c87a80551f2f5647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11844421eac8fb31c92a3a20a458aef5" id="r_a11844421eac8fb31c92a3a20a458aef5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__QCBOREncodeContext.html">_QCBOREncodeContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a></td></tr>
<tr class="separator:a11844421eac8fb31c92a3a20a458aef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1477d3286dd0b0f64e55886b5d2309" id="r_adb1477d3286dd0b0f64e55886b5d2309"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__QCBORDecodeContext.html">_QCBORDecodeContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a></td></tr>
<tr class="separator:adb1477d3286dd0b0f64e55886b5d2309"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a917c840b71af72c2cdd4b31bb2a4fb42" id="r_a917c840b71af72c2cdd4b31bb2a4fb42"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> { <br />
&#160;&#160;<a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42af59ba798361a9a941d7312c6304a6fba">QCBOR_SUCCESS</a> = 0
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42aea5398e1a2b27fc437b99b9ab91aaafd">QCBOR_ERR_BUFFER_TOO_SMALL</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a0d74cc5b94f9510ecc5f330c238508b8">QCBOR_ERR_ARRAY_NESTING_TOO_DEEP</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a16d78e7c134706bfa0c5b221774cc9b4">QCBOR_ERR_ARRAY_TOO_LONG</a>
, <br />
&#160;&#160;<a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42ab79ef3fec6d6ef45c85d925a5f9c78c6">QCBOR_ERR_TOO_MANY_CLOSES</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a7976ba2a67d65d4b0048fcafbf183655">QCBOR_ERR_UNSUPPORTED</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42af851c38293b14b0335c65b02140e8a3d">QCBOR_ERR_HIT_END</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a1056d95e93e9f01c05b3dce6e82907a4">QCBOR_ERR_BUFFER_TOO_LARGE</a>
, <br />
&#160;&#160;<a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42ab4148715700ffcc769193f2c47bec7ec">QCBOR_ERR_INT_OVERFLOW</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a72071afbe1fe98d8b5b8e798e2b50878">QCBOR_ERR_MAP_LABEL_TYPE</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a5880606db007bdf5dba9498ea877fd84">QCBOR_ERR_ARRAY_OR_MAP_STILL_OPEN</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a691c5b5a79727b84b1da18a1d1c30877">QCBOR_ERR_BAD_SIMPLE</a>
, <br />
&#160;&#160;<a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a042e4c7585f18aed1883721ad0cde1fe">QCBOR_ERR_DATE_OVERFLOW</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a99b8608d0a8ae97155576b2c5590d1cb">QCBOR_ERR_INVALID_CBOR</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42add540e42603e163282db5edf279cff07">QCBOR_ERR_BAD_OPT_TAG</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a52c51d8c1ab843c1c1d550414ea378ad">QCBOR_ERR_EXTRA_BYTES</a>
, <br />
&#160;&#160;<a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a439657577b3780303291244cbac1077e">QCBOR_ERR_CLOSE_MISMATCH</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a64e0fa8767c2d022ecd7885ab2653664">QCBOR_ERR_NO_STRING_ALLOCATOR</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a90bbf40200a6be9f7838db9557eff274">QCBOR_ERR_INDEFINITE_STRING_CHUNK</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42ac137e2e0f81190b6cbb0dbd8837f16e8">QCBOR_ERR_STRING_ALLOCATE</a>
, <br />
&#160;&#160;<a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42a30db911b5d817e7a56499f50a3b59dfa">QCBOR_ERR_BAD_BREAK</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42ad1256c54a3aabfc05e434272d510d222">QCBOR_ERR_TOO_MANY_TAGS</a>
, <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42adf78b2cf913ea4a47220db8a8c352bc2">QCBOR_ERR_MEM_POOL_INTERNAL</a>
<br />
 }</td></tr>
<tr class="separator:a917c840b71af72c2cdd4b31bb2a4fb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1592b19f254b747e6ad788189e8c58" id="r_afb1592b19f254b747e6ad788189e8c58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a> { <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a25dbb7ce42d1c8113a26c9d14a417ccf">QCBOR_DECODE_MODE_NORMAL</a> = 0
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a4116f650e4fa0e0279371dff415152c7">QCBOR_DECODE_MODE_MAP_STRINGS_ONLY</a> = 1
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58aff9fda08b08890a0d6fb6fa362d0c4e5">QCBOR_DECODE_MODE_MAP_AS_ARRAY</a> = 2
 }</td></tr>
<tr class="separator:afb1592b19f254b747e6ad788189e8c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab7f85546a84e1301d1a6af6890cb191e" id="r_ab7f85546a84e1301d1a6af6890cb191e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7f85546a84e1301d1a6af6890cb191e">QCBOREncode_Init</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, <a class="el" href="UsefulBuf_8h.html#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> Storage)</td></tr>
<tr class="separator:ab7f85546a84e1301d1a6af6890cb191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7779154b7b3d4ce7e074866255192d1" id="r_aa7779154b7b3d4ce7e074866255192d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7779154b7b3d4ce7e074866255192d1">QCBOREncode_AddInt64</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, int64_t nNum)</td></tr>
<tr class="memdesc:aa7779154b7b3d4ce7e074866255192d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a signed 64-bit integer to the encoded output.  <br /></td></tr>
<tr class="separator:aa7779154b7b3d4ce7e074866255192d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fc48e69746a5668a5e4deeb55776c2" id="r_a57fc48e69746a5668a5e4deeb55776c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57fc48e69746a5668a5e4deeb55776c2">QCBOREncode_AddUInt64</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, uint64_t uNum)</td></tr>
<tr class="memdesc:a57fc48e69746a5668a5e4deeb55776c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an unsigned 64-bit integer to the encoded output.  <br /></td></tr>
<tr class="separator:a57fc48e69746a5668a5e4deeb55776c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3e4d266c63c327bc963931ac27a12c" id="r_a9c3e4d266c63c327bc963931ac27a12c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c3e4d266c63c327bc963931ac27a12c">QCBOREncode_AddDouble</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, double dNum)</td></tr>
<tr class="memdesc:a9c3e4d266c63c327bc963931ac27a12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a floating-point number to the encoded output.  <br /></td></tr>
<tr class="separator:a9c3e4d266c63c327bc963931ac27a12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25481c14bcc196e1b22c426ba1fefb49" id="r_a25481c14bcc196e1b22c426ba1fefb49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25481c14bcc196e1b22c426ba1fefb49">QCBOREncode_AddTag</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, uint64_t uTag)</td></tr>
<tr class="memdesc:a25481c14bcc196e1b22c426ba1fefb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">[in] Add an optional tag  <br /></td></tr>
<tr class="separator:a25481c14bcc196e1b22c426ba1fefb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0498cefe2cb8d1454340cc8f68cb75f" id="r_ac0498cefe2cb8d1454340cc8f68cb75f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0498cefe2cb8d1454340cc8f68cb75f">QCBOREncode_Finish</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, <a class="el" href="UsefulBuf_8h.html#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> *pEncodedCBOR)</td></tr>
<tr class="memdesc:ac0498cefe2cb8d1454340cc8f68cb75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encoded result.  <br /></td></tr>
<tr class="separator:ac0498cefe2cb8d1454340cc8f68cb75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012f50732fbd530eef67dee5111eedce" id="r_a012f50732fbd530eef67dee5111eedce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a012f50732fbd530eef67dee5111eedce">QCBOREncode_FinishGetSize</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, size_t *uEncodedLen)</td></tr>
<tr class="memdesc:a012f50732fbd530eef67dee5111eedce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encoded CBOR and error status.  <br /></td></tr>
<tr class="separator:a012f50732fbd530eef67dee5111eedce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7111364851b2d02cf67ed09829d405d" id="r_ab7111364851b2d02cf67ed09829d405d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7111364851b2d02cf67ed09829d405d">QCBORDecode_Init</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="UsefulBuf_8h.html#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> EncodedCBOR, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a> nMode)</td></tr>
<tr class="separator:ab7111364851b2d02cf67ed09829d405d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2d572e423cfed0a2c774b2999c53dc" id="r_aee2d572e423cfed0a2c774b2999c53dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc">QCBORDecode_SetMemPool</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="UsefulBuf_8h.html#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a> <a class="el" href="structMemPool.html">MemPool</a>, bool bAllStrings)</td></tr>
<tr class="memdesc:aee2d572e423cfed0a2c774b2999c53dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the <a class="el" href="structMemPool.html">MemPool</a> string allocator for indefinite length strings.  <br /></td></tr>
<tr class="separator:aee2d572e423cfed0a2c774b2999c53dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab573db9aecf8eb82861b9e2df6dc5d9e" id="r_ab573db9aecf8eb82861b9e2df6dc5d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab573db9aecf8eb82861b9e2df6dc5d9e">QCBORDecode_SetUpAllocator</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, const <a class="el" href="structQCBORStringAllocator.html">QCBORStringAllocator</a> *pAllocator, bool bAllStrings)</td></tr>
<tr class="memdesc:ab573db9aecf8eb82861b9e2df6dc5d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a custom string allocator for indefinite length strings.  <br /></td></tr>
<tr class="separator:ab573db9aecf8eb82861b9e2df6dc5d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ea338696573e23b9493813543f98f6" id="r_a01ea338696573e23b9493813543f98f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01ea338696573e23b9493813543f98f6">QCBORDecode_SetCallerConfiguredTagList</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, const <a class="el" href="structQCBORTagListIn.html">QCBORTagListIn</a> *pTagList)</td></tr>
<tr class="memdesc:a01ea338696573e23b9493813543f98f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure list of caller selected tags to be recognized.  <br /></td></tr>
<tr class="separator:a01ea338696573e23b9493813543f98f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5822b9efabd2a4bb1ce13390bf378b61" id="r_a5822b9efabd2a4bb1ce13390bf378b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61">QCBORDecode_GetNext</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *pDecodedItem)</td></tr>
<tr class="memdesc:a5822b9efabd2a4bb1ce13390bf378b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree.  <br /></td></tr>
<tr class="separator:a5822b9efabd2a4bb1ce13390bf378b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3971a89e4bd3816a5e638be2363ba050" id="r_a3971a89e4bd3816a5e638be2363ba050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3971a89e4bd3816a5e638be2363ba050">QCBORDecode_GetNextWithTags</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *pDecodedItem, <a class="el" href="structQCBORTagListOut.html">QCBORTagListOut</a> *pTagList)</td></tr>
<tr class="memdesc:a3971a89e4bd3816a5e638be2363ba050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next item including full list of tags for item.  <br /></td></tr>
<tr class="separator:a3971a89e4bd3816a5e638be2363ba050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ae5c6a36c8d9de1ea4b3f095e958b8" id="r_a73ae5c6a36c8d9de1ea4b3f095e958b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73ae5c6a36c8d9de1ea4b3f095e958b8">QCBORDecode_IsTagged</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, const <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *pItem, uint64_t uTag)</td></tr>
<tr class="memdesc:a73ae5c6a36c8d9de1ea4b3f095e958b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a CBOR item was tagged with a particular tag.  <br /></td></tr>
<tr class="separator:a73ae5c6a36c8d9de1ea4b3f095e958b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79109a9a307c93dddb8b582d4a3a9ceb" id="r_a79109a9a307c93dddb8b582d4a3a9ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb">QCBORDecode_Finish</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx)</td></tr>
<tr class="separator:a79109a9a307c93dddb8b582d4a3a9ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986612a7ed8e0538af3e341744ac656c" id="r_a986612a7ed8e0538af3e341744ac656c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a986612a7ed8e0538af3e341744ac656c">QCBOREncode_AddBuffer</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, uint8_t uMajorType, <a class="el" href="UsefulBuf_8h.html#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> Bytes)</td></tr>
<tr class="memdesc:a986612a7ed8e0538af3e341744ac656c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-private method to add a buffer full of bytes to encoded output.  <br /></td></tr>
<tr class="separator:a986612a7ed8e0538af3e341744ac656c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e19a115627e89f5ee9298ed9d9d976d" id="r_a3e19a115627e89f5ee9298ed9d9d976d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e19a115627e89f5ee9298ed9d9d976d">QCBOREncode_OpenMapOrArray</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, uint8_t uMajorType)</td></tr>
<tr class="memdesc:a3e19a115627e89f5ee9298ed9d9d976d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-private method to open a map, array or bstr wrapped CBOR.  <br /></td></tr>
<tr class="separator:a3e19a115627e89f5ee9298ed9d9d976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f361b7c37de1b35c8ef2d30082366b" id="r_a90f361b7c37de1b35c8ef2d30082366b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90f361b7c37de1b35c8ef2d30082366b">QCBOREncode_CloseMapOrArray</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, uint8_t uMajorType, <a class="el" href="UsefulBuf_8h.html#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> *pWrappedCBOR)</td></tr>
<tr class="memdesc:a90f361b7c37de1b35c8ef2d30082366b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-private method to close a map, array or bstr wrapped CBOR.  <br /></td></tr>
<tr class="separator:a90f361b7c37de1b35c8ef2d30082366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba41561b15e2abbdb0fcf131b2c6ab2d" id="r_aba41561b15e2abbdb0fcf131b2c6ab2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba41561b15e2abbdb0fcf131b2c6ab2d">QCBOREncode_AddType7</a> (<a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *pCtx, size_t uSize, uint64_t uNum)</td></tr>
<tr class="memdesc:aba41561b15e2abbdb0fcf131b2c6ab2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-private method to add simple types.  <br /></td></tr>
<tr class="separator:aba41561b15e2abbdb0fcf131b2c6ab2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Q C B O R E n c o d e / D e c o d e</p>
<p>This implements CBOR &ndash; Concise Binary Object Representation as defined in RFC 7049. More info is at <a href="http://cbor.io">http://cbor.io</a>. This is a near-complete implementation of the specification. Limitations are listed further down.</p>
<p>CBOR is intentionally designed to be translatable to JSON, but not all CBOR can convert to JSON. See RFC 7049 for more info on how to construct CBOR that is the most JSON friendly.</p>
<p>The memory model for encoding and decoding is that encoded CBOR must be in a contiguous buffer in memory. During encoding the caller must supply an output buffer and if the encoding would go off the end of the buffer an error is returned. During decoding the caller supplies the encoded CBOR in a contiguous buffer and the decoder returns pointers and lengths into that buffer for strings.</p>
<p>This implementation does not require malloc. All data structures passed in/out of the APIs can fit on the stack.</p>
<p>Decoding of indefinite length strings is a special case that requires a "string allocator" to allocate memory into which the segments of the string are coalesced. Without this, decoding will error out if an indefinite length string is encountered (indefinite length maps and arrays do not require the string allocator). A simple string allocator called <a class="el" href="structMemPool.html">MemPool</a> is built-in and will work if supplied with a block of memory to allocate. The string allocator can optionally use malloc() or some other custom scheme.</p>
<p>Here are some terms and definitions:</p>
<ul>
<li>"Item", "Data Item": An integer or string or such. The basic "thing" that CBOR is about. An array is an item itself that contains some items.</li>
<li>"Array": An ordered sequence of items, the same as JSON.</li>
<li>"Map": A collection of label/value pairs. Each pair is a data item. A JSON "object" is the same as a CBOR "map".</li>
<li>"Label": The data item in a pair in a map that names or identifies the pair, not the value. This implementation refers to it as a "label". JSON refers to it as the "name". The CBOR RFC refers to it this as a "key". This implementation chooses label instead because key is too easily confused with a cryptographic key. The COSE standard, which uses CBOR, has also chosen to use the term "label" rather than "key" for this same reason.</li>
<li>"Key": See "Label" above.</li>
<li>"Tag": Optional info that can be added before each data item. This is always CBOR major type 6.</li>
<li>"Initial Byte": The first byte of an encoded item. Encoding and decoding of this byte is taken care of by the implementation.</li>
<li>"Additional Info": In addition to the major type, all data items have some other info. This is usually the length of the data, but can be several other things. Encoding and decoding of this is taken care of by the implementation.</li>
</ul>
<p>CBOR has two mechanisms for tagging and labeling the data values like integers and strings. For example, an integer that represents someone's birthday in epoch seconds since Jan 1, 1970 could be encoded like this:</p>
<ul>
<li>First it is CBOR_MAJOR_TYPE_POSITIVE_INT, the primitive positive integer.</li>
<li>Next it has a "tag" CBOR_TAG_DATE_EPOCH indicating the integer represents a date in the form of the number of seconds since Jan 1, 1970.</li>
<li>Last it has a string "label" like "BirthDate" indicating the meaning of the data.</li>
</ul>
<p>The encoded binary looks like this: a1 # Map of 1 item 69 # Indicates text string of 9 bytes 426972746844617465 # The text "BirthDate" c1 # Tags next int as epoch date 1a # Indicates 4 byte integer 580d4172 # unsigned integer date 1477263730</p>
<p>Implementors using this API will primarily work with labels. Generally tags are only needed for making up new data types. This implementation covers most of the data types defined in the RFC using tags. It also, allows for the creation of news tags if necessary.</p>
<p>This implementation explicitly supports labels that are text strings and integers. Text strings translate nicely into JSON objects and are very readable. Integer labels are much less readable, but can be very compact. If they are in the range of -23 to 23 they take up only one byte.</p>
<p>CBOR allows a label to be any type of data including an array or a map. It is possible to use this API to construct and parse such labels, but it is not explicitly supported.</p>
<p>A common encoding usage mode is to invoke the encoding twice. First with no output buffer to compute the length of the needed output buffer. Then the correct sized output buffer is allocated. Last the encoder is invoked again, this time with the output buffer.</p>
<p>The double invocation is not required if the max output buffer size can be predicted. This is usually possible for simple CBOR structures. If the double invocation is implemented, it can be in a loop or function as in the example code so that the code doesn't have to actually be written twice, saving code size.</p>
<p>If a buffer too small to hold the encoded output is given, the error QCBOR_ERR_BUFFER_TOO_SMALL will be returned. Data will never be written off the end of the output buffer no matter which functions here are called or what parameters are passed to them.</p>
<p>The error handling is simple. The only possible errors are trying to encode structures that are too large or too complex. There are no internal malloc calls so there will be no failures for out of memory. Only the final call, <a class="el" href="#ac0498cefe2cb8d1454340cc8f68cb75f" title="Get the encoded result.">QCBOREncode_Finish()</a>, returns an error code. Once an error happens, the encoder goes into an error state and calls to it will do nothing so the encoding can just go on. An error check is not needed after every data item is added.</p>
<p>Encoding generally proceeds by calling <a class="el" href="#ab7f85546a84e1301d1a6af6890cb191e">QCBOREncode_Init()</a>, calling lots of "Add" functions and calling <a class="el" href="#ac0498cefe2cb8d1454340cc8f68cb75f" title="Get the encoded result.">QCBOREncode_Finish()</a>. There are many "Add" functions for various data types. The input buffers need only to be valid during the "Add" calls. The data is copied into the output buf during the "Add" call.</p>
<p>There are three <code>Add</code> functions for each data type. The first / main one for the type is for adding the data item to an array. The second one's name ends in <code>ToMap</code>, is used for adding data items to maps and takes a string argument that is its label in the map. The third one ends in <code>ToMapN</code>, is also used for adding data items to maps, and takes an integer argument that is its label in the map.</p>
<p>The simplest aggregate type is an array, which is a simple ordered set of items without labels the same as JSON arrays. Call QCBOREncode_OpenArray() to open a new array, then "Add" to put items in the array and then QCBOREncode_CloseArray(). Nesting to a limit is allowed. All opens must be matched by closes or an encoding error will be returned.</p>
<p>The other aggregate type is a map which does use labels. The <code>Add</code> functions that end in <code>ToMap</code> and <code>ToMapN</code> are convenient ways to add labeled data items to a map. You can also call any type of <code>Add</code> function once to add a label of any time and then call any type of <code>Add</code> again to add its value.</p>
<p>Note that when you nest arrays or maps in a map, the nested array or map has a label.</p>
<p>Usually it is not necessary to add tags explicitly as most tagged types have functions here, but they can be added by calling <a class="el" href="#a25481c14bcc196e1b22c426ba1fefb49" title="[in] Add an optional tag">QCBOREncode_AddTag()</a>. There is an IANA registry for new tags that are for broad use and standardization as per RFC 7049. It is also allowed for protocols to make up new tags in the range above 256. Note that even arrays and maps can be tagged.</p>
<p>Summary Limits of this implementation:</p><ul>
<li>The entire encoded CBOR must fit into contiguous memory.</li>
<li>Max size of encoded / decoded CBOR data is UINT32_MAX (4GB).</li>
<li>Max array / map nesting level when encoding / decoding is QCBOR_MAX_ARRAY_NESTING (this is typically 15).</li>
<li>Max items in an array or map when encoding / decoding is QCBOR_MAX_ITEMS_IN_ARRAY (typically 65,536).</li>
<li>Does not support encoding indefinite lengths (decoding is supported).</li>
<li>Does not directly support some tagged types: decimal fractions, big floats</li>
<li>Does not directly support labels in maps other than text strings and ints.</li>
<li>Does not directly support int labels greater than INT64_MAX</li>
<li>Epoch dates limited to INT64_MAX (+/- 292 billion years)</li>
<li>Tags on labels are ignored during decoding</li>
</ul>
<p>This implementation is intended to run on 32 and 64-bit CPUs. Minor modifications are needed for it to work on 16-bit CPUs.</p>
<p>The public interface uses size_t for all lengths. Internally the implementation uses 32-bit lengths by design to use less memory and fit structures on the stack. This limits the encoded CBOR it can work with to size UINT32_MAX (4GB) which should be enough.</p>
<p>This implementation assumes two's compliment integer machines. Stdint.h also requires this. It of course would be easy to fix this implementation for another integer representation, but all modern machines seem to be two's compliment. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a82fe584ddba0632aeda34609d4fabeed" name="a82fe584ddba0632aeda34609d4fabeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fe584ddba0632aeda34609d4fabeed">&#9670;&#160;</a></span>CBOR_TAG_B64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBOR_TAG_B64&#160;&#160;&#160;34</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The data in the string is base 64'd </p>

</div>
</div>
<a id="a531e2d609d863de2e6cd1287d42c0357" name="a531e2d609d863de2e6cd1287d42c0357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531e2d609d863de2e6cd1287d42c0357">&#9670;&#160;</a></span>CBOR_TAG_B64URL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBOR_TAG_B64URL&#160;&#160;&#160;33</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The data in the string is a base 64'd URL </p>

</div>
</div>
<a id="a83d58429f77ffbe918a6d923b0c54735" name="a83d58429f77ffbe918a6d923b0c54735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d58429f77ffbe918a6d923b0c54735">&#9670;&#160;</a></span>CBOR_TAG_BIN_UUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBOR_TAG_BIN_UUID&#160;&#160;&#160;37</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary <a class="el" href="classUUID.html">UUID</a> </p>

</div>
</div>
<a id="acae1b64585c657d98bef46b06e9757b6" name="acae1b64585c657d98bef46b06e9757b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae1b64585c657d98bef46b06e9757b6">&#9670;&#160;</a></span>CBOR_TAG_CBOR_MAGIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBOR_TAG_CBOR_MAGIC&#160;&#160;&#160;55799</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The data is CBOR data </p>

</div>
</div>
<a id="a7dedcb07c8058893a67efe42f6740990" name="a7dedcb07c8058893a67efe42f6740990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dedcb07c8058893a67efe42f6740990">&#9670;&#160;</a></span>CBOR_TAG_DATE_EPOCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBOR_TAG_DATE_EPOCH&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See QCBOREncode_AddDateEpoch_2() </p>

</div>
</div>
<a id="a5f01747fee8d393dd1bda112484ab040" name="a5f01747fee8d393dd1bda112484ab040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f01747fee8d393dd1bda112484ab040">&#9670;&#160;</a></span>CBOR_TAG_DATE_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBOR_TAG_DATE_STRING&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See QCBOREncode_AddDateString() below </p>

</div>
</div>
<a id="af8bb552dc369fa13a9aaa74cd84f191b" name="af8bb552dc369fa13a9aaa74cd84f191b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bb552dc369fa13a9aaa74cd84f191b">&#9670;&#160;</a></span>CBOR_TAG_MIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBOR_TAG_MIME&#160;&#160;&#160;36</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MIME messages (including all headers), as defined in RFC2045 </p>

</div>
</div>
<a id="aa819563ea8b98c073c4533ef345eeef2" name="aa819563ea8b98c073c4533ef345eeef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819563ea8b98c073c4533ef345eeef2">&#9670;&#160;</a></span>CBOR_TAG_REGEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBOR_TAG_REGEX&#160;&#160;&#160;35</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>regular expressions in Perl Compatible Regular Expressions (PCRE) / JavaScript syntax ECMA262. </p>

</div>
</div>
<a id="a4ae8a1164ab0a3341445582cfe81613f" name="a4ae8a1164ab0a3341445582cfe81613f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae8a1164ab0a3341445582cfe81613f">&#9670;&#160;</a></span>CBOR_TAG_URI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBOR_TAG_URI&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The data in the string is a URIs, as defined in RFC3986 </p>

</div>
</div>
<a id="ab4377ad62925e5d38c948b6a00ac52a0" name="ab4377ad62925e5d38c948b6a00ac52a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4377ad62925e5d38c948b6a00ac52a0">&#9670;&#160;</a></span>QCBOR_DECODE_MIN_MEM_POOL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_DECODE_MIN_MEM_POOL_SIZE&#160;&#160;&#160;72</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This only matters if you use a string allocator and and set it up with <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite length strings.">QCBORDecode_SetMemPool()</a>. It is the size of the overhead needed needed by <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite length strings.">QCBORDecode_SetMemPool()</a>. If you write your own string allocator or use the separately available malloc based string allocator, this size will not apply </p>

</div>
</div>
<a id="adecdeb0c5bc02f8892a2c89cdae3e25e" name="adecdeb0c5bc02f8892a2c89cdae3e25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecdeb0c5bc02f8892a2c89cdae3e25e">&#9670;&#160;</a></span>QCBOR_MAX_ARRAY_NESTING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_MAX_ARRAY_NESTING&#160;&#160;&#160;QCBOR_MAX_ARRAY_NESTING1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum nesting of arrays and maps when encoding or decoding. The error QCBOR_ERR_ARRAY_NESTING_TOO_DEEP will be returned on encoding of decoding if it is exceeded </p>

</div>
</div>
<a id="acc2134be6f6197c468ec2190a16b7086" name="acc2134be6f6197c468ec2190a16b7086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2134be6f6197c468ec2190a16b7086">&#9670;&#160;</a></span>QCBOR_MAX_CUSTOM_TAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_MAX_CUSTOM_TAGS&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of tags that can be in <a class="el" href="structQCBORTagListIn.html">QCBORTagListIn</a> and passed to <a class="el" href="#a01ea338696573e23b9493813543f98f6" title="Configure list of caller selected tags to be recognized.">QCBORDecode_SetCallerConfiguredTagList()</a> </p>

</div>
</div>
<a id="adb9b599e92af0a69453a8f8b61ec7777" name="adb9b599e92af0a69453a8f8b61ec7777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9b599e92af0a69453a8f8b61ec7777">&#9670;&#160;</a></span>QCBOR_MAX_ITEMS_IN_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_MAX_ITEMS_IN_ARRAY&#160;&#160;&#160;(UINT16_MAX-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of items in a single array or map when encoding of decoding. </p>

</div>
</div>
<a id="aa4d5e4cd1373d0da4e537be46fb6960f" name="aa4d5e4cd1373d0da4e537be46fb6960f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d5e4cd1373d0da4e537be46fb6960f">&#9670;&#160;</a></span>QCBOR_TYPE_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_ARRAY&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for an array. The number of items in the array is in val.uCount. </p>

</div>
</div>
<a id="ae886c89aec2e7cf66c01b6eddb95a96d" name="ae886c89aec2e7cf66c01b6eddb95a96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae886c89aec2e7cf66c01b6eddb95a96d">&#9670;&#160;</a></span>QCBOR_TYPE_BYTE_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BYTE_STRING&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a buffer full of bytes. Data is in val.string. </p>

</div>
</div>
<a id="aec90d1718b1b06f0dedab210ae53593d" name="aec90d1718b1b06f0dedab210ae53593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec90d1718b1b06f0dedab210ae53593d">&#9670;&#160;</a></span>QCBOR_TYPE_DATE_EPOCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DATE_EPOCH&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for integer seconds since Jan 1970 + floating point fraction. Data is in val.epochDate </p>

</div>
</div>
<a id="a3ada2e6df4c177daf197808f006279c7" name="a3ada2e6df4c177daf197808f006279c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ada2e6df4c177daf197808f006279c7">&#9670;&#160;</a></span>QCBOR_TYPE_DATE_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DATE_STRING&#160;&#160;&#160;11</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for RFC 3339 date string, possibly with time zone. Data is in val.dateString </p>

</div>
</div>
<a id="adaeb5fec90e5121d21bfcefef094f9d0" name="adaeb5fec90e5121d21bfcefef094f9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaeb5fec90e5121d21bfcefef094f9d0">&#9670;&#160;</a></span>QCBOR_TYPE_DOUBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DOUBLE&#160;&#160;&#160;27</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a double floating point number. Data is in val.double. </p>

</div>
</div>
<a id="af7ad705c12ce13feb36465c7667569d1" name="af7ad705c12ce13feb36465c7667569d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ad705c12ce13feb36465c7667569d1">&#9670;&#160;</a></span>QCBOR_TYPE_FALSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_FALSE&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the simple value false; nothing more; nothing in val union. </p>

</div>
</div>
<a id="a3d6b81ebf8ffb251ac1cee59329aa9e3" name="a3d6b81ebf8ffb251ac1cee59329aa9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6b81ebf8ffb251ac1cee59329aa9e3">&#9670;&#160;</a></span>QCBOR_TYPE_FLOAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_FLOAT&#160;&#160;&#160;26</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a floating point number. Data is in val.float. </p>

</div>
</div>
<a id="aad060737704d85d5407ea2f342df9a66" name="aad060737704d85d5407ea2f342df9a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad060737704d85d5407ea2f342df9a66">&#9670;&#160;</a></span>QCBOR_TYPE_INT64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_INT64&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for an integer that decoded either between INT64_MIN and INT32_MIN or INT32_MAX and INT64_MAX; val.int64 </p>

</div>
</div>
<a id="ac2d68008ebd9bf49e4417a21be81e429" name="ac2d68008ebd9bf49e4417a21be81e429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d68008ebd9bf49e4417a21be81e429">&#9670;&#160;</a></span>QCBOR_TYPE_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_MAP&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a map; number of items in map is in val.uCount </p>

</div>
</div>
<a id="ad02b6f79a71304eda226a7ac33305479" name="ad02b6f79a71304eda226a7ac33305479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02b6f79a71304eda226a7ac33305479">&#9670;&#160;</a></span>QCBOR_TYPE_MAP_AS_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_MAP_AS_ARRAY&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For QCBOR_DECODE_MODE_MAP_AS_ARRAY decode mode, a map that is being traversed as an array. See <a class="el" href="#ab7111364851b2d02cf67ed09829d405d">QCBORDecode_Init()</a> </p>

</div>
</div>
<a id="ae9c803e8cc9062cda64c79ce227ec6ab" name="ae9c803e8cc9062cda64c79ce227ec6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c803e8cc9062cda64c79ce227ec6ab">&#9670;&#160;</a></span>QCBOR_TYPE_NEGBIGNUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_NEGBIGNUM&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a negative big number. Data is in val.bignum, a pointer and a length. </p>

</div>
</div>
<a id="a5917b8146669036e62a49a54b5c4c601" name="a5917b8146669036e62a49a54b5c4c601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5917b8146669036e62a49a54b5c4c601">&#9670;&#160;</a></span>QCBOR_TYPE_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_NONE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type is unknown, unset or invalid </p>

</div>
</div>
<a id="a5f2f594f9dc2703e7eaff43a186953ff" name="a5f2f594f9dc2703e7eaff43a186953ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2f594f9dc2703e7eaff43a186953ff">&#9670;&#160;</a></span>QCBOR_TYPE_NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_NULL&#160;&#160;&#160;22</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the simple value null; nothing more; nothing in val union. </p>

</div>
</div>
<a id="adaa198d9c5262e614999afd356b653ba" name="adaa198d9c5262e614999afd356b653ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa198d9c5262e614999afd356b653ba">&#9670;&#160;</a></span>QCBOR_TYPE_POSBIGNUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_POSBIGNUM&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a positive big number. Data is in val.bignum, a pointer and a length. </p>

</div>
</div>
<a id="a76a815aef632d06e4cf6f8d9df53edf4" name="a76a815aef632d06e4cf6f8d9df53edf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a815aef632d06e4cf6f8d9df53edf4">&#9670;&#160;</a></span>QCBOR_TYPE_TEXT_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_TEXT_STRING&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a UTF-8 string. It is not NULL terminated. Data is in val.string. </p>

</div>
</div>
<a id="a4625f4d10093a48fbcc274bc4823082b" name="a4625f4d10093a48fbcc274bc4823082b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4625f4d10093a48fbcc274bc4823082b">&#9670;&#160;</a></span>QCBOR_TYPE_TRUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_TRUE&#160;&#160;&#160;21</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the simple value true; nothing more; nothing in val union. </p>

</div>
</div>
<a id="a16a54fa5ae26645015243d1681331405" name="a16a54fa5ae26645015243d1681331405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a54fa5ae26645015243d1681331405">&#9670;&#160;</a></span>QCBOR_TYPE_UINT64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_UINT64&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for an integer that decoded to a more than INT64_MAX and UINT64_MAX; val.uint64 </p>

</div>
</div>
<a id="a028f8c16e763a72709662c9119cebcfd" name="a028f8c16e763a72709662c9119cebcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028f8c16e763a72709662c9119cebcfd">&#9670;&#160;</a></span>QCBOR_TYPE_UKNOWN_SIMPLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_UKNOWN_SIMPLE&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple type that this CBOR implementation doesn't know about; Type is in val.uSimple. </p>

</div>
</div>
<a id="aaf1b9d3bc96e09b9881582491bc70138" name="aaf1b9d3bc96e09b9881582491bc70138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1b9d3bc96e09b9881582491bc70138">&#9670;&#160;</a></span>QCBOR_TYPE_UNDEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_UNDEF&#160;&#160;&#160;23</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the simple value undef; nothing more; nothing in val union. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adb1477d3286dd0b0f64e55886b5d2309" name="adb1477d3286dd0b0f64e55886b5d2309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1477d3286dd0b0f64e55886b5d2309">&#9670;&#160;</a></span>QCBORDecodeContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__QCBORDecodeContext.html">_QCBORDecodeContext</a> <a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> is the data type that holds context decoding the data items for some received CBOR. It is about 100 bytes, so it can go on the stack. The contents are opaque, and the caller should not access any internal items. A context may be re used serially as long as it is re initialized. </p>

</div>
</div>
<a id="a11844421eac8fb31c92a3a20a458aef5" name="a11844421eac8fb31c92a3a20a458aef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11844421eac8fb31c92a3a20a458aef5">&#9670;&#160;</a></span>QCBOREncodeContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__QCBOREncodeContext.html">_QCBOREncodeContext</a> <a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> is the data type that holds context for all the encoding functions. It is less than 200 bytes, so it can go on the stack. The contents are opaque, and the caller should not access any internal items. A context may be re used serially as long as it is re initialized. </p>

</div>
</div>
<a id="af9cda6b7e1f5c811c87a80551f2f5647" name="af9cda6b7e1f5c811c87a80551f2f5647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cda6b7e1f5c811c87a80551f2f5647">&#9670;&#160;</a></span>QCBORItem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__QCBORItem.html">_QCBORItem</a> <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> holds the type, value and other info for a decoded item returned by GetNextItem(). </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afb1592b19f254b747e6ad788189e8c58" name="afb1592b19f254b747e6ad788189e8c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1592b19f254b747e6ad788189e8c58">&#9670;&#160;</a></span>QCBORDecodeMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a25dbb7ce42d1c8113a26c9d14a417ccf" name="afb1592b19f254b747e6ad788189e8c58a25dbb7ce42d1c8113a26c9d14a417ccf"></a>QCBOR_DECODE_MODE_NORMAL&#160;</td><td class="fielddoc"><p>See <a class="el" href="#ab7111364851b2d02cf67ed09829d405d">QCBORDecode_Init()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a4116f650e4fa0e0279371dff415152c7" name="afb1592b19f254b747e6ad788189e8c58a4116f650e4fa0e0279371dff415152c7"></a>QCBOR_DECODE_MODE_MAP_STRINGS_ONLY&#160;</td><td class="fielddoc"><p>See <a class="el" href="#ab7111364851b2d02cf67ed09829d405d">QCBORDecode_Init()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58aff9fda08b08890a0d6fb6fa362d0c4e5" name="afb1592b19f254b747e6ad788189e8c58aff9fda08b08890a0d6fb6fa362d0c4e5"></a>QCBOR_DECODE_MODE_MAP_AS_ARRAY&#160;</td><td class="fielddoc"><p>See <a class="el" href="#ab7111364851b2d02cf67ed09829d405d">QCBORDecode_Init()</a> </p>
</td></tr>
</table>

</div>
</div>
<a id="a917c840b71af72c2cdd4b31bb2a4fb42" name="a917c840b71af72c2cdd4b31bb2a4fb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917c840b71af72c2cdd4b31bb2a4fb42">&#9670;&#160;</a></span>QCBORError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42af59ba798361a9a941d7312c6304a6fba" name="a917c840b71af72c2cdd4b31bb2a4fb42af59ba798361a9a941d7312c6304a6fba"></a>QCBOR_SUCCESS&#160;</td><td class="fielddoc"><p>The encode or decode completely correctly. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42aea5398e1a2b27fc437b99b9ab91aaafd" name="a917c840b71af72c2cdd4b31bb2a4fb42aea5398e1a2b27fc437b99b9ab91aaafd"></a>QCBOR_ERR_BUFFER_TOO_SMALL&#160;</td><td class="fielddoc"><p>The buffer provided for the encoded output when doing encoding was too small and the encoded output will not fit. Also, when the buffer given to <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite length strings.">QCBORDecode_SetMemPool()</a> is too small. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a0d74cc5b94f9510ecc5f330c238508b8" name="a917c840b71af72c2cdd4b31bb2a4fb42a0d74cc5b94f9510ecc5f330c238508b8"></a>QCBOR_ERR_ARRAY_NESTING_TOO_DEEP&#160;</td><td class="fielddoc"><p>During encoding or decoding, the array or map nesting was deeper than this implementation can handle. Note that in the interest of code size and memory use, this implementation has a hard limit on array nesting. The limit is defined as the constant QCBOR_MAX_ARRAY_NESTING. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a16d78e7c134706bfa0c5b221774cc9b4" name="a917c840b71af72c2cdd4b31bb2a4fb42a16d78e7c134706bfa0c5b221774cc9b4"></a>QCBOR_ERR_ARRAY_TOO_LONG&#160;</td><td class="fielddoc"><p>During decoding or encoding, the array or map had too many items in it. This limit QCBOR_MAX_ITEMS_IN_ARRAY, typically 65,535. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42ab79ef3fec6d6ef45c85d925a5f9c78c6" name="a917c840b71af72c2cdd4b31bb2a4fb42ab79ef3fec6d6ef45c85d925a5f9c78c6"></a>QCBOR_ERR_TOO_MANY_CLOSES&#160;</td><td class="fielddoc"><p>During encoding, more arrays or maps were closed than opened. This is a coding error on the part of the caller of the encoder. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a7976ba2a67d65d4b0048fcafbf183655" name="a917c840b71af72c2cdd4b31bb2a4fb42a7976ba2a67d65d4b0048fcafbf183655"></a>QCBOR_ERR_UNSUPPORTED&#160;</td><td class="fielddoc"><p>During decoding, some CBOR construct was encountered that this decoder doesn't support, primarily this is the reserved additional info values, 28 through 30. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42af851c38293b14b0335c65b02140e8a3d" name="a917c840b71af72c2cdd4b31bb2a4fb42af851c38293b14b0335c65b02140e8a3d"></a>QCBOR_ERR_HIT_END&#160;</td><td class="fielddoc"><p>During decoding, hit the end of the given data to decode. For example, a byte string of 100 bytes was expected, but the end of the input was hit before finding those 100 bytes. Corrupted CBOR input will often result in this error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a1056d95e93e9f01c05b3dce6e82907a4" name="a917c840b71af72c2cdd4b31bb2a4fb42a1056d95e93e9f01c05b3dce6e82907a4"></a>QCBOR_ERR_BUFFER_TOO_LARGE&#160;</td><td class="fielddoc"><p>During encoding, the length of the encoded CBOR exceeded UINT32_MAX. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42ab4148715700ffcc769193f2c47bec7ec" name="a917c840b71af72c2cdd4b31bb2a4fb42ab4148715700ffcc769193f2c47bec7ec"></a>QCBOR_ERR_INT_OVERFLOW&#160;</td><td class="fielddoc"><p>During decoding, an integer smaller than INT64_MIN was received (CBOR can represent integers smaller than INT64_MIN, but C cannot). </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a72071afbe1fe98d8b5b8e798e2b50878" name="a917c840b71af72c2cdd4b31bb2a4fb42a72071afbe1fe98d8b5b8e798e2b50878"></a>QCBOR_ERR_MAP_LABEL_TYPE&#160;</td><td class="fielddoc"><p>During decoding, the label for a map entry is bad. What causes this error depends on the decoding mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a5880606db007bdf5dba9498ea877fd84" name="a917c840b71af72c2cdd4b31bb2a4fb42a5880606db007bdf5dba9498ea877fd84"></a>QCBOR_ERR_ARRAY_OR_MAP_STILL_OPEN&#160;</td><td class="fielddoc"><p>During encoding or decoding, the number of array or map opens was not matched by the number of closes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a691c5b5a79727b84b1da18a1d1c30877" name="a917c840b71af72c2cdd4b31bb2a4fb42a691c5b5a79727b84b1da18a1d1c30877"></a>QCBOR_ERR_BAD_SIMPLE&#160;</td><td class="fielddoc"><p>During encoding, the simple value is not between CBOR_SIMPLEV_FALSE and CBOR_SIMPLEV_UNDEF. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a042e4c7585f18aed1883721ad0cde1fe" name="a917c840b71af72c2cdd4b31bb2a4fb42a042e4c7585f18aed1883721ad0cde1fe"></a>QCBOR_ERR_DATE_OVERFLOW&#160;</td><td class="fielddoc"><p>During decoding, a date greater than +- 292 billion years from Jan 1 1970 encountered during parsing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a99b8608d0a8ae97155576b2c5590d1cb" name="a917c840b71af72c2cdd4b31bb2a4fb42a99b8608d0a8ae97155576b2c5590d1cb"></a>QCBOR_ERR_INVALID_CBOR&#160;</td><td class="fielddoc"><p>During decoding, the CBOR is not valid, primarily a simple type is encoded in a prohibited way. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42add540e42603e163282db5edf279cff07" name="a917c840b71af72c2cdd4b31bb2a4fb42add540e42603e163282db5edf279cff07"></a>QCBOR_ERR_BAD_OPT_TAG&#160;</td><td class="fielddoc"><p>Optional tagging that doesn't make sense (an int is tagged as a date string) or can't be handled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a52c51d8c1ab843c1c1d550414ea378ad" name="a917c840b71af72c2cdd4b31bb2a4fb42a52c51d8c1ab843c1c1d550414ea378ad"></a>QCBOR_ERR_EXTRA_BYTES&#160;</td><td class="fielddoc"><p>Returned by <a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb">QCBORDecode_Finish()</a> if all the inputs bytes have not been consumed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a439657577b3780303291244cbac1077e" name="a917c840b71af72c2cdd4b31bb2a4fb42a439657577b3780303291244cbac1077e"></a>QCBOR_ERR_CLOSE_MISMATCH&#160;</td><td class="fielddoc"><p>During encoding, QCBOREncode_Close() call with a different type than is currently open. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a64e0fa8767c2d022ecd7885ab2653664" name="a917c840b71af72c2cdd4b31bb2a4fb42a64e0fa8767c2d022ecd7885ab2653664"></a>QCBOR_ERR_NO_STRING_ALLOCATOR&#160;</td><td class="fielddoc"><p>Unable to decode an indefinite length string because no string allocator was configured. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a90bbf40200a6be9f7838db9557eff274" name="a917c840b71af72c2cdd4b31bb2a4fb42a90bbf40200a6be9f7838db9557eff274"></a>QCBOR_ERR_INDEFINITE_STRING_CHUNK&#160;</td><td class="fielddoc"><p>One of the chunks in an indefinite length string is not of the type of the string. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42ac137e2e0f81190b6cbb0dbd8837f16e8" name="a917c840b71af72c2cdd4b31bb2a4fb42ac137e2e0f81190b6cbb0dbd8837f16e8"></a>QCBOR_ERR_STRING_ALLOCATE&#160;</td><td class="fielddoc"><p>Error allocating space for a string, usually for an indefinite length string. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42a30db911b5d817e7a56499f50a3b59dfa" name="a917c840b71af72c2cdd4b31bb2a4fb42a30db911b5d817e7a56499f50a3b59dfa"></a>QCBOR_ERR_BAD_BREAK&#160;</td><td class="fielddoc"><p>During decoding, a break occurred outside an indefinite length item. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42ad1256c54a3aabfc05e434272d510d222" name="a917c840b71af72c2cdd4b31bb2a4fb42ad1256c54a3aabfc05e434272d510d222"></a>QCBOR_ERR_TOO_MANY_TAGS&#160;</td><td class="fielddoc"><p>During decoding, too many tags in the caller-configured tag list, or not enough space in <a class="el" href="structQCBORTagListOut.html">QCBORTagListOut</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c840b71af72c2cdd4b31bb2a4fb42adf78b2cf913ea4a47220db8a8c352bc2" name="a917c840b71af72c2cdd4b31bb2a4fb42adf78b2cf913ea4a47220db8a8c352bc2"></a>QCBOR_ERR_MEM_POOL_INTERNAL&#160;</td><td class="fielddoc"><p>Returned by <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite length strings.">QCBORDecode_SetMemPool()</a> when xx is too small. This should never happen on a machine with 64-bit or smaller pointers. Fixing it is probably by increasing QCBOR_DECODE_MIN_MEM_POOL_SIZE. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a79109a9a307c93dddb8b582d4a3a9ceb" name="a79109a9a307c93dddb8b582d4a3a9ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79109a9a307c93dddb8b582d4a3a9ceb">&#9670;&#160;</a></span>QCBORDecode_Finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_Finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether all the bytes have been decoded and maps and arrays closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>QCBOR_SUCCESS or error</dd></dl>
<p>This tells you if all the bytes given to <a class="el" href="#ab7111364851b2d02cf67ed09829d405d">QCBORDecode_Init()</a> have been consumed and whether all maps and arrays were closed. The decode is considered to be incorrect or incomplete if not and an error will be returned. </p>

</div>
</div>
<a id="a5822b9efabd2a4bb1ce13390bf378b61" name="a5822b9efabd2a4bb1ce13390bf378b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5822b9efabd2a4bb1ce13390bf378b61">&#9670;&#160;</a></span>QCBORDecode_GetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_GetNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *</td>          <td class="paramname"><span class="paramname"><em>pDecodedItem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDecodedItem</td><td>Holds the CBOR item just decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or error. All errors except QCBOR_ERR_TOO_MANY_TAGS and QCBOR_ERR_STRING_ALLOCATE indicate that the CBOR input could not be decoded. In most cases this is because the CBOR is invalid. In a few cases (QCBOR_ERR_ARRAY_NESTING_TOO_DEEP, QCBOR_ERR_INT_OVERFLOW, QCBOR_ERR_DATE_OVERFLOW) it is because the CBOR is beyond the limits of what this implementation can handle. QCBOR_ERR_NO_STRING_ALLOCATOR indicates CBOR that cannot be handled unless a string allocator is configured. QCBOR_ERR_MAP_LABEL_TYPE is in a way a limitation of this implementation, but can be avoided by decoding in QCBOR_DECODE_MODE_MAP_AS_ARRAY mode.</dd></dl>
<p>pDecodedItem is filled in with the value parsed. Generally, the following data is returned in the structure.</p>
<ul>
<li>The data type in uDataType which indicates which member of the val union the data is in. This decoder figures out the type based on the CBOR major type, the CBOR "additionalInfo", the CBOR optional tags and the value of the integer.</li>
<li>The value of the item, which might be an integer, a pointer and a length, the count of items in an array, a floating-point number or other.</li>
<li>The nesting level for maps and arrays.</li>
<li>The label for an item in a map, which may be a text or byte string or an integer.</li>
<li>The CBOR optional tag or tags.</li>
</ul>
<p>See documentation on in the data type <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> for all the details on what is returned.</p>
<p>This function also handles arrays and maps. When first encountered a <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> will be returned with major type CBOR_MAJOR_TYPE_ARRAY or CBOR_MAJOR_TYPE_ARRAY_MAP. <a class="el" href="struct__QCBORItem.html#a67f431f589006ebac9b5328d0e79efc0">QCBORItem.val.uCount</a> will indicate the number of Items in the array or map. Typically, an implementation will call <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree.">QCBORDecode_GetNext()</a> in a for loop to fetch them all. When decoding indefinite length maps and arrays, <a class="el" href="struct__QCBORItem.html#a67f431f589006ebac9b5328d0e79efc0">QCBORItem.val.uCount</a> is UINT16_MAX and uNextNestLevel must be used to know when the end of a map or array is reached.</p>
<p>Nesting level 0 is the outside top-most nesting level. For example, in a CBOR structure with two items, an integer and a byte string only, both would be at nesting level 0. A CBOR structure with an array open, an integer and a byte string, would have the integer and byte string as nesting level 1.</p>
<p>Here is an example of how the nesting level is reported with no arrays or maps at all</p>
<pre class="fragment">CBOR Structure           Nesting Level
Integer                    0
Byte String                0
</pre><p>Here is an example of how the nesting level is reported with an a simple array and some top-level items.</p>
<pre class="fragment">Integer                    0
Array (with 2 items)       0
Byte String                1
Byte string                1
Integer                    0
</pre><p>Here's a more complex example </p><pre class="fragment">Map with 2 items           0
Text string                1
Array with 3 integers      1
integer                    2
integer                    2
integer                    2
text string                1
byte string                1
</pre><p>In <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a>, uNextNestLevel is the nesting level for the next call to <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree.">QCBORDecode_GetNext()</a>. It indicates if any maps or arrays were closed out during the processing of the just-fecthed <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a>. This processing includes a look-ahead for any breaks that close out indefinite length arrays or maps. This value is needed to be able to understand the hierarchical structure. If uNextNestLevel is not equal to uNestLevel the end of the current map or array has been encountered. This works the same for both definite and indefinite length arrays.</p>
<p>Most uses of this decoder will not need to do anything extra for tag handling. The built-in tags, those with a macro of the form CBOR_TAG_XXXX, will be enough.</p>
<p>If tags beyond built-in tags are to be recognized, they must be configured by calling QCBORDecode_SetCallerConfiguredTags(). If a tag is not recognized it is silently ignored.</p>
<p>Several tagged types are automatically recognized and decoded and returned in their decoded form.</p>
<p>To find out if a <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> was tagged with a particular tag call <a class="el" href="#a73ae5c6a36c8d9de1ea4b3f095e958b8" title="Determine if a CBOR item was tagged with a particular tag.">QCBORDecode_IsTagged()</a>. This works only for built-in tags and caller-configured tags.</p>
<p>To get the full list of tags on an Item without having to pre-configure any predetermined list of tags use <a class="el" href="#a3971a89e4bd3816a5e638be2363ba050" title="Gets the next item including full list of tags for item.">QCBORDecode_GetNextWithTags()</a>. </p>

</div>
</div>
<a id="a3971a89e4bd3816a5e638be2363ba050" name="a3971a89e4bd3816a5e638be2363ba050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3971a89e4bd3816a5e638be2363ba050">&#9670;&#160;</a></span>QCBORDecode_GetNextWithTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_GetNextWithTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *</td>          <td class="paramname"><span class="paramname"><em>pDecodedItem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structQCBORTagListOut.html">QCBORTagListOut</a> *</td>          <td class="paramname"><span class="paramname"><em>pTagList</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next item including full list of tags for item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDecodedItem</td><td>Holds the CBOR item just decoded. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pTagList</td><td>On input array to put tags in; on output the tags on this item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or error.</dd></dl>
<p>This works the same as <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree.">QCBORDecode_GetNext()</a> except that it also returns the full list of tags for the data item. This function should only be needed when parsing CBOR to print it out or convert it to some other format. It should not be needed in an actual CBOR protocol implementation.</p>
<p>Tags will be returned here whether or not they are in the built-in or caller-configured tag lists.</p>
<p>CBOR has no upper bound of limit on the number of tags that can be associated with a data item. In practice the number of tags on an item will usually be small, perhaps less than five. This will return an error if the array in pTagList is too small to hold all the tags for an item.</p>
<p>(This function is separate from <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree.">QCBORDecode_GetNext()</a> so as to not have to make <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> large enough to be able to hold a full list of tags. Even a list of five tags would nearly double its size because tags can be a uint64_t). </p>

</div>
</div>
<a id="ab7111364851b2d02cf67ed09829d405d" name="ab7111364851b2d02cf67ed09829d405d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7111364851b2d02cf67ed09829d405d">&#9670;&#160;</a></span>QCBORDecode_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBORDecode_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UsefulBuf_8h.html#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>EncodedCBOR</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a></td>          <td class="paramname"><span class="paramname"><em>nMode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the CBOR decoder context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EncodedCBOR</td><td>The buffer with CBOR encoded bytes to be decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nMode</td><td>One of QCBOR_DECODE_MODE_xxx</td></tr>
  </table>
  </dd>
</dl>
<p>Initialize context for a pre-order travesal of the encoded CBOR tree.</p>
<p>Most CBOR decoding can be completed by calling this function to start and <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree.">QCBORDecode_GetNext()</a> in a loop.</p>
<p>If indefinite length strings are to be decoded, then <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite length strings.">QCBORDecode_SetMemPool()</a> or <a class="el" href="#ab573db9aecf8eb82861b9e2df6dc5d9e" title="Sets up a custom string allocator for indefinite length strings.">QCBORDecode_SetUpAllocator()</a> must be called to set up a string allocator.</p>
<p>If tags other than built-in tags are to be recognized, then QCBORDecode_SetCallerAddedTagMap() must be called. The built-in tags are those for which a macro of the form CBOR_TAG_XXX is defined.</p>
<p>Three decoding modes are supported. In normal mode, QCBOR_DECODE_MODE_NORMAL, maps are decoded and strings and ints are accepted as map labels. If a label is other than these, the error QCBOR_ERR_MAP_LABEL_TYPE is returned by <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree.">QCBORDecode_GetNext()</a>.</p>
<p>In strings-only mode, QCBOR_DECODE_MODE_MAP_STRINGS_ONLY, only text strings are accepted for map labels. This lines up with CBOR that converts to JSON. The error QCBOR_ERR_MAP_LABEL_TYPE is returned by <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree.">QCBORDecode_GetNext()</a> if anything but a text string label is encountered.</p>
<p>In QCBOR_DECODE_MODE_MAP_AS_ARRAY maps are treated as special arrays. They will be return with special uDataType QCBOR_TYPE_MAP_AS_ARRAY and uCount, the number of items, will be double what it would be for a normal map because the labels are also counted. This mode is useful for decoding CBOR that has labels that are not integers or text strings, but the caller must manage much of the map decoding. </p>

</div>
</div>
<a id="a73ae5c6a36c8d9de1ea4b3f095e958b8" name="a73ae5c6a36c8d9de1ea4b3f095e958b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ae5c6a36c8d9de1ea4b3f095e958b8">&#9670;&#160;</a></span>QCBORDecode_IsTagged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QCBORDecode_IsTagged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *</td>          <td class="paramname"><span class="paramname"><em>pItem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>uTag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a CBOR item was tagged with a particular tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pItem</td><td>The CBOR item to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uTag</td><td>The tag to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it was tagged, 0 if not</dd></dl>
<p><a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Gets the next item (integer, byte string, array...) in pre order traversal of CBOR tree.">QCBORDecode_GetNext()</a> processes tags by looking them up in two lists and setting a bit corresponding to the tag in uTagBits in the <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a>. To find out if a <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> was tagged with a particular tag, call this function. It handles the mapping between the two lists of tags and the bits set for it.</p>
<p>The first tag list is the built-in tags, those with a macro of the form CBOR_TAG_XXX in this header file. There are up to 48 of these, corresponding to the lower 48 tag bits.</p>
<p>The other optional tag list is the ones the caller configured using <a class="el" href="#a01ea338696573e23b9493813543f98f6" title="Configure list of caller selected tags to be recognized.">QCBORDecode_SetCallerConfiguredTagList()</a> There are QCBOR_MAX_CUSTOM_TAGS (16) of these corresponding to the upper 16 tag bits.</p>
<p>See also QCBORDecode_GetTags() and <a class="el" href="#a3971a89e4bd3816a5e638be2363ba050" title="Gets the next item including full list of tags for item.">QCBORDecode_GetNextWithTags()</a>. </p>

</div>
</div>
<a id="a01ea338696573e23b9493813543f98f6" name="a01ea338696573e23b9493813543f98f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ea338696573e23b9493813543f98f6">&#9670;&#160;</a></span>QCBORDecode_SetCallerConfiguredTagList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBORDecode_SetCallerConfiguredTagList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structQCBORTagListIn.html">QCBORTagListIn</a> *</td>          <td class="paramname"><span class="paramname"><em>pTagList</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure list of caller selected tags to be recognized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decode context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pTagList</td><td>Structure holding the list of tags to configure</td></tr>
  </table>
  </dd>
</dl>
<p>This is used to tell the decoder about tags beyond those that are built-in that should be recognized. The built-in tags are those with macros of the form CBOR_TAG_XXX.</p>
<p>See description of <a class="el" href="structQCBORTagListIn.html">QCBORTagListIn</a>. </p>

</div>
</div>
<a id="aee2d572e423cfed0a2c774b2999c53dc" name="aee2d572e423cfed0a2c774b2999c53dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2d572e423cfed0a2c774b2999c53dc">&#9670;&#160;</a></span>QCBORDecode_SetMemPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_SetMemPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UsefulBuf_8h.html#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>MemPool</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bAllStrings</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up the <a class="el" href="structMemPool.html">MemPool</a> string allocator for indefinite length strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decode context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="structMemPool.html">MemPool</a></td><td>The pointer and length of the memory pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bAllStrings</td><td>true means to put even definite length strings in the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error if the <a class="el" href="structMemPool.html">MemPool</a> was less than QCBOR_DECODE_MIN_MEM_POOL_SIZE.</dd></dl>
<p>Indefinite length strings (text and byte) cannot be decoded unless there is a string allocator configured. <a class="el" href="structMemPool.html">MemPool</a> is a simple built-in string allocator that allocates bytes from a memory pool handed to it by calling this function. The memory pool is just a pointer and length for some block of memory that is to be used for string allocation. It can come from the stack, heap or other.</p>
<p>The memory pool must be QCBOR_DECODE_MIN_MEM_POOL_SIZE plus space for all the strings allocated. There is no overhead per string allocated</p>
<p>This memory pool is used for all indefinite length strings that are text strings or byte strings, including strings used as labels.</p>
<p>The pointers to strings in <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> will point into the memory pool set here. They do not need to be individually freed. Just discard the buffer when they are no longer needed.</p>
<p>If bAllStrings is set, then the size will be the overhead plus the space to hold <b>all</b> strings, definite and indefinite length, value or label. The advantage of this is that after the decode is complete, the original memory holding the encoded CBOR does not need to remain valid.</p>
<p>If this function is never called because there is no need to support indefinite length strings, the <a class="el" href="structMemPool.html">MemPool</a> implementation should be dead-stripped by the loader and not add to code size. </p>

</div>
</div>
<a id="ab573db9aecf8eb82861b9e2df6dc5d9e" name="ab573db9aecf8eb82861b9e2df6dc5d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab573db9aecf8eb82861b9e2df6dc5d9e">&#9670;&#160;</a></span>QCBORDecode_SetUpAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBORDecode_SetUpAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structQCBORStringAllocator.html">QCBORStringAllocator</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bAllStrings</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a custom string allocator for indefinite length strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context to set up an allocator for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAllocator</td><td>The string allocator "object"</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="structQCBORStringAllocator.html">QCBORStringAllocator</a> for the requirements of the string allocator.</p>
<p>Typically, this is used if the simple <a class="el" href="structMemPool.html">MemPool</a> allocator isn't desired.</p>
<p>A malloc based string allocator can be obtained by calling QCBOR_DMalloc(). This function is supply separately from qcbor to keep qcbor smaller and neater. It is in a separate GitHub repository.</p>
<p>You can also write your own allocator. Create the allocate, free, and destroy functions and put pointers to them in a <a class="el" href="structQCBORStringAllocator.html">QCBORStringAllocator</a>. </p>

</div>
</div>
<a id="a986612a7ed8e0538af3e341744ac656c" name="a986612a7ed8e0538af3e341744ac656c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986612a7ed8e0538af3e341744ac656c">&#9670;&#160;</a></span>QCBOREncode_AddBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBOREncode_AddBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>uMajorType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UsefulBuf_8h.html#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>Bytes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Semi-private method to add a buffer full of bytes to encoded output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The encoding context to add the integer to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uMajorType</td><td>The CBOR major type of the bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Bytes</td><td>The bytes to add.</td></tr>
  </table>
  </dd>
</dl>
<p>Use QCBOREncode_AddText() or QCBOREncode_AddBytes() or QCBOREncode_AddEncoded() instead. They are inline functions that call this and supply the correct major type. This function is public to make the inline functions work to keep the overall code size down and because the C language has no way to make it private.</p>
<p>If this is called the major type should be CBOR_MAJOR_TYPE_TEXT_STRING, CBOR_MAJOR_TYPE_BYTE_STRING or CBOR_MAJOR_NONE_TYPE_RAW. The last one is special for adding already-encoded CBOR. </p>

</div>
</div>
<a id="a9c3e4d266c63c327bc963931ac27a12c" name="a9c3e4d266c63c327bc963931ac27a12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3e4d266c63c327bc963931ac27a12c">&#9670;&#160;</a></span>QCBOREncode_AddDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBOREncode_AddDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dNum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a floating-point number to the encoded output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The encoding context to add the float to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dNum</td><td>The double precision number to add.</td></tr>
  </table>
  </dd>
</dl>
<p>This outputs a floating-point number with CBOR major type 7.</p>
<p>This will selectively encode the double-precision floating point number as either double-precision, single-precision or half-precision. It will always encode infinity, NaN and 0 has half precision. If no precision will be lost in the conversion to half-precision then it will be converted and encoded. If not and no precision will be lost in conversion to single-precision, then it will be converted and encoded. If not, then no conversion is performed, and it encoded as a double.</p>
<p>Half-precision floating point numbers take up 2 bytes, half that of single-precision, one quarter of double-precision</p>
<p>This automatically reduces the size of encoded messages a lot, maybe even by four if most of values are 0, infinity or NaN.</p>
<p>On decode, these will always be returned as a double.</p>
<p>Error handling is the same as <a class="el" href="#aa7779154b7b3d4ce7e074866255192d1" title="Add a signed 64-bit integer to the encoded output.">QCBOREncode_AddInt64()</a>. </p>

</div>
</div>
<a id="aa7779154b7b3d4ce7e074866255192d1" name="aa7779154b7b3d4ce7e074866255192d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7779154b7b3d4ce7e074866255192d1">&#9670;&#160;</a></span>QCBOREncode_AddInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBOREncode_AddInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>nNum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a signed 64-bit integer to the encoded output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The encoding context to add the integer to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nNum</td><td>The integer to add.</td></tr>
  </table>
  </dd>
</dl>
<p>The integer will be encoded and added to the CBOR output.</p>
<p>This function figures out the size and the sign and encodes in the correct minimal CBOR. Specifically, it will select CBOR major type 0 or 1 based on sign and will encode to 1, 2, 4 or 8 bytes depending on the value of the integer. Values less than 24 effectively encode to one byte because they are encoded in with the CBOR major type. This is a neat and efficient characteristic of CBOR that can be taken advantage of when designing CBOR-based protocols. If integers like tags can be kept between -23 and 23 they will be encoded in one byte including the major type.</p>
<p>If you pass a smaller int, say an int16_t or a small value, say 100, the encoding will still be CBOR's most compact that can represent the value. For example, CBOR always encodes the value 0 as one byte, 0x00. The representation as 0x00 includes identification of the type as an integer too as the major type for an integer is 0. See RFC 7049 Appendix A for more examples of CBOR encoding. This compact encoding is also canonical CBOR as per section 3.9 in RFC 7049.</p>
<p>There are no functions to add int16_t or int32_t because they are not necessary because this always encodes to the smallest number of bytes based on the value (If this code is running on a 32-bit machine having a way to add 32-bit integers would reduce code size some).</p>
<p>If the encoding context is in an error state, this will do nothing. If an error occurs when adding this integer, the internal error flag will be set, and the error will be returned when <a class="el" href="#ac0498cefe2cb8d1454340cc8f68cb75f" title="Get the encoded result.">QCBOREncode_Finish()</a> is called.</p>
<p>See also <a class="el" href="#a57fc48e69746a5668a5e4deeb55776c2" title="Add an unsigned 64-bit integer to the encoded output.">QCBOREncode_AddUInt64()</a>. </p>

</div>
</div>
<a id="a25481c14bcc196e1b22c426ba1fefb49" name="a25481c14bcc196e1b22c426ba1fefb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25481c14bcc196e1b22c426ba1fefb49">&#9670;&#160;</a></span>QCBOREncode_AddTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBOREncode_AddTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>uTag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[in] Add an optional tag </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The encoding context to add the integer to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uTag</td><td>The tag to add</td></tr>
  </table>
  </dd>
</dl>
<p>This outputs a CBOR major type 6 optional tag.</p>
<p>The tag is applied to the next data item added to the encoded output. That data item that is to be tagged can be of any major CBOR type. Any number of tags can be added to a data item by calling this multiple times before the data item is added.</p>
<p>For many of the common standard tags a function to encode data using it already exists and this is not needed. For example, QCBOREncode_AddDateEpoch() already exists to output integers representing dates with the right tag. </p>

</div>
</div>
<a id="aba41561b15e2abbdb0fcf131b2c6ab2d" name="aba41561b15e2abbdb0fcf131b2c6ab2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba41561b15e2abbdb0fcf131b2c6ab2d">&#9670;&#160;</a></span>QCBOREncode_AddType7()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBOREncode_AddType7 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>uNum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Semi-private method to add simple types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The encoding context to add the simple value to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uSize</td><td>Minimum encoding size for uNum. Usually 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uNum</td><td>One of CBOR_SIMPLEV_FALSE through _UNDEF or other.</td></tr>
  </table>
  </dd>
</dl>
<p>This is used to add simple types like true and false.</p>
<p>Call QCBOREncode_AddBool(), QCBOREncode_AddNULL(), QCBOREncode_AddUndef() instead of this.</p>
<p>This function can add simple values that are not defined by CBOR yet. This expansion point in CBOR should not be used unless they are standardized.</p>
<p>Error handling is the same as <a class="el" href="#aa7779154b7b3d4ce7e074866255192d1" title="Add a signed 64-bit integer to the encoded output.">QCBOREncode_AddInt64()</a>. </p>

</div>
</div>
<a id="a57fc48e69746a5668a5e4deeb55776c2" name="a57fc48e69746a5668a5e4deeb55776c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fc48e69746a5668a5e4deeb55776c2">&#9670;&#160;</a></span>QCBOREncode_AddUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBOREncode_AddUInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>uNum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an unsigned 64-bit integer to the encoded output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The encoding context to add the integer to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uNum</td><td>The integer to add.</td></tr>
  </table>
  </dd>
</dl>
<p>The integer will be encoded and added to the CBOR output.</p>
<p>The only reason so use this function is for integers larger than INT64_MAX and smaller than UINT64_MAX. Otherwise <a class="el" href="#aa7779154b7b3d4ce7e074866255192d1" title="Add a signed 64-bit integer to the encoded output.">QCBOREncode_AddInt64()</a> will work fine.</p>
<p>Error handling is the same as for <a class="el" href="#aa7779154b7b3d4ce7e074866255192d1" title="Add a signed 64-bit integer to the encoded output.">QCBOREncode_AddInt64()</a>. </p>

</div>
</div>
<a id="a90f361b7c37de1b35c8ef2d30082366b" name="a90f361b7c37de1b35c8ef2d30082366b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f361b7c37de1b35c8ef2d30082366b">&#9670;&#160;</a></span>QCBOREncode_CloseMapOrArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBOREncode_CloseMapOrArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>uMajorType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UsefulBuf_8h.html#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> *</td>          <td class="paramname"><span class="paramname"><em>pWrappedCBOR</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Semi-private method to close a map, array or bstr wrapped CBOR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to add to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uMajorType</td><td>The major CBOR type to close </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pWrappedCBOR</td><td><a class="el" href="UsefulBuf_8h.html#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> containing wrapped bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Call QCBOREncode_CloseArray(), QCBOREncode_CloseMap() or QCBOREncode_CloseBstrWrap() instead of this. </p>

</div>
</div>
<a id="ac0498cefe2cb8d1454340cc8f68cb75f" name="ac0498cefe2cb8d1454340cc8f68cb75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0498cefe2cb8d1454340cc8f68cb75f">&#9670;&#160;</a></span>QCBOREncode_Finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBOREncode_Finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UsefulBuf_8h.html#a05d9f65b59b672ec72153a346ef7cdad">UsefulBufC</a> *</td>          <td class="paramname"><span class="paramname"><em>pEncodedCBOR</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the encoded result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to finish encoding with. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pEncodedCBOR</td><td>Pointer and length of encoded CBOR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the CBOR error codes.</dd></dl>
<p>If this returns success QCBOR_SUCCESS the encoding was a success and the return length is correct and complete.</p>
<p>If no buffer was passed to QCBOR_Init(), then only the length and number of items was computed. The length is in pEncodedCBOR-&gt;Bytes.len. pEncodedCBOR-&gt;Bytes.ptr is NULL.</p>
<p>If a buffer was passed, then pEncodedCBOR-&gt;Bytes.ptr is the same as the buffer passed to QCBOR_Init() and contains the encoded CBOR and the length is filled in.</p>
<p>If an error is returned, the buffer may have partially encoded incorrect CBOR in it and it should not be used. Likewise, the length may be incorrect and should not be used.</p>
<p>Note that the error could have occurred in one of the many QCBOR_AddXXX calls long before <a class="el" href="#ac0498cefe2cb8d1454340cc8f68cb75f" title="Get the encoded result.">QCBOREncode_Finish()</a> was called. This error handling approach reduces the CBOR implementation size, but makes debugging a problem a little more difficult. </p>

</div>
</div>
<a id="a012f50732fbd530eef67dee5111eedce" name="a012f50732fbd530eef67dee5111eedce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012f50732fbd530eef67dee5111eedce">&#9670;&#160;</a></span>QCBOREncode_FinishGetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBOREncode_FinishGetSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>uEncodedLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the encoded CBOR and error status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to finish encoding with. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uEncodedLen</td><td>The length of the encoded or potentially encoded CBOR in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the CBOR error codes.</dd></dl>
<p>If this returns success QCBOR_SUCCESS the encoding was a success and the return length is correct and complete.</p>
<p>If no buffer was passed to QCBOR_Init(), then only the length was computed. If a buffer was passed, then the encoded CBOR is in the buffer.</p>
<p>If an error is returned, the buffer may have partially encoded incorrect CBOR in it and it should not be used. Likewise, the length may be incorrect and should not be used.</p>
<p>Note that the error could have occurred in one of the many QCBOR_AddXXX calls long before <a class="el" href="#ac0498cefe2cb8d1454340cc8f68cb75f" title="Get the encoded result.">QCBOREncode_Finish()</a> was called. This error handling reduces the CBOR implementation size, but makes debugging harder. </p>

</div>
</div>
<a id="ab7f85546a84e1301d1a6af6890cb191e" name="ab7f85546a84e1301d1a6af6890cb191e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f85546a84e1301d1a6af6890cb191e">&#9670;&#160;</a></span>QCBOREncode_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBOREncode_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UsefulBuf_8h.html#aa7643740fe44091c5c6507368863e85c">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>Storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the the encoder to prepare to encode some CBOR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCtx</td><td>The encoder context to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Storage</td><td>The buffer into which this encoded result will be placed.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this once at the start of an encoding of a CBOR structure. Then call the various QCBOREncode_AddXXX() functions to add the data items. Then call <a class="el" href="#ac0498cefe2cb8d1454340cc8f68cb75f" title="Get the encoded result.">QCBOREncode_Finish()</a>.</p>
<p>The maximum output buffer is UINT32_MAX (4GB). This is not a practical limit in any way and reduces the memory needed by the implementation. The error QCBOR_ERR_BUFFER_TOO_LARGE will be returned by QCBOR_Finish() if a larger buffer length is passed in.</p>
<p>If this is called with pBuf as NULL and uBufLen a large value like UINT32_MAX, all the QCBOREncode_AddXXXX() functions and QCBORE_Encode_Finish() can still be called. No data will be encoded, but the length of what would be encoded will be calculated. The length of the encoded structure will be handed back in the call to <a class="el" href="#ac0498cefe2cb8d1454340cc8f68cb75f" title="Get the encoded result.">QCBOREncode_Finish()</a>. You can then allocate a buffer of that size and call all the encoding again, this time to fill in the buffer.</p>
<p>A QCBORContext can be reused over and over as long as <a class="el" href="#ab7f85546a84e1301d1a6af6890cb191e">QCBOREncode_Init()</a> is called. </p>

</div>
</div>
<a id="a3e19a115627e89f5ee9298ed9d9d976d" name="a3e19a115627e89f5ee9298ed9d9d976d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e19a115627e89f5ee9298ed9d9d976d">&#9670;&#160;</a></span>QCBOREncode_OpenMapOrArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBOREncode_OpenMapOrArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a11844421eac8fb31c92a3a20a458aef5">QCBOREncodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>uMajorType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Semi-private method to open a map, array or bstr wrapped CBOR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to add to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uMajorType</td><td>The major CBOR type to close</td></tr>
  </table>
  </dd>
</dl>
<p>Call QCBOREncode_OpenArray(), QCBOREncode_OpenMap() or QCBOREncode_BstrWrap() instead of this. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5fdebfbd0a4b5643a5e85bf3c8b1558b.html">mbed-os</a></li><li class="navelem"><a class="el" href="dir_d00fafdb9414f6e624fcf4d73ffde065.html">platform</a></li><li class="navelem"><a class="el" href="dir_a72924067aea8bbead751f11070268f4.html">FEATURE_EXPERIMENTAL_API</a></li><li class="navelem"><a class="el" href="dir_007a19531d3d09289f9f9c2cf309e91b.html">FEATURE_PSA</a></li><li class="navelem"><a class="el" href="dir_05e0d8a557d855fa23572451f1c8ea18.html">TARGET_MBED_PSA_SRV</a></li><li class="navelem"><a class="el" href="dir_ca746bf8ecd12d766019f43663efcc0b.html">services</a></li><li class="navelem"><a class="el" href="dir_923835f9769c78775a68e44a6b879543.html">attestation</a></li><li class="navelem"><a class="el" href="dir_3e8e74e557914f05fcb63c739dc062d4.html">qcbor</a></li><li class="navelem"><a class="el" href="dir_39375c5e13307d3e1d0539a6cbb9bd8a.html">inc</a></li><li class="navelem"><a class="el" href="qcbor_8h.html">qcbor.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
