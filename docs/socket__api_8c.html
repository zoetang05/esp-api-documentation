<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: /home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/nanostack/sal-stack-nanostack/source/libNET/src/socket_api.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('socket__api_8c.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">socket_api.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classSocket.html">Socket</a> API for library model.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;nsconfig.h&quot;</code><br />
<code>#include &quot;<a class="el" href="ns__types_8h_source.html">ns_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="eventOS__scheduler_8h_source.html">eventOS_scheduler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="arm__hal__phy_8h_source.html">platform/arm_hal_phy.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ns__address_8h_source.html">ns_address.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="socket__api_8h_source.html">socket_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ns__trace_8h_source.html">ns_trace.h</a>&quot;</code><br />
<code>#include &quot;string.h&quot;</code><br />
<code>#include &quot;<a class="el" href="nsdynmemLIB_8h_source.html">nsdynmemLIB.h</a>&quot;</code><br />
<code>#include &quot;Core/include/ns_socket.h&quot;</code><br />
<code>#include &quot;<a class="el" href="protocol_8h_source.html">NWK_INTERFACE/Include/protocol.h</a>&quot;</code><br />
<code>#include &quot;Common_Protocols/ipv6_constants.h&quot;</code><br />
<code>#include &quot;Common_Protocols/ipv6_flow.h&quot;</code><br />
<code>#include &quot;Common_Protocols/tcp.h&quot;</code><br />
<code>#include &quot;Common_Protocols/udp.h&quot;</code><br />
<code>#include &quot;6LoWPAN/Bootstraps/protocol_6lowpan.h&quot;</code><br />
<code>#include &quot;common_functions.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a11d6426816b579f962c2c72da915d991" id="r_a11d6426816b579f962c2c72da915d991"><td class="memItemLeft" align="right" valign="top"><a id="a11d6426816b579f962c2c72da915d991" name="a11d6426816b579f962c2c72da915d991"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUILD_LIBRARY</b></td></tr>
<tr class="separator:a11d6426816b579f962c2c72da915d991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace62ea8082b91f14c6055d38b176c508" id="r_ace62ea8082b91f14c6055d38b176c508"><td class="memItemLeft" align="right" valign="top"><a id="ace62ea8082b91f14c6055d38b176c508" name="ace62ea8082b91f14c6055d38b176c508"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TRACE_GROUP</b>&#160;&#160;&#160;&quot;sckA&quot;</td></tr>
<tr class="separator:ace62ea8082b91f14c6055d38b176c508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b8dc2e12ede9d4076462579df48e69" id="r_a28b8dc2e12ede9d4076462579df48e69"><td class="memItemLeft" align="right" valign="top"><a id="a28b8dc2e12ede9d4076462579df48e69" name="a28b8dc2e12ede9d4076462579df48e69"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GETSOCKOPT_DATA_READY</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a28b8dc2e12ede9d4076462579df48e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f52d39e21e38fdb65f0ff26dc2d9eaf" id="r_a2f52d39e21e38fdb65f0ff26dc2d9eaf"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f52d39e21e38fdb65f0ff26dc2d9eaf">socket_open</a> (uint8_t protocol, uint16_t identifier, void(*passed_fptr)(void *))</td></tr>
<tr class="memdesc:a2f52d39e21e38fdb65f0ff26dc2d9eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialize a socket for communication.  <br /></td></tr>
<tr class="separator:a2f52d39e21e38fdb65f0ff26dc2d9eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d80ab729daef5f8ba8dd933a761a4e" id="r_a49d80ab729daef5f8ba8dd933a761a4e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49d80ab729daef5f8ba8dd933a761a4e">socket_close</a> (int8_t sid)</td></tr>
<tr class="memdesc:a49d80ab729daef5f8ba8dd933a761a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to close a socket.  <br /></td></tr>
<tr class="separator:a49d80ab729daef5f8ba8dd933a761a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49634d9e74b49935e69289a3802a18dc" id="r_a49634d9e74b49935e69289a3802a18dc"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49634d9e74b49935e69289a3802a18dc">socket_listen</a> (int8_t <a class="el" href="structsocket.html">socket</a>, uint8_t backlog)</td></tr>
<tr class="memdesc:a49634d9e74b49935e69289a3802a18dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to set a socket to listening mode.  <br /></td></tr>
<tr class="separator:a49634d9e74b49935e69289a3802a18dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ba4bb45d53a3784b6e0c98c4650a86" id="r_a06ba4bb45d53a3784b6e0c98c4650a86"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ba4bb45d53a3784b6e0c98c4650a86">socket_accept</a> (int8_t listen_socket_id, <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *addr, void(*passed_fptr)(void *))</td></tr>
<tr class="memdesc:a06ba4bb45d53a3784b6e0c98c4650a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to accept a new connection on an socket.  <br /></td></tr>
<tr class="separator:a06ba4bb45d53a3784b6e0c98c4650a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497ae9406f6f8160c9ec4fb096d7b213" id="r_a497ae9406f6f8160c9ec4fb096d7b213"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a497ae9406f6f8160c9ec4fb096d7b213">socket_shutdown</a> (int8_t <a class="el" href="structsocket.html">socket</a>, uint8_t how)</td></tr>
<tr class="memdesc:a497ae9406f6f8160c9ec4fb096d7b213"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to shut down a connection.  <br /></td></tr>
<tr class="separator:a497ae9406f6f8160c9ec4fb096d7b213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a1617cc03d0b1904714643e70f8ae2" id="r_a75a1617cc03d0b1904714643e70f8ae2"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75a1617cc03d0b1904714643e70f8ae2">socket_getsockname</a> (int8_t <a class="el" href="structsocket.html">socket</a>, <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *address)</td></tr>
<tr class="memdesc:a75a1617cc03d0b1904714643e70f8ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to read local address and port for a bound socket.  <br /></td></tr>
<tr class="separator:a75a1617cc03d0b1904714643e70f8ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5701178689c3daa8a039d07a2cbc61e" id="r_af5701178689c3daa8a039d07a2cbc61e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5701178689c3daa8a039d07a2cbc61e">socket_getpeername</a> (int8_t <a class="el" href="structsocket.html">socket</a>, <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *address)</td></tr>
<tr class="memdesc:af5701178689c3daa8a039d07a2cbc61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to read remote address and port for a connected socket.  <br /></td></tr>
<tr class="separator:af5701178689c3daa8a039d07a2cbc61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c3af52fc3dd173a10186f89cc74e3d" id="r_a45c3af52fc3dd173a10186f89cc74e3d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45c3af52fc3dd173a10186f89cc74e3d">socket_read</a> (int8_t <a class="el" href="structsocket.html">socket</a>, <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *src_addr, uint8_t *<a class="el" href="structbuffer.html">buffer</a>, uint16_t length)</td></tr>
<tr class="memdesc:a45c3af52fc3dd173a10186f89cc74e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to read received data buffer from a socket.  <br /></td></tr>
<tr class="separator:a45c3af52fc3dd173a10186f89cc74e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214d3be1d867315bf7e144dc6a796f99" id="r_a214d3be1d867315bf7e144dc6a796f99"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a214d3be1d867315bf7e144dc6a796f99">socket_recv</a> (int8_t <a class="el" href="structsocket.html">socket</a>, void *<a class="el" href="structbuffer.html">buffer</a>, uint16_t length, int flags)</td></tr>
<tr class="memdesc:a214d3be1d867315bf7e144dc6a796f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to read received data buffer from a socket,.  <br /></td></tr>
<tr class="separator:a214d3be1d867315bf7e144dc6a796f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ed5c1ac957864decc0075decd8ad2d" id="r_ac7ed5c1ac957864decc0075decd8ad2d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7ed5c1ac957864decc0075decd8ad2d">socket_recvfrom</a> (int8_t <a class="el" href="structsocket.html">socket</a>, void *<a class="el" href="structbuffer.html">buffer</a>, uint16_t length, int flags, <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *src_addr)</td></tr>
<tr class="memdesc:ac7ed5c1ac957864decc0075decd8ad2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to read received data buffer from a socket.  <br /></td></tr>
<tr class="separator:ac7ed5c1ac957864decc0075decd8ad2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15147f986ce27671c3329035b770116" id="r_aa15147f986ce27671c3329035b770116"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa15147f986ce27671c3329035b770116">socket_recvmsg</a> (int8_t <a class="el" href="structsocket.html">socket</a>, <a class="el" href="structns__msghdr.html">ns_msghdr_t</a> *msg, int flags)</td></tr>
<tr class="memdesc:aa15147f986ce27671c3329035b770116"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to read received message with ancillary data from a socket.  <br /></td></tr>
<tr class="separator:aa15147f986ce27671c3329035b770116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0d3c19054a92ee77ce38b5d32e46da" id="r_aca0d3c19054a92ee77ce38b5d32e46da"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca0d3c19054a92ee77ce38b5d32e46da">socket_sendmsg</a> (int8_t <a class="el" href="structsocket.html">socket</a>, const <a class="el" href="structns__msghdr.html">ns_msghdr_t</a> *msg, int flags)</td></tr>
<tr class="memdesc:aca0d3c19054a92ee77ce38b5d32e46da"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to send UDP, TCP or raw ICMP data via the socket with or without ancillary data or destination address.  <br /></td></tr>
<tr class="separator:aca0d3c19054a92ee77ce38b5d32e46da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69df1f91ca3395824d3f6a499da06c3" id="r_ad69df1f91ca3395824d3f6a499da06c3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad69df1f91ca3395824d3f6a499da06c3">socket_sendto</a> (int8_t <a class="el" href="structsocket.html">socket</a>, const <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *address, const void *<a class="el" href="structbuffer.html">buffer</a>, uint16_t length)</td></tr>
<tr class="memdesc:ad69df1f91ca3395824d3f6a499da06c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to send UDP, TCP or raw ICMP data via the socket.  <br /></td></tr>
<tr class="separator:ad69df1f91ca3395824d3f6a499da06c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5c7711e3122c53dc1274de7a1cc8a0" id="r_aba5c7711e3122c53dc1274de7a1cc8a0"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba5c7711e3122c53dc1274de7a1cc8a0">socket_connect</a> (int8_t <a class="el" href="structsocket.html">socket</a>, <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *address, uint8_t randomly_take_src_number)</td></tr>
<tr class="memdesc:aba5c7711e3122c53dc1274de7a1cc8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to connect to remote peer (TCP).  <br /></td></tr>
<tr class="separator:aba5c7711e3122c53dc1274de7a1cc8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9f4994720a3fe67a110604c4620113" id="r_ade9f4994720a3fe67a110604c4620113"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade9f4994720a3fe67a110604c4620113">socket_bind</a> (int8_t <a class="el" href="structsocket.html">socket</a>, const <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *address)</td></tr>
<tr class="memdesc:ade9f4994720a3fe67a110604c4620113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind socket to address.  <br /></td></tr>
<tr class="separator:ade9f4994720a3fe67a110604c4620113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9e54ffd6cf557096ab10323d69c2c6" id="r_aea9e54ffd6cf557096ab10323d69c2c6"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea9e54ffd6cf557096ab10323d69c2c6">socket_bind2addrsel</a> (int8_t <a class="el" href="structsocket.html">socket</a>, const <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *dst_address)</td></tr>
<tr class="memdesc:aea9e54ffd6cf557096ab10323d69c2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a local address to a socket based on the destination address and the address selection preferences.  <br /></td></tr>
<tr class="separator:aea9e54ffd6cf557096ab10323d69c2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8d6315f44d135a08ae9d7d2c7e6cd1" id="r_a8e8d6315f44d135a08ae9d7d2c7e6cd1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e8d6315f44d135a08ae9d7d2c7e6cd1">socket_send</a> (int8_t <a class="el" href="structsocket.html">socket</a>, const void *<a class="el" href="structbuffer.html">buffer</a>, uint16_t length)</td></tr>
<tr class="memdesc:a8e8d6315f44d135a08ae9d7d2c7e6cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data via a connected socket by client.  <br /></td></tr>
<tr class="separator:a8e8d6315f44d135a08ae9d7d2c7e6cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3580e586ae6d714b6ca3a04d1f8b8693" id="r_a3580e586ae6d714b6ca3a04d1f8b8693"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3580e586ae6d714b6ca3a04d1f8b8693">socket_setsockopt</a> (int8_t <a class="el" href="structsocket.html">socket</a>, uint8_t level, uint8_t opt_name, const void *opt_value, uint16_t opt_len)</td></tr>
<tr class="memdesc:a3580e586ae6d714b6ca3a04d1f8b8693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option for a socket.  <br /></td></tr>
<tr class="separator:a3580e586ae6d714b6ca3a04d1f8b8693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0d2cbf2ba417e92570fa20d208c249" id="r_a0a0d2cbf2ba417e92570fa20d208c249"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a0d2cbf2ba417e92570fa20d208c249">socket_getsockopt</a> (int8_t <a class="el" href="structsocket.html">socket</a>, uint8_t level, uint8_t opt_name, void *opt_value, uint16_t *opt_len)</td></tr>
<tr class="memdesc:a0a0d2cbf2ba417e92570fa20d208c249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option for a socket.  <br /></td></tr>
<tr class="separator:a0a0d2cbf2ba417e92570fa20d208c249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f0a6ffe04c48548fa9bb655bd0c2e6" id="r_a22f0a6ffe04c48548fa9bb655bd0c2e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structns__cmsghdr.html">ns_cmsghdr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22f0a6ffe04c48548fa9bb655bd0c2e6">NS_CMSG_NXTHDR</a> (const <a class="el" href="structns__msghdr.html">ns_msghdr_t</a> *msgh, const <a class="el" href="structns__cmsghdr.html">ns_cmsghdr_t</a> *cmsg)</td></tr>
<tr class="memdesc:a22f0a6ffe04c48548fa9bb655bd0c2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse next control message from message by current control message header.  <br /></td></tr>
<tr class="separator:a22f0a6ffe04c48548fa9bb655bd0c2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae33aefdb733b605daf4ab51056557c44" id="r_ae33aefdb733b605daf4ab51056557c44"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33aefdb733b605daf4ab51056557c44">ns_in6addr_any</a> [16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}</td></tr>
<tr class="separator:ae33aefdb733b605daf4ab51056557c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classSocket.html">Socket</a> API for library model. </p>
<p>The socket API functions for library model </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a22f0a6ffe04c48548fa9bb655bd0c2e6" name="a22f0a6ffe04c48548fa9bb655bd0c2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f0a6ffe04c48548fa9bb655bd0c2e6">&#9670;&#160;</a></span>NS_CMSG_NXTHDR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structns__cmsghdr.html">ns_cmsghdr_t</a> * NS_CMSG_NXTHDR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structns__msghdr.html">ns_msghdr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>msgh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structns__cmsghdr.html">ns_cmsghdr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>cmsg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse next control message from message by current control message header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgh</td><td>Pointer for socket message. </td></tr>
    <tr><td class="paramname">cmsg</td><td>Pointer for last parsed control message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to Next control message header , Could be NULL when no more control messages data. </dd></dl>

</div>
</div>
<a id="a06ba4bb45d53a3784b6e0c98c4650a86" name="a06ba4bb45d53a3784b6e0c98c4650a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ba4bb45d53a3784b6e0c98c4650a86">&#9670;&#160;</a></span>socket_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_accept </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>passed_fptr&#160;</em></span>)(void *)&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to accept a new connection on an socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>The socket ID of the listening socket. </td></tr>
    <tr><td class="paramname">addr</td><td>Either NULL pointer or pointer to structure where the remote address of the connecting host is copied. </td></tr>
    <tr><td class="paramname">passed_fptr</td><td>A function pointer to a function that is called whenever a data frame is received to the new socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or greater on success; return value is the new socket ID. </dd>
<dd>
-1 on failure. </dd>
<dd>
NS_EWOULDBLOCK if no pending connections. </dd></dl>

</div>
</div>
<a id="ade9f4994720a3fe67a110604c4620113" name="ade9f4994720a3fe67a110604c4620113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9f4994720a3fe67a110604c4620113">&#9670;&#160;</a></span>socket_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_bind </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind socket to address. </p>
<p>Used by the application to bind a socket to a port and/or an address. Binding of each of address and port can only be done once.</p>
<p>If address is ns_in6addr_any, the address binding is not changed. If port is 0, the port binding is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td><a class="el" href="classSocket.html">Socket</a> ID of the socket to bind. </td></tr>
    <tr><td class="paramname">address</td><td>Address structure containing the port and/or address to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 if the given address is NULL. </dd>
<dd>
-2 if the port is already bound to another socket. </dd>
<dd>
-3 if address is not us. </dd>
<dd>
-4 if the socket is already bound. </dd>
<dd>
-5 bind is not supported on this type of socket. </dd></dl>

</div>
</div>
<a id="aea9e54ffd6cf557096ab10323d69c2c6" name="aea9e54ffd6cf557096ab10323d69c2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9e54ffd6cf557096ab10323d69c2c6">&#9670;&#160;</a></span>socket_bind2addrsel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_bind2addrsel </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dst_address</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a local address to a socket based on the destination address and the address selection preferences. </p>
<p>Binding happens to the same address that <a class="el" href="socket__api_8h.html#aba5c7711e3122c53dc1274de7a1cc8a0" title="A function to connect to remote peer (TCP).">socket_connect()</a> would bind to. Reference: RFC5014 IPv6 <a class="el" href="classSocket.html">Socket</a> API for Source Address Selection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">dst_address</td><td>The destination address to which the socket wants to communicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 if the given address is NULL or socket ID is invalid. </dd>
<dd>
-2 if the memory allocation failed. </dd>
<dd>
-3 if the socket is already bound to address. </dd>
<dd>
-4 if the interface cannot be found. </dd>
<dd>
-5 if the source address selection fails. </dd>
<dd>
-6 bind2addrsel is not supported on this type of socket. </dd></dl>

</div>
</div>
<a id="a49d80ab729daef5f8ba8dd933a761a4e" name="a49d80ab729daef5f8ba8dd933a761a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d80ab729daef5f8ba8dd933a761a4e">&#9670;&#160;</a></span>socket_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_close </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to close a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>ID of the socket to be closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 socket closed. </dd>
<dd>
-1 socket not closed. </dd></dl>

</div>
</div>
<a id="aba5c7711e3122c53dc1274de7a1cc8a0" name="aba5c7711e3122c53dc1274de7a1cc8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5c7711e3122c53dc1274de7a1cc8a0">&#9670;&#160;</a></span>socket_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_connect </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>randomly_take_src_number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to connect to remote peer (TCP). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">address</td><td>The address of a remote peer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000643">Deprecated</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">randomly_take_src_number</td><td>Ignored - random local port is always chosen if not yet bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 in case of an invalid socket ID or parameter. </dd>
<dd>
-2 if memory allocation fails. </dd>
<dd>
-3 if the socket is in listening state. </dd>
<dd>
-4 if the socket is already connected. </dd>
<dd>
-5 connect is not supported on this type of socket. </dd>
<dd>
-6 if the TCP session state is wrong. </dd>
<dd>
-7 if the source address selection fails. </dd></dl>

</div>
</div>
<a id="af5701178689c3daa8a039d07a2cbc61e" name="af5701178689c3daa8a039d07a2cbc61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5701178689c3daa8a039d07a2cbc61e">&#9670;&#160;</a></span>socket_getpeername()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_getpeername </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to read remote address and port for a connected socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">address</td><td>A pointer to the address structure where the remote address information is written to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 if no socket is found. </dd>
<dd>
-2 if no socket is not connected. </dd></dl>

</div>
</div>
<a id="a75a1617cc03d0b1904714643e70f8ae2" name="a75a1617cc03d0b1904714643e70f8ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a1617cc03d0b1904714643e70f8ae2">&#9670;&#160;</a></span>socket_getsockname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_getsockname </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to read local address and port for a bound socket. </p>
<p>This call writes ns_in6addr_any if address is not bound and 0 if the port is not bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">address</td><td>A pointer to the address structure where the local address information is written to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 if no socket is found. </dd></dl>

</div>
</div>
<a id="a0a0d2cbf2ba417e92570fa20d208c249" name="a0a0d2cbf2ba417e92570fa20d208c249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0d2cbf2ba417e92570fa20d208c249">&#9670;&#160;</a></span>socket_getsockopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_getsockopt </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>opt_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>opt_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>opt_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an option for a socket. </p>
<p>Used to read miscellaneous options for a socket. Supported levels and names defined above. If the buffer is smaller than the option, the output is silently truncated; otherwise opt_len is modified to indicate the actual length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">level</td><td>The protocol level. </td></tr>
    <tr><td class="paramname">opt_name</td><td>The option name (interpretation depends on level). See <a class="el" href="socket__api_8h.html#OPTNAMES_IPV6">OPTNAMES_IPV6</a>. </td></tr>
    <tr><td class="paramname">opt_value</td><td>A pointer to output buffer. </td></tr>
    <tr><td class="paramname">opt_len</td><td>A pointer to length of output buffer; updated on exit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 invalid socket ID. </dd>
<dd>
-2 invalid/unsupported option. </dd>
<dd>
-3 data can't be retrieved. </dd></dl>

</div>
</div>
<a id="a49634d9e74b49935e69289a3802a18dc" name="a49634d9e74b49935e69289a3802a18dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49634d9e74b49935e69289a3802a18dc">&#9670;&#160;</a></span>socket_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_listen </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>backlog</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to set a socket to listening mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">backlog</td><td>The pending connections queue size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 on failure. </dd></dl>

</div>
</div>
<a id="a2f52d39e21e38fdb65f0ff26dc2d9eaf" name="a2f52d39e21e38fdb65f0ff26dc2d9eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f52d39e21e38fdb65f0ff26dc2d9eaf">&#9670;&#160;</a></span>socket_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>protocol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>passed_fptr&#160;</em></span>)(void *)&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialize a socket for communication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>Defines the protocol to use. </td></tr>
    <tr><td class="paramname">identifier</td><td>The socket port. 0 indicates that port is not specified and it will be selected automatically when using the socket. </td></tr>
    <tr><td class="paramname">passed_fptr</td><td>A function pointer to a function that is called whenever a data frame is received to this socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or greater on success; Return value is the socket ID. </dd>
<dd>
-1 on failure. </dd>
<dd>
-2 on port reserved. </dd></dl>

</div>
</div>
<a id="a45c3af52fc3dd173a10186f89cc74e3d" name="a45c3af52fc3dd173a10186f89cc74e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c3af52fc3dd173a10186f89cc74e3d">&#9670;&#160;</a></span>socket_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t socket_read </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *</td>          <td class="paramname"><span class="paramname"><em>src_addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to read received data buffer from a socket. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000644">Deprecated</a></b></dt><dd></dd></dl>
<p>Used by the application to get data from a socket. See <a class="el" href="socket__api_8h.html#ac7ed5c1ac957864decc0075decd8ad2d" title="A function to read received data buffer from a socket.">socket_recvfrom()</a> for more details.</p>
<p>This is equivalent to socket_recvfrom, except that it passes the flag NS_MSG_LEGACY0, which modifies the return behaviour for zero data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">src_addr</td><td>A pointer to a structure where the sender's address is stored. May be NULL if not required. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an array where the read data is written to. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum length of the allocated buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 indicates the length of the data copied to buffer. </dd>
<dd>
0 if no data was read (includes zero-length datagram, end of stream and no data currently available) </dd>
<dd>
-1 invalid input parameters. </dd></dl>

</div>
</div>
<a id="a214d3be1d867315bf7e144dc6a796f99" name="a214d3be1d867315bf7e144dc6a796f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214d3be1d867315bf7e144dc6a796f99">&#9670;&#160;</a></span>socket_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t socket_recv </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to read received data buffer from a socket,. </p>
<p>Equivalent to socket_recvfrom with src_address set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an array where the read data is written to. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum length of the allocated buffer. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags for read call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>as for socket_recvfrom </dd></dl>

</div>
</div>
<a id="ac7ed5c1ac957864decc0075decd8ad2d" name="ac7ed5c1ac957864decc0075decd8ad2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ed5c1ac957864decc0075decd8ad2d">&#9670;&#160;</a></span>socket_recvfrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t socket_recvfrom </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *</td>          <td class="paramname"><span class="paramname"><em>src_addr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to read received data buffer from a socket. </p>
<p>Used by the application to get data from a socket.</p>
<p>This has two modes of operation.</p>
<p>1) For non-stream sockets, if the receive queue is disabled (set to 0 via SOCKET_SO_RCVBUF), which is the non-stream default and original <a class="el" href="classNanostack.html">Nanostack</a> behaviour, then applications receive exactly one SOCKET_DATA callback per datagram, indicating that datagram's length. They must make 1 read call in that callback, and they will be given the data. If not read, the datagram is discarded on return from the callback.</p>
<p>2) Otherwise - stream sockets or SOCKET_SO_RCVBUF non-zero - behaviour is akin to traditional BSD. SOCKET_DATA callbacks occur when new data arrives, and read calls can be made any time. Data will be queued to an extent determined by the receive buffer size. The length in the data callback is the total amount of data in the receive queue - possibly multiple datagrams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an array where the read data is written to. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum length of the allocated buffer. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags for read call </td></tr>
    <tr><td class="paramname">src_addr</td><td>A pointer to a structure where the sender's address is stored. May be NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<p>The returned length is normally the length of data actually written to the buffer; if NS_MSG_TRUNC is set in flags, then for non-stream sockets, the actual datagram length is returned instead, which may be larger than the buffer size.</p>
<p>Return values assume flag NS_MSG_LEGACY0 is not set - if it is set, they are as per <a class="el" href="socket__api_8h.html#a45c3af52fc3dd173a10186f89cc74e3d" title="A function to read received data buffer from a socket.">socket_read()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 indicates the length of the data copied to buffer (or original datagram size) </dd>
<dd>
0 if end of stream or zero-length datagram </dd>
<dd>
-1 invalid input parameters. </dd>
<dd>
NS_EWOULDBLOCK if no data is currently available </dd></dl>

</div>
</div>
<a id="aa15147f986ce27671c3329035b770116" name="aa15147f986ce27671c3329035b770116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15147f986ce27671c3329035b770116">&#9670;&#160;</a></span>socket_recvmsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t socket_recvmsg </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structns__msghdr.html">ns_msghdr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to read received message with ancillary data from a socket. </p>
<p>Used by the application to get data from a socket. See socket_recvfrom for details of the two delivery mechanisms.</p>
<p>Ancillary data must request by <a class="el" href="socket__api_8h.html#a3580e586ae6d714b6ca3a04d1f8b8693" title="Set an option for a socket.">socket_setsockopt()</a>.</p>
<p>msg-&gt;msg_controllen is updated to indicate actual length of ancillary data output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">msg</td><td>A pointer to a structure where messages is stored with or without ancillary data </td></tr>
    <tr><td class="paramname">flags</td><td>A flags for message read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>as for socket_recvfrom </dd></dl>
<p>Validate socket id</p>
<p>Validate message payload buffer size</p>
<p>Write Ancillary</p>

</div>
</div>
<a id="a8e8d6315f44d135a08ae9d7d2c7e6cd1" name="a8e8d6315f44d135a08ae9d7d2c7e6cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8d6315f44d135a08ae9d7d2c7e6cd1">&#9670;&#160;</a></span>socket_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t socket_send </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data via a connected socket by client. </p>
<p>Note: The socket connection must be ready before using this function. The stack uses automatically the address of the remote connected host as the destination address for the packet.</p>
<p>This call is equivalent to <a class="el" href="socket__api_8h.html#ad69df1f91ca3395824d3f6a499da06c3" title="A function to send UDP, TCP or raw ICMP data via the socket.">socket_sendto()</a> with address set to NULL - see that call for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to data. </td></tr>
    <tr><td class="paramname">length</td><td>Data length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca0d3c19054a92ee77ce38b5d32e46da" name="aca0d3c19054a92ee77ce38b5d32e46da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0d3c19054a92ee77ce38b5d32e46da">&#9670;&#160;</a></span>socket_sendmsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t socket_sendmsg </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structns__msghdr.html">ns_msghdr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to send UDP, TCP or raw ICMP data via the socket with or without ancillary data or destination address. </p>
<p>Used by the application to send data message header support also vector list <a class="el" href="socket__api_8h.html#a8e8d6315f44d135a08ae9d7d2c7e6cd1" title="Send data via a connected socket by client.">socket_send()</a> and <a class="el" href="socket__api_8h.html#ad69df1f91ca3395824d3f6a499da06c3" title="A function to send UDP, TCP or raw ICMP data via the socket.">socket_sendto()</a> use this functionality internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">msg</td><td>A pointer to the Message header which include address, payload and ancillary data. </td></tr>
    <tr><td class="paramname">flags</td><td>A flags for message send (eg NS_MSG_LEGACY0)</td></tr>
  </table>
  </dd>
</dl>
<p>Messages destination address is defined by msg-&gt;msg_name which must be <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a>. If msg-&gt;msg_nme is NULL socket select connected address</p>
<p>Messages payload and length is defined msg-&gt;msg_iov and msg-&gt;msg_iovlen. API support to send multiple data vector.</p>
<p>Supported ancillary data for send defined by msg-&gt;msg_control and msg-&gt;msg_controllen.</p>
<p>msg-&gt;msg_flags is unused, and need not be initialised.</p>
<p>The following main return values assume flag NS_MSG_LEGACY0 is not set - if it is set, they are as per <a class="el" href="socket__api_8h.html#ad69df1f91ca3395824d3f6a499da06c3" title="A function to send UDP, TCP or raw ICMP data via the socket.">socket_sendto()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>length if entire amount written (which could be 0) </dd>
<dd>
value &gt;0 and &lt;length if partial amount written (stream only) </dd>
<dd>
NS_EWOULDBLOCK if nothing written due to lack of queue space.</dd></dl>
<p>Error returns:</p>
<dl class="section return"><dt>Returns</dt><dd>-1 Invalid socket ID. </dd>
<dd>
-2 <a class="el" href="classSocket.html">Socket</a> memory allocation fail. </dd>
<dd>
-3 TCP state not established or address scope not defined . </dd>
<dd>
-4 Unknown interface. </dd>
<dd>
-5 <a class="el" href="classSocket.html">Socket</a> not connected </dd>
<dd>
-6 Packet too short (ICMP raw socket error). </dd></dl>

</div>
</div>
<a id="ad69df1f91ca3395824d3f6a499da06c3" name="ad69df1f91ca3395824d3f6a499da06c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69df1f91ca3395824d3f6a499da06c3">&#9670;&#160;</a></span>socket_sendto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t socket_sendto </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ns__address_8h.html#a387b9e0c0bda536f665b79ae4e88b3cf">ns_address_t</a> *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to send UDP, TCP or raw ICMP data via the socket. </p>
<p>Used by the application to send data.</p>
<p>The return of 0 on success is unconventional, and obtained by passing NS_MSG_LEGACY0 to socket_sendmsg internally - to get conventional return values, you can use <a class="el" href="socket__api_8h.html#aca0d3c19054a92ee77ce38b5d32e46da" title="A function to send UDP, TCP or raw ICMP data via the socket with or without ancillary data or destina...">socket_sendmsg()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">address</td><td>A pointer to the destination address information. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to data to be sent. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the data to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 On success (whole packet queued) </dd>
<dd>
NS_EWOULDBLOCK if nothing written due to lack of queue space.</dd></dl>
<p>Error returns:</p>
<dl class="section return"><dt>Returns</dt><dd>-1 Invalid socket ID. </dd>
<dd>
-2 <a class="el" href="classSocket.html">Socket</a> memory allocation fail. </dd>
<dd>
-3 TCP state not established or address scope not defined . </dd>
<dd>
-4 Unknown interface. </dd>
<dd>
-5 <a class="el" href="classSocket.html">Socket</a> not connected </dd>
<dd>
-6 Packet too short (ICMP raw socket error). </dd></dl>

</div>
</div>
<a id="a3580e586ae6d714b6ca3a04d1f8b8693" name="a3580e586ae6d714b6ca3a04d1f8b8693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3580e586ae6d714b6ca3a04d1f8b8693">&#9670;&#160;</a></span>socket_setsockopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_setsockopt </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>opt_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>opt_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>opt_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an option for a socket. </p>
<p>Used to specify miscellaneous options for a socket. Supported levels and names defined above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">level</td><td>The protocol level. </td></tr>
    <tr><td class="paramname">opt_name</td><td>The option name (interpretation depends on level). See <a class="el" href="socket__api_8h.html#OPTNAMES_SOCKET">OPTNAMES_SOCKET</a> and <a class="el" href="socket__api_8h.html#OPTNAMES_IPV6">OPTNAMES_IPV6</a>. </td></tr>
    <tr><td class="paramname">opt_value</td><td>A pointer to value for the specified option. </td></tr>
    <tr><td class="paramname">opt_len</td><td>Size of the data pointed to by the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 invalid socket ID. </dd>
<dd>
-2 invalid/unsupported option. </dd>
<dd>
-3 invalid option value. </dd></dl>

</div>
</div>
<a id="a497ae9406f6f8160c9ec4fb096d7b213" name="a497ae9406f6f8160c9ec4fb096d7b213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497ae9406f6f8160c9ec4fb096d7b213">&#9670;&#160;</a></span>socket_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t socket_shutdown </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>how</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to shut down a connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The ID of the socket to be shut down. </td></tr>
    <tr><td class="paramname">how</td><td>How socket is to be shut down, one of SOCKET_SHUT_XX.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 if the given socket ID is not found, if the socket type is wrong or TCP layer returns a failure. </dd>
<dd>
-2 if socket is not connected. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae33aefdb733b605daf4ab51056557c44" name="ae33aefdb733b605daf4ab51056557c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33aefdb733b605daf4ab51056557c44">&#9670;&#160;</a></span>ns_in6addr_any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ns_in6addr_any[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IPv6 wildcard address IN_ANY </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5fdebfbd0a4b5643a5e85bf3c8b1558b.html">mbed-os</a></li><li class="navelem"><a class="el" href="dir_456207283565120b441ff9733579e7b8.html">connectivity</a></li><li class="navelem"><a class="el" href="dir_bf6e9fbf979cbf4841d7c2ac9c16af92.html">nanostack</a></li><li class="navelem"><a class="el" href="dir_08aa6bb0b2f02b9b5882d5c36d29412f.html">sal-stack-nanostack</a></li><li class="navelem"><a class="el" href="dir_eef37ac994594867baf4b5cfc943b5c3.html">source</a></li><li class="navelem"><a class="el" href="dir_17df3d1cf4ede759380c7f95c0ebf5f8.html">libNET</a></li><li class="navelem"><a class="el" href="dir_c7b2871d12a6750a40cda55ba6c3beb5.html">src</a></li><li class="navelem"><a class="el" href="socket__api_8c.html">socket_api.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
