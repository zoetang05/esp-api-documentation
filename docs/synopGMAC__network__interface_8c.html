<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP API: /home/zoe/Mbed Programs/esp_code/mbed-os/connectivity/drivers/emac/TARGET_NUVOTON_EMAC/TARGET_M460/synopGMAC_network_interface.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ESP API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('synopGMAC__network__interface_8c.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">synopGMAC_network_interface.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;string.h&quot;</code><br />
<code>#include &quot;<a class="el" href="synopGMAC__network__interface_8h_source.html">synopGMAC_network_interface.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a44f591bc49c756ce38c24ff6f47d3e7a" id="r_a44f591bc49c756ce38c24ff6f47d3e7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44f591bc49c756ce38c24ff6f47d3e7a">synopGMAC_powerdown_mac</a> (<a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *gmacdev)</td></tr>
<tr class="separator:a44f591bc49c756ce38c24ff6f47d3e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d93fad66fdd37114ea1e71f1f0a34ae" id="r_a3d93fad66fdd37114ea1e71f1f0a34ae"><td class="memItemLeft" align="right" valign="top"><a id="a3d93fad66fdd37114ea1e71f1f0a34ae" name="a3d93fad66fdd37114ea1e71f1f0a34ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synopGMAC_powerup_mac</b> (<a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *gmacdev)</td></tr>
<tr class="separator:a3d93fad66fdd37114ea1e71f1f0a34ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf83572552e880d2cb7fc67a769f71f5" id="r_aaf83572552e880d2cb7fc67a769f71f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf83572552e880d2cb7fc67a769f71f5">synopGMAC_setup_tx_desc_queue</a> (<a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *gmacdev, <a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> no_of_desc, <a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> desc_mode)</td></tr>
<tr class="separator:aaf83572552e880d2cb7fc67a769f71f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff52a50e3c3b2f1336860c946c050bb7" id="r_aff52a50e3c3b2f1336860c946c050bb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff52a50e3c3b2f1336860c946c050bb7">synopGMAC_setup_rx_desc_queue</a> (<a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *gmacdev, <a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> no_of_desc, <a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> desc_mode)</td></tr>
<tr class="separator:aff52a50e3c3b2f1336860c946c050bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a1df8f438b6f550265d6ebf00dd6d4" id="r_a49a1df8f438b6f550265d6ebf00dd6d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49a1df8f438b6f550265d6ebf00dd6d4">synopGMAC_giveup_rx_desc_queue</a> (<a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *gmacdev, <a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> desc_mode)</td></tr>
<tr class="separator:a49a1df8f438b6f550265d6ebf00dd6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884a20254db62e5583df2e66fbe280bd" id="r_a884a20254db62e5583df2e66fbe280bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a884a20254db62e5583df2e66fbe280bd">synopGMAC_giveup_tx_desc_queue</a> (<a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *gmacdev, <a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> desc_mode)</td></tr>
<tr class="separator:a884a20254db62e5583df2e66fbe280bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8092cd741ef55e236951fde8c11611ad" id="r_a8092cd741ef55e236951fde8c11611ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8092cd741ef55e236951fde8c11611ad">synop_handle_transmit_over</a> (int intf)</td></tr>
<tr class="separator:a8092cd741ef55e236951fde8c11611ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47258a59b23a81709f3ff95e66d6ff45" id="r_a47258a59b23a81709f3ff95e66d6ff45"><td class="memItemLeft" align="right" valign="top"><a id="a47258a59b23a81709f3ff95e66d6ff45" name="a47258a59b23a81709f3ff95e66d6ff45"></a>
<a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>synop_handle_received_data</b> (int intf, <a class="el" href="synopGMAC__plat_8h.html#aed742c436da53c1080638ce6ef7d13de">u8</a> **<a class="el" href="wsf__trace_8c.html#a631cb00ea94506727e7ab9cdd27cf9cd">buf</a>)</td></tr>
<tr class="separator:a47258a59b23a81709f3ff95e66d6ff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242134e6385a598153929385665f2747" id="r_a242134e6385a598153929385665f2747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a242134e6385a598153929385665f2747">synopGMAC0_intr_handler</a> (void)</td></tr>
<tr class="separator:a242134e6385a598153929385665f2747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32805854899fc3e013071d80db2783f9" id="r_a32805854899fc3e013071d80db2783f9"><td class="memItemLeft" align="right" valign="top"><a id="a32805854899fc3e013071d80db2783f9" name="a32805854899fc3e013071d80db2783f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synopGMAC_set_speed</b> (int intf)</td></tr>
<tr class="separator:a32805854899fc3e013071d80db2783f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9e00cee138687add7964f49d188099" id="r_a6d9e00cee138687add7964f49d188099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d9e00cee138687add7964f49d188099">synopGMAC_open</a> (int intf)</td></tr>
<tr class="separator:a6d9e00cee138687add7964f49d188099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baf8f657ed963b926963df9bccc633a" id="r_a3baf8f657ed963b926963df9bccc633a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3baf8f657ed963b926963df9bccc633a">synopGMAC_close</a> (int intf)</td></tr>
<tr class="separator:a3baf8f657ed963b926963df9bccc633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24da1813b5e303bf573f1569cb24bb9b" id="r_a24da1813b5e303bf573f1569cb24bb9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24da1813b5e303bf573f1569cb24bb9b">synopGMAC_xmit_frames</a> (struct <a class="el" href="structsk__buff.html">sk_buff</a> *skb, int intf, <a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> offload_needed, <a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> ts)</td></tr>
<tr class="separator:a24da1813b5e303bf573f1569cb24bb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94da859cd086b8a56c4b6ac4bcc07c53" id="r_a94da859cd086b8a56c4b6ac4bcc07c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94da859cd086b8a56c4b6ac4bcc07c53">synopGMAC_set_mac_address</a> (int intf, <a class="el" href="synopGMAC__plat_8h.html#aed742c436da53c1080638ce6ef7d13de">u8</a> *macaddr)</td></tr>
<tr class="separator:a94da859cd086b8a56c4b6ac4bcc07c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bb73c57e38d8df9fdc66a861a834c9" id="r_a92bb73c57e38d8df9fdc66a861a834c9"><td class="memItemLeft" align="right" valign="top"><a id="a92bb73c57e38d8df9fdc66a861a834c9" name="a92bb73c57e38d8df9fdc66a861a834c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synopGMAC_set_mode</b> (int intf, int mode)</td></tr>
<tr class="separator:a92bb73c57e38d8df9fdc66a861a834c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:affad892b15f9d3493fa47ff57ec0aec1" id="r_affad892b15f9d3493fa47ff57ec0aec1"><td class="memItemLeft" align="right" valign="top"><a id="affad892b15f9d3493fa47ff57ec0aec1" name="affad892b15f9d3493fa47ff57ec0aec1"></a>
<a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GMACdev</b> [GMAC_CNT]</td></tr>
<tr class="separator:affad892b15f9d3493fa47ff57ec0aec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4623f2370e8bdc5e0db15e3a1e0ab4fd" id="r_a4623f2370e8bdc5e0db15e3a1e0ab4fd"><td class="memItemLeft" align="right" valign="top"><a id="a4623f2370e8bdc5e0db15e3a1e0ab4fd" name="a4623f2370e8bdc5e0db15e3a1e0ab4fd"></a>
<a class="el" href="synopGMAC__plat_8h.html#aed742c436da53c1080638ce6ef7d13de">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mac_addr0</b> [6] = DEFAULT_MAC0_ADDRESS</td></tr>
<tr class="separator:a4623f2370e8bdc5e0db15e3a1e0ab4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfe415f14c8492f74a6d19b7c361d85" id="r_a4dfe415f14c8492f74a6d19b7c361d85"><td class="memItemLeft" align="right" valign="top"><a id="a4dfe415f14c8492f74a6d19b7c361d85" name="a4dfe415f14c8492f74a6d19b7c361d85"></a>
<a class="el" href="synopGMAC__plat_8h.html#aed742c436da53c1080638ce6ef7d13de">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mac_addr1</b> [6] = DEFAULT_MAC1_ADDRESS</td></tr>
<tr class="separator:a4dfe415f14c8492f74a6d19b7c361d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226d57b7bd474c907f6feb82dc119d45" id="r_a226d57b7bd474c907f6feb82dc119d45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDmaDescStruct.html">DmaDesc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a226d57b7bd474c907f6feb82dc119d45">prevtx</a></td></tr>
<tr class="separator:a226d57b7bd474c907f6feb82dc119d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4c664dd1339637f454a66d01e47226" id="r_abd4c664dd1339637f454a66d01e47226"><td class="memItemLeft" align="right" valign="top"><a id="abd4c664dd1339637f454a66d01e47226" name="abd4c664dd1339637f454a66d01e47226"></a>
<a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><b>LPIStsChange</b> = 0</td></tr>
<tr class="separator:abd4c664dd1339637f454a66d01e47226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff47a406096b4c6f9123fcff65da2931" id="r_aff47a406096b4c6f9123fcff65da2931"><td class="memItemLeft" align="right" valign="top"><a id="aff47a406096b4c6f9123fcff65da2931" name="aff47a406096b4c6f9123fcff65da2931"></a>
<a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><b>LPIReg</b> = 0</td></tr>
<tr class="separator:aff47a406096b4c6f9123fcff65da2931"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the network dependent layer to handle network related functionality. This file is tightly coupled to neworking frame work of linux 2.6.xx kernel. The functionality carried out in this file should be treated as an example only if the underlying operating system is not Linux.</p>
<dl class="section note"><dt>Note</dt><dd>Many of the functions other than the device specific functions changes for operating system other than Linux 2.6.xx </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8092cd741ef55e236951fde8c11611ad" name="a8092cd741ef55e236951fde8c11611ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8092cd741ef55e236951fde8c11611ad">&#9670;&#160;</a></span>synop_handle_transmit_over()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synop_handle_transmit_over </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>intf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to handle housekeeping after a packet is transmitted over the wire. After the transmission of a packet DMA generates corresponding interrupt (if it is enabled). It takes care of returning the <a class="el" href="structsk__buff.html">sk_buff</a> to the linux kernel, updating the networking statistics and tracking the descriptors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to net_device structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in interrupt context </dd></dl>

</div>
</div>
<a id="a242134e6385a598153929385665f2747" name="a242134e6385a598153929385665f2747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242134e6385a598153929385665f2747">&#9670;&#160;</a></span>synopGMAC0_intr_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synopGMAC0_intr_handler </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt service routing. This is the function registered as ISR for device interrupts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupt</td><td>number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>pointer to device unique structure (Required for shared interrupts in Linux). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to pt_regs (not used). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns IRQ_NONE if not device interrupts IRQ_HANDLED for device interrupts. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in interrupt context </dd></dl>

</div>
</div>
<a id="a3baf8f657ed963b926963df9bccc633a" name="a3baf8f657ed963b926963df9bccc633a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3baf8f657ed963b926963df9bccc633a">&#9670;&#160;</a></span>synopGMAC_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a> synopGMAC_close </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>intf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function used when the interface is closed.</p>
<p>This function is registered to linux stop() function. This function is called whenever ifconfig (in Linux) closes the device (for example "ifconfig eth0 down"). This releases all the system resources allocated during open call. system resources int needs</p><ul>
<li>Disable the device interrupts</li>
<li>Stop the receiver and get back all the rx descriptors from the DMA</li>
<li>Stop the transmitter and get back all the tx descriptors from the DMA</li>
<li>Stop the Linux network queue interface</li>
</ul>
<p>Free the irq (ISR registered is removed from the kernel)</p><ul>
<li>Release the TX and RX descripor memory</li>
</ul>
<p>De-initialize one second timer rgistered for cable plug/unplug tracking </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to net_device structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and error status upon failure. </dd></dl>

</div>
</div>
<a id="a49a1df8f438b6f550265d6ebf00dd6d4" name="a49a1df8f438b6f550265d6ebf00dd6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a1df8f438b6f550265d6ebf00dd6d4">&#9670;&#160;</a></span>synopGMAC_giveup_rx_desc_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synopGMAC_giveup_rx_desc_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *</td>          <td class="paramname"><span class="paramname"><em>gmacdev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a></td>          <td class="paramname"><span class="paramname"><em>desc_mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This gives up the receive Descriptor queue in ring or chain mode. This function is tightly coupled to the platform and operating system Once device's Dma is stopped the memory descriptor memory and the buffer memory deallocation, is completely handled by the operating system, this call is kept outside the device driver Api. This function should be treated as an example code to de-allocate the descriptor structures in ring mode or chain mode and network buffer deallocation. This function depends on the pcidev structure for dma-able memory deallocation for both descriptor memory and the network buffer memory under linux. The responsibility of this function is to</p><ul>
<li>Free the network buffer memory if any.</li>
</ul>
<p>Fee the memory allocated for the descriptors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to synopGMACdevice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to pci_device structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>of descriptor expected in rx descriptor queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whether</td><td>descriptors to be created in RING mode or CHAIN mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success. Error code upon failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>No referece should be made to descriptors once this function is called. This function is invoked when the device is closed. </dd></dl>

</div>
</div>
<a id="a884a20254db62e5583df2e66fbe280bd" name="a884a20254db62e5583df2e66fbe280bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884a20254db62e5583df2e66fbe280bd">&#9670;&#160;</a></span>synopGMAC_giveup_tx_desc_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synopGMAC_giveup_tx_desc_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *</td>          <td class="paramname"><span class="paramname"><em>gmacdev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a></td>          <td class="paramname"><span class="paramname"><em>desc_mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This gives up the transmit Descriptor queue in ring or chain mode. This function is tightly coupled to the platform and operating system Once device's Dma is stopped the memory descriptor memory and the buffer memory deallocation, is completely handled by the operating system, this call is kept outside the device driver Api. This function should be treated as an example code to de-allocate the descriptor structures in ring mode or chain mode and network buffer deallocation. This function depends on the pcidev structure for dma-able memory deallocation for both descriptor memory and the network buffer memory under linux. The responsibility of this function is to</p><ul>
<li>Free the network buffer memory if any.</li>
</ul>
<p>Fee the memory allocated for the descriptors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to synopGMACdevice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to pci_device structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>of descriptor expected in tx descriptor queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whether</td><td>descriptors to be created in RING mode or CHAIN mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success. Error code upon failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>No reference should be made to descriptors once this function is called. This function is invoked when the device is closed. </dd></dl>

</div>
</div>
<a id="a6d9e00cee138687add7964f49d188099" name="a6d9e00cee138687add7964f49d188099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9e00cee138687add7964f49d188099">&#9670;&#160;</a></span>synopGMAC_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a> synopGMAC_open </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>intf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function used when the interface is opened for use. We register synopGMAC_linux_open function to linux open(). Basically this function prepares the the device for operation . This function is called whenever ifconfig (in Linux) activates the device (for example "ifconfig eth0 up"). This function registers system resources needed</p><ul>
<li>Attaches device to device specific structure</li>
<li>Programs the MDC clock for PHY configuration</li>
<li>Check and initialize the PHY interface</li>
</ul>
<p>ISR registration</p><ul>
<li>Setup and initialize Tx and Rx descriptors</li>
</ul>
<p>Initialize MAC and DMA</p><ul>
<li>Allocate Memory for RX descriptors (The should be DMAable)<ul>
<li>Initialize one second timer to detect cable plug/unplug</li>
</ul>
</li>
<li>Configure and Enable Interrupts</li>
<li>Enable Tx and Rx</li>
<li>start the Linux network queue interface <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to net_device structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and error status upon failure. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a44f591bc49c756ce38c24ff6f47d3e7a" name="a44f591bc49c756ce38c24ff6f47d3e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f591bc49c756ce38c24ff6f47d3e7a">&#9670;&#160;</a></span>synopGMAC_powerdown_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synopGMAC_powerdown_mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *</td>          <td class="paramname"><span class="paramname"><em>gmacdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function used to detect the cable plugging and unplugging. This function gets scheduled once in every second and polls the PHY register for network cable plug/unplug. Once the connection is back the GMAC device is configured as per new Duplex mode and Speed of the connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049" title="Define 32-bit unsigned data type.">u32</a></td><td>type but is not used currently. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns void. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is tightly coupled with Linux 2.6.xx. </dd></dl>

</div>
</div>
<a id="a94da859cd086b8a56c4b6ac4bcc07c53" name="a94da859cd086b8a56c4b6ac4bcc07c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94da859cd086b8a56c4b6ac4bcc07c53">&#9670;&#160;</a></span>synopGMAC_set_mac_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a> synopGMAC_set_mac_address </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>intf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="synopGMAC__plat_8h.html#aed742c436da53c1080638ce6ef7d13de">u8</a> *</td>          <td class="paramname"><span class="paramname"><em>macaddr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to set ethernet address of the NIC. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to net_device structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to an address structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success Errorcode on failure. </dd></dl>

</div>
</div>
<a id="aff52a50e3c3b2f1336860c946c050bb7" name="aff52a50e3c3b2f1336860c946c050bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff52a50e3c3b2f1336860c946c050bb7">&#9670;&#160;</a></span>synopGMAC_setup_rx_desc_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a> synopGMAC_setup_rx_desc_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *</td>          <td class="paramname"><span class="paramname"><em>gmacdev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a></td>          <td class="paramname"><span class="paramname"><em>no_of_desc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a></td>          <td class="paramname"><span class="paramname"><em>desc_mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This sets up the receive Descriptor queue in ring or chain mode. This function is tightly coupled to the platform and operating system Device is interested only after the descriptors are setup. Therefore this function is not included in the device driver API. This function should be treated as an example code to design the descriptor structures in ring mode or chain mode. This function depends on the pcidev structure for allocation of consistent dma-able memory in case of linux. This limitation is due to the fact that linux uses pci structure to allocate a dmable memory</p><ul>
<li>Allocates the memory for the descriptors.</li>
<li>Initialize the Busy and Next descriptors indices to 0(Indicating first descriptor).</li>
<li>Initialize the Busy and Next descriptors to first descriptor address.<ul>
<li>Initialize the last descriptor with the endof ring in case of ring mode.</li>
</ul>
</li>
<li>Initialize the descriptors in chain mode. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to synopGMACdevice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to pci_device structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>of descriptor expected in rx descriptor queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whether</td><td>descriptors to be created in RING mode or CHAIN mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success. Error code upon failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function fails if allocation fails for required number of descriptors in Ring mode, but in chain mode function returns -ESYNOPGMACNOMEM in the process of descriptor chain creation. once returned from this function user should for gmacdev-&gt;RxDescCount to see how many descriptors are there in the chain. Should continue further only if the number of descriptors in the chain meets the requirements </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aaf83572552e880d2cb7fc67a769f71f5" name="aaf83572552e880d2cb7fc67a769f71f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf83572552e880d2cb7fc67a769f71f5">&#9670;&#160;</a></span>synopGMAC_setup_tx_desc_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a> synopGMAC_setup_tx_desc_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsynopGMACDeviceStruct.html">synopGMACdevice</a> *</td>          <td class="paramname"><span class="paramname"><em>gmacdev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a></td>          <td class="paramname"><span class="paramname"><em>no_of_desc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a></td>          <td class="paramname"><span class="paramname"><em>desc_mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This sets up the transmit Descriptor queue in ring or chain mode. This function is tightly coupled to the platform and operating system Device is interested only after the descriptors are setup. Therefore this function is not included in the device driver API. This function should be treated as an example code to design the descriptor structures for ring mode or chain mode. This function depends on the pcidev structure for allocation consistent dma-able memory in case of linux. This limitation is due to the fact that linux uses pci structure to allocate a dmable memory</p><ul>
<li>Allocates the memory for the descriptors.</li>
<li>Initialize the Busy and Next descriptors indices to 0(Indicating first descriptor).</li>
<li>Initialize the Busy and Next descriptors to first descriptor address.<ul>
<li>Initialize the last descriptor with the endof ring in case of ring mode.</li>
</ul>
</li>
<li>Initialize the descriptors in chain mode. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to synopGMACdevice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to pci_device structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>of descriptor expected in tx descriptor queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whether</td><td>descriptors to be created in RING mode or CHAIN mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success. Error code upon failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function fails if allocation fails for required number of descriptors in Ring mode, but in chain mode function returns -ESYNOPGMACNOMEM in the process of descriptor chain creation. once returned from this function user should for gmacdev-&gt;TxDescCount to see how many descriptors are there in the chain. Should continue further only if the number of descriptors in the chain meets the requirements </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a24da1813b5e303bf573f1569cb24bb9b" name="a24da1813b5e303bf573f1569cb24bb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24da1813b5e303bf573f1569cb24bb9b">&#9670;&#160;</a></span>synopGMAC_xmit_frames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="synopGMAC__plat_8h.html#a0ce6887c26c1c49ad3be5710dd42bfd6">s32</a> synopGMAC_xmit_frames </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsk__buff.html">sk_buff</a> *</td>          <td class="paramname"><span class="paramname"><em>skb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>intf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a></td>          <td class="paramname"><span class="paramname"><em>offload_needed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="synopGMAC__plat_8h.html#a10e94b422ef0c20dcdec20d31a1f5049">u32</a></td>          <td class="paramname"><span class="paramname"><em>ts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to transmit a given packet on the wire. Whenever Linux Kernel has a packet ready to be transmitted, this function is called. The function prepares a packet and prepares the descriptor and enables/resumes the transmission. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to <a class="el" href="structsk__buff.html">sk_buff</a> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to net_device structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and Error code on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>structure <a class="el" href="structsk__buff.html">sk_buff</a> is used to hold packet in Linux networking stacks. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a226d57b7bd474c907f6feb82dc119d45" name="a226d57b7bd474c907f6feb82dc119d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226d57b7bd474c907f6feb82dc119d45">&#9670;&#160;</a></span>prevtx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDmaDescStruct.html">DmaDesc</a>* prevtx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to Receive a packet from the interface. After Receiving a packet, DMA transfers the received packet to the system memory and generates corresponding interrupt (if it is enabled). This function prepares the <a class="el" href="structsk__buff.html">sk_buff</a> for received packet after removing the ethernet CRC, and hands it over to linux networking stack.</p><ul>
<li>Updataes the networking interface statistics</li>
</ul>
<p>Keeps track of the rx descriptors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to net_device structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in interrupt context. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5fdebfbd0a4b5643a5e85bf3c8b1558b.html">mbed-os</a></li><li class="navelem"><a class="el" href="dir_456207283565120b441ff9733579e7b8.html">connectivity</a></li><li class="navelem"><a class="el" href="dir_59977a0c207738c890dea4a1d368376e.html">drivers</a></li><li class="navelem"><a class="el" href="dir_8a9d34223ea507ff0ee5010536533647.html">emac</a></li><li class="navelem"><a class="el" href="dir_088300282ce285043e44850e9037bc1c.html">TARGET_NUVOTON_EMAC</a></li><li class="navelem"><a class="el" href="dir_e7090f94c9ef8ef505e62a7dd91af8d4.html">TARGET_M460</a></li><li class="navelem"><a class="el" href="synopGMAC__network__interface_8c.html">synopGMAC_network_interface.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
